<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Средневековое Подземелье</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background: url('background.png') no-repeat center center fixed;
    background-size: cover;
}

        canvas {
            display: block;
            background: #000;
        }
        .crosshair {
            position: absolute;
            width: 60px;
            height: 60px;
            background: url('crosshair.png') no-repeat center;
            background-size: contain;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-in-out;
            display: none;
        }
        #bottomMenu {
            position: fixed;
            bottom: 0;
            left: 210px;
            width: 100%;
            height: 60px;
            background: #333;
            color: white;
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 18px;
        }
        #characterMenu {
    position: fixed;
    top: 0px;
    right: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    display: block; 
    font-size: 16px;
    text-align: center;
    max-width: calc(100vw - 20px); 
    max-height: calc(100vh - 120px); 
    overflow: auto; 
}

#leftCharacterMenu {
        position: fixed;
        top: 0px;
        left: 0px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        display: block;
        font-size: 16px;
        text-align: center;
        max-width: calc(100vw - 20px);
        max-height: calc(100vh - 20px);
        overflow: auto;
        display: none; /* Скрываем по умолчанию */
    }
        /* Добавляем стили для новой кнопки */
        #fullscreenButton {
            position: fixed;
            bottom: 60px;
            right: 0px;
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }



        #shopMenu {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        #shopItems {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .shop-item {
            margin: 10px;
            text-align: center;
            cursor: pointer;
        }
        .shop-item img {
            width: 100px;
            height: 100px;
            border-radius: 10px;
            transition: transform 0.3s;
        }
        .shop-item img:hover {
            transform: scale(1.1);
        }
        #itemDetail {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #itemDetail img {
            max-width: 100%;
            max-height: 80vh;
        }
        #itemDetail button {
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }
        .status-bar {
            position: fixed;
            top: 10px;
            left: 300px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
        .status-bar p {
            margin: 8px 0;
            font-size: 18px; /* Установите желаемый размер шрифта */
        }
        .health-bar {
            background: #555;
            border-radius: 5px;
            overflow: hidden;
            width: 200px;
            height: 20px;
            margin-bottom: 10px;
        }
        .health-bar-inner {
            height: 100%;
            background: #0f0;
        }
        .monster-health-bar-inner {
            height: 100%;
            background: #f00; /* Red for monster health */
        }
        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        .hero img {
        width: 175px;
        height: 242px;
        border-radius: 10px;
        transition: filter 0.3s;
    }

    .hero.not-hired img {
        filter: brightness(10%);
    }

    .hero.hired img {
        filter: brightness(100%);
    }
        #characterImage {
            width: 297px;
            height: 500px;
        }
        #nicknameMenu {
            display: block;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #topPlayersMenu {
            display: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #gameVersion {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
        }
        #continuePrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        #continuePrompt button {
            margin: 5px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #fff;
            border: none;
            padding: 5px;
            cursor: pointer;
        }
        .monster-message {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
            display: none;
        }
        #weaponInfo, #healthInfo {
            display: none; /* Скрываем элементы оружия и здоровья */
        }

        #mailButton {
            position: fixed;
            top: 100px;
            left: 300px;
            width: 150px;
            height: 150px;
            background: url('mail.png') no-repeat center;
            background-size: cover;
            cursor: pointer;
            transition: transform 0.3s;
            display: none; /* Скрыта по умолчанию */
        }
        #mailButton:hover {
            transform: scale(1.1);
        }
        #mailWindow {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 400px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
        }
        #rebornButton {
    position: fixed;
    top: 5px;
    right: 325px;
    width: 200px;
    height: 200px;
    background: url('reborn.png') no-repeat center;
    background-size: contain;
    cursor: pointer;
    z-index: 1000;
    transition: transform 0.3s, box-shadow 0.3s;
}
#rebornButton:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 255, 0, 0.8); /* Добавьте красивую тень */
}
#rebornPrompt {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    z-index: 2000;
}

#rebornPrompt button {
    margin: 10px;
    padding: 10px;
    background: #fff;
    border: none;
    cursor: pointer;
}
#monsterHealthContainer {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 30%; /* Ширина контейнера */
    height: 50px; /* Высота контейнера */
    background-color: rgba(255, 0, 0, 0.2); /* Полупрозрачный фон для контейнера */
    border-radius: 15px;
    overflow: hidden; /* Обрезка содержимого */
    display: none; /* Скрыть по умолчанию */
}

#monsterHealthBar {
    height: 100%; /* Высота полоски равна высоте контейнера */
    background-color: green; /* Цвет полоски */
    border-radius: 15px; /* Округленные углы */
    transition: width 0.5s; /* Плавный переход ширины */
}

#monsterHealthValue {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 32px;
    line-height: 50px; /* Высота строки совпадает с высотой контейнера */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Тень для текста */
    font-weight: bold; /* Жирный текст */
    padding: 0 10px; /* Отступы по бокам */
    border: 2px solid rgba(0, 0, 0, 0.5); /* Обводка вокруг текста */
    border-radius: 5px; /* Скругленные углы */
    background-color: rgba(0, 0, 0, 0.3); /* Полупрозрачный фон */
}

#chatContainer {
    position: fixed;
    bottom: 60px;
    left: 210px;
    width: 300px;
    max-height: 400px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    border-radius: 5px;
    overflow: auto;
    display: flex;
    flex-direction: column;
    padding: 10px;
}

#chatMessages {
    flex-grow: 1;
    overflow-y: auto;
}

#chatInput {
    display: flex;
    margin-top: 10px;
}

#chatInput input {
    flex-grow: 1;
    padding: 5px;
    border: none;
    border-radius: 3px;
}

#chatInput button {
    margin-left: 5px;
    padding: 5px 10px;
    border: none;
    border-radius: 3px;
    background-color: #333;
    color: white;
    cursor: pointer;
}
/* Основные стили кнопок */
button.upgrade-button, button.hire-button {
    background: linear-gradient(to right, #ff416c, #ff4b2b); /* Градиентный фон */
    border: none;
    border-radius: 10px; /* Скругленные углы */
    color: white;
    cursor: pointer;
    font-size: 18px; /* Увеличенный размер шрифта */
    padding: 10px 20px;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 15px rgba(255, 75, 43, 0.4); /* Тень для кнопок */
}

/* Эффект наведения на кнопку */
button.upgrade-button:hover, button.hire-button:hover {
    transform: scale(1.05); /* Легкое увеличение кнопки */
    box-shadow: 0 6px 20px rgba(255, 75, 43, 0.6); /* Более яркая тень при наведении */
}
#toggleAutoboyButton {
    position: fixed;
    bottom: 100px; /* Расположение кнопки над кнопкой "Полноэкранный режим" */
    right: 0px;
    padding: 10px 20px;
    background: #333;
    color: white;
    border: none;
    cursor: pointer;
    font-size: 16px;
    z-index: 1000;
    display: none; /* Скрываем по умолчанию */
}
#pvpButton {
            position: fixed;
            bottom: 210px;
            left: 790px;
            width: 200px;
            height: 200px;
            background: url('Sworddouble.png') no-repeat center;
            background-size: contain;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            display: none; /* Скрываем по умолчанию */
        }

        #pvpButton:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
        }
        
        /* Стиль для окна регистрации на PvP */
        #pvpRegistration {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
        }

        #pvpRegistration button {
            margin: 10px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }
        #pvpBattle {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
        }
        #pvpBattle button {
            margin: 10px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }

    </style>
</head>
<body>
    <button id="fullscreenButton" onclick="toggleFullscreen()">Полноэкранный режим</button>
    <button id="toggleAutoboyButton" onclick="toggleAutoboy()">Отключить автобой</button>
    <div id="pvpButton" onclick="openPvpRegistration()"></div>
    <div id="nicknameMenu">
        <h2>Введите свой никнейм</h2>
        <input type="text" id="nicknameInput" placeholder="Ваш никнейм">
        <button onclick="startGame()">Начать игру</button>
        <div id="gameVersion">Версия игры: 1.15</div>
    </div>
    <canvas id="gameCanvas" style="display:none;"></canvas>
    <div id="bottomMenu" style="display:none;">
        <div onclick="changeScreen('arena')">Арена</div>
        <div onclick="changeScreen('dungeon')">Подземелье</div>
        <div onclick="changeScreen('raid')">Рейд</div>
        <div onclick="changeScreen('castle')">Замок</div>
        <div onclick="changeScreen('levels')">Уровни</div>
        <div onclick="changeScreen('worldBoss')">Мировой Босс</div>
        <div onclick="toggleShop()">Магазин</div>
        <div onclick="toggleTopPlayers()">Топ игроки</div>
       
    </div>

    <div id="chatContainer">
        <div id="chatMessages"></div>
        <div id="chatInput">
            <input type="text" id="chatMessageInput" placeholder="Введите сообщение...">
            <button onclick="sendMessage()">Отправить</button>
        </div>
    </div>

    <div id="pvpRegistration">
        <h2>Хотите зарегистрироваться на бой PvP?</h2>
        <button onclick="registerForPvp()">Да</button>
        <button onclick="closePvpRegistration()">Нет</button>
    </div>
    <div id="pvpBattle" style="display:none;">
        <h2>Бой PvP</h2>
        <div id="pvpOpponentInfo"></div>
        <div id="pvpFightLog"></div>
        <button onclick="endPvpBattle()">Завершить бой</button>
    </div>

    <div id="monsterHealthContainer">
        <div id="monsterHealthBar"></div>
        <div id="monsterHealthValue"></div>
    </div>
    <div id="monsterHealthDisplay">
        <span style="font-size: 30px; margin-right: 10px;">❤️</span>
        Здоровье монстра <span id="monsterHealthValue"></span>
    </div>
    

    


    <!-- Добавляем кнопку с изображением письма -->
    <div id="mailButton" onclick="toggleMailWindow()"></div>

    <!-- Окно почты -->
    <div id="mailWindow">
        <h2>Ваша почта</h2>
        <p>Здесь будут отображаться ваши награды.</p>
        <button onclick="toggleMailWindow()">Закрыть</button>
    </div>

    <div id="rebornButton" onclick="showRebornPrompt()"></div>
    <div id="rebornPrompt">
        <h2>Вы хотите переродиться?</h2>
        <p>Прогресс уровней, нанятые герои и накопленное золото будут сброшены. Но вы будете получать награды за убийство монстров в два раза выше.</p>
        <button onclick="confirmReborn()">Да</button>
        <button onclick="hideRebornPrompt()">Нет</button>
    </div>
    
    

    

    <div id="worldBossScreen" style="display:none;">
        <h2>Мировой Босс</h2>
        <img id="worldBossImage" src="world_boss.png" alt="Мировой Босс">
        <div id="worldBossHealth">Здоровье Босса: <span id="worldBossHealthValue">1000000</span></div>
        <div id="playersDamageList">
            <h3>Список игроков</h3>
            <ul id="damageList"></ul>
        </div>
    </div>
   
    <div id="leftCharacterMenu">
        <!-- Контент меню для найма героев слева будет динамически добавлен через JavaScript -->
    </div>
    
    </div>
    <div id="characterMenu">
        <img id="characterImage" src="peasant.png" alt="Character">
        <p style="display:none;">Оружие: <span id="weapon"></span></p> <!-- Скрытый элемент для отображения оружия -->
        <p style="display:none;">Здоровье: <span id="health"></span></p> <!-- Скрытый элемент для отображения здоровья -->
        <p style="display:none;">Уровень: <span id="level"></span></p>
        <p style="display:none;">Золото: <span id="gold"></span></p>
        <p style="display:none;"><span id="totalDamage">Суммарный урон: 0</p>

        <p style="display:none;">Урон: <span id="damage"></span></p>
        
        
        
    </div>
    <div id="shopMenu">
        <button class="close-btn" onclick="toggleShop()">X</button>
        <h2>Магазин</h2>
        <p>Золото: <span id="shopGold"></span></p>
        <div id="shopItems">
            <div class="shop-item" onclick="showItemDetail('sword.png', 'Меч (+10 сила)', 50, 'sword', 10)">
                <img src="sword_thumb.png" alt="Меч">
                <p>Меч</p>
                <p>50 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('bow.png', 'Лук (+8 сила)', 40, 'bow', 8)">
                <img src="bow_thumb.png" alt="Лук">
                <p>Лук</p>
                <p>40 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('crossbow.png', 'Арбалет (+12 сила)', 60, 'crossbow', 12)">
                <img src="crossbow_thumb.png" alt="Арбалет">
                <p>Арбалет</p>
                <p>60 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('armor.png', 'Доспехи (+15 защита)', 70, 'armor', 15)">
                <img src="armor_thumb.png" alt="Доспехи">
                <p>Доспехи</p>
                <p>70 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('helmet.png', 'Шлем (+5 защита)', 30, 'helmet', 5)">
                <img src="helmet_thumb.png" alt="Шлем">
                <p>Шлем</p>
                <p>30 золота</p>
            </div>
            
        </div>
    </div>
    <div id="topPlayersMenu">
        <button onclick="toggleTopPlayers()">Закрыть</button>
    </div>

    <div class="status-bar" id="statusBar" style="display:none;">
        <div class="health-bar">
            <div class="health-bar-inner" id="playerHealthBar"></div>
        </div>
        <p>Уровень: <span id="statusLevel"></span></p>
        <p> <img src="gold_icon.png" alt="Gold Icon" style="width: 30px; height: 30px; vertical-align: middle;"> <span id="statusGold"></span></p>
        <p> <img src="damage_icon.png" alt="Gold Icon" style="width: 30px; height: 30px; vertical-align: middle;"> <span id="statusDamage"></span></p>
        <p>Множитель награды: <span id="statusRewardMultiplier"></span></p> <!-- Новый элемент для отображения множителя награды -->
    </div>
    



    
    <div class="victory-message" id="victoryMessage">
        <p>Shap в печали, что вы его бьете :(</p>
    </div>
    

    
    
    <div class="crosshair" id="crosshair"></div>
    <div id="itemDetail">
        <img id="itemDetailImage" src="" alt="Item Detail">
        <p id="itemDetailName"></p>
        <button onclick="buyItem()">Купить</button>
        <button onclick="closeItemDetail()">Закрыть</button>
    </div>
    <div id="continuePrompt">
        <img id="victoryImage" src="win2.png" alt="Вы победили" style="display: none; width: 700px; height: auto;">
        <p>Shap в печали, что вы его бьете :(</p>
        <p>Вы хотите продолжить унижать Shap и убить следующего монстра?</p>
        <div id="goldEarned" style="display: none; font-size: 24px; color: gold; font-family: 'Comic Sans MS', cursive, sans-serif;">Золото: <span id="goldAmount"></span></div>
        
    </div>
    
    
    
    <div class="monster-message" id="monsterMessage"></div>
    <script type="module">

let rewardMultiplier = 1; // Начальное значение множителя награды


    // Данные о героях
    let allHeroes = [
    { name: 'Эльф', level: 1, baseDamage: 5, baseCost: 50, damage: 5, cost: 50, img: 'hero1.png', hired: false },
    { name: 'Гном', level: 1, baseDamage: 10, baseCost: 100, damage: 10, cost: 100, img: 'hero2.png', hired: false },
    { name: 'хоббит', level: 1, baseDamage: 20, baseCost: 250, damage: 20, cost: 250, img: 'hero3.png', hired: false },
    { name: 'Тор', level: 1, baseDamage: 30, baseCost: 500, damage: 30, cost: 500, img: 'hero4.png', hired: false },
    { name: 'Кузнечик', level: 1, baseDamage: 40, baseCost: 1000, damage: 40, cost: 1000, img: 'hero5.png', hired: false },
    { name: 'Лесной зверек', level: 1, baseDamage: 60, baseCost: 2000, damage: 60, cost: 2000, img: 'hero6.png', hired: false },
    { name: 'Дюймовочка', level: 1, baseDamage: 80, baseCost: 4000, damage: 80, cost: 4000, img: 'hero7.png', hired: false },
    { name: 'Зевс', level: 1, baseDamage: 100, baseCost: 8000, damage: 100, cost: 8000, img: 'hero8.png', hired: false },
    { name: 'Аполлон', level: 1, baseDamage: 120, baseCost: 16000, damage: 120, cost: 16000, img: 'hero9.png', hired: false },
    { name: 'Олимп', level: 1, baseDamage: 200, baseCost: 100000, damage: 200, cost: 100000, img: 'hero10.png', hired: false }
];
let initialHeroes = allHeroes.slice(0, 5); // Начальные герои
let heroes = [...initialHeroes];
// Функция для миграции данных героев

function showRebornPrompt() {
    const playerLevel = currentLevel;
    let rebornPossible = false;
    let nextRebornLevel = 0;

    if (rebornCount === 0 && playerLevel >= 10) {
        rebornPossible = true;
        nextRebornLevel = 20;
    } else if (rebornCount === 1 && playerLevel >= 20) {
        rebornPossible = true;
        nextRebornLevel = 30;
    } else if (rebornCount === 2 && playerLevel >= 30) {
        rebornPossible = true;
        nextRebornLevel = 40;
    } else if (rebornCount === 3 && playerLevel >= 40) {
        rebornPossible = true;
        nextRebornLevel = 50;
    } else if (rebornCount === 4 && playerLevel >= 50) {
        rebornPossible = true;
        nextRebornLevel = 60;
    } else if (rebornCount === 5 && playerLevel >= 60) {
        rebornPossible = true;
        nextRebornLevel = 70;
    } else if (playerLevel >= 100) {
        rebornPossible = true;
        nextRebornLevel = playerLevel + 10; // или любое другое значение для следующего перерождения
    }

    if (rebornPossible) {
        document.getElementById('rebornPrompt').style.display = 'block';
        document.getElementById('rebornPrompt').querySelector('p').textContent = `Прогресс уровней, нанятые герои и накопленное золото будут сброшены. Но вы будете получать награды за убийство монстров в ${1 + rebornCount * 0.1} раза выше. Следующее перерождение доступно с уровня ${nextRebornLevel}.`;
    } else {
        alert('Ваш уровень недостаточно высок для перерождения.');
    }
}
window.showRebornPrompt = showRebornPrompt;



// Функция для перерождения
function confirmReborn() {
    hideRebornPrompt();
    levels = new Array(10000).fill().map((_, i) => ({ number: i + 1, stars: 0, completed: false }));
    heroes.forEach(hero => {
        const baseDamage = hero.baseDamage || 0;
        const baseCost = hero.baseCost || 0;

        hero.level = 0;
        hero.hired = false;
        hero.damage = calculateHeroStats(1, baseDamage, baseCost).newDamage;
        hero.cost = baseCost;
    });
    currentLevel = 1;
    rebornCount++;
    rewardMultiplier = Math.min(1 + rebornCount * 0.1, 9999);
    
    // Обновить список героев для включения новых героев после перерождения
    heroes = allHeroes;

    updateGold(100).then(() => {
        updateCharacterMenu();
        addHeroesToMenu();
        startLevel(currentLevel);
        alert(`Вы переродились! Теперь вы будете получать награды за убийство монстров в ${rewardMultiplier.toFixed(1)} раза выше.`);
        
        saveProgress().then(() => {
            console.log('Progress saved after reborn');
            updateStatusBar();
        }).catch(error => {
            console.error('Error saving progress after reborn:', error);
        });
    }).catch(error => {
        console.error('Error updating gold:', error);
    });
}
window.confirmReborn = confirmReborn;







// Функция для миграции данных героев
function migrateHeroData(oldHeroes) {
    return oldHeroes.map(oldHero => {
        const newHero = allHeroes.find(hero => hero.name === oldHero.name);
        if (newHero) {
            return {
                ...newHero,
                level: oldHero.level,
                damage: calculateHeroStats(oldHero.level, newHero.baseDamage, newHero.baseCost).newDamage,
                cost: calculateHeroStats(oldHero.level, newHero.baseDamage, newHero.baseCost).newCost,
                hired: oldHero.hired,
            };
        }
        return oldHero;
    });
}
window.migrateHeroData = migrateHeroData;








function createHeroElement(hero) {
    const heroDiv = document.createElement('div');
    heroDiv.className = `hero ${hero.hired ? 'hired' : 'not-hired'}`;

    const heroImg = document.createElement('img');
    heroImg.src = hero.img;
    heroImg.alt = hero.name;
    heroDiv.appendChild(heroImg);

    const heroName = document.createElement('p');
    heroName.textContent = hero.name;
    heroDiv.appendChild(heroName);

    const heroLevel = document.createElement('p');
    heroLevel.textContent = `Ур.: ${hero.level}`;
    heroDiv.appendChild(heroLevel);

    const heroDamage = document.createElement('p');
    heroDamage.textContent = `Урон: ${hero.damage}`;
    heroDiv.appendChild(heroDamage);

    const heroCost = document.createElement('p');
    const upgradeCost = hero.hired ? calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost).newCost : hero.cost;
    heroCost.textContent = `Стоимость: ${upgradeCost}`;
    heroDiv.appendChild(heroCost);

    const hireButton = document.createElement('button');
    hireButton.className = hero.hired ? 'upgrade-button' : 'hire-button'; // Присваиваем класс кнопке
    hireButton.textContent = hero.hired ? 'Улучшить' : 'Нанять';
    hireButton.onclick = () => {
        hireOrUpgradeHero(hero, heroDiv, hireButton);
    };
    heroDiv.appendChild(hireButton);

    return heroDiv;
}

window.createHeroElement = createHeroElement;


    // Функция для добавления героев в меню
    function addHeroesToMenu() {
    const leftCharacterMenu = document.getElementById('leftCharacterMenu');
    leftCharacterMenu.innerHTML = ''; // Очистка меню перед добавлением героев
    heroes.forEach(hero => {
        const heroElement = createHeroElement(hero);
        leftCharacterMenu.appendChild(heroElement);
    });
}
window.addHeroesToMenu = addHeroesToMenu;



function hireOrUpgradeHero(hero, heroDiv, hireButton) {
    console.log(`Начало функции hireOrUpgradeHero для ${hero.name}, уровень: ${hero.level}, золото: ${gold}`);

    if (!hero.hired && gold >= hero.cost) {
        // Найм героя
        console.log(`Найм героя ${hero.name} за ${hero.cost} золота`);
        gold -= hero.cost;
        hero.hired = true;
        hero.level = 1; // Устанавливаем начальный уровень при найме
        const stats = calculateHeroStats(hero.level, hero.baseDamage, hero.baseCost);
        hero.damage = stats.newDamage;
        hero.cost = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost).newCost; // Обновляем стоимость для следующего улучшения
        totalDamage += hero.damage;
        console.log(`Герой ${hero.name} нанят: уровень ${hero.level}, урон ${hero.damage}, следующая стоимость улучшения ${hero.cost}`);
        heroDiv.classList.remove('not-hired');
        heroDiv.classList.add('hired');
        hireButton.textContent = 'Улучшить';
        updateHeroElement(hero, heroDiv); // Обновляем элементы героя в интерфейсе
    } else if (hero.hired) {
        // Улучшение героя
        console.log(`Улучшение героя ${hero.name}`);
        const stats = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost);
        const upgradeCost = stats.newCost;
        console.log(`Текущая стоимость улучшения: ${hero.cost}, Новая стоимость улучшения: ${upgradeCost}`);
        if (gold >= upgradeCost) {
            console.log(`Герой ${hero.name} улучшается за ${upgradeCost} золота`);
            gold -= upgradeCost;
            totalDamage -= hero.damage;
            hero.level++;
            hero.damage = stats.newDamage;
            hero.cost = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost).newCost; // Обновляем стоимость для следующего улучшения
            totalDamage += hero.damage;
            console.log(`Герой ${hero.name} улучшен: уровень ${hero.level}, урон ${hero.damage}, следующая стоимость улучшения ${hero.cost}`);
            hireButton.textContent = 'Улучшить';
            updateHeroElement(hero, heroDiv); // Обновляем элементы героя в интерфейсе
        } else {
            console.log('Недостаточно золота для улучшения!');
        }
    } else {
        console.log('Недостаточно золота для найма!');
    }

    updateTotalDamage();
    localGoldUpdated = true;
    updateStatusBar();
    saveGoldToDatabase().then(() => {
        console.log(`Золото сохранено в базе данных: ${gold}`);
    });
    savePlayerData();
    console.log(`Конец функции hireOrUpgradeHero для ${hero.name}, уровень: ${hero.level}, золото: ${gold}`);
}
window.hireOrUpgradeHero = hireOrUpgradeHero;















function saveGoldToDatabase() {
    const playerGoldRef = ref(database, `players/${nickname}/gold`);
    return set(playerGoldRef, gold).then(() => {
        console.log(`Gold saved to database: ${gold}`);
    }).catch((error) => {
        console.error('Error saving gold to database:', error);
        throw error;
    });
}

function updateHeroElement(hero, heroDiv) {
    console.log(`Обновление элемента героя ${hero.name}: уровень ${hero.level}, урон ${hero.damage}, стоимость ${hero.cost}`);
    heroDiv.querySelector('p:nth-child(3)').textContent = `Ур.: ${hero.level}`;
    heroDiv.querySelector('p:nth-child(4)').textContent = `Урон: ${hero.damage}`;
    heroDiv.querySelector('p:nth-child(5)').textContent = `Стоимость: ${hero.cost}`;
    console.log(`Элемент героя ${hero.name} обновлен в интерфейсе: уровень ${heroDiv.querySelector('p:nth-child(3)').textContent}, урон ${heroDiv.querySelector('p:nth-child(4)').textContent}, стоимость ${heroDiv.querySelector('p:nth-child(5)').textContent}`);
}
window.updateHeroElement = updateHeroElement;





// Функция для обновления суммарного урона
function updateTotalDamage() {
    totalDamage = calculateTotalDamage();
    const totalDamageElement = document.getElementById('totalDamage');
    if (totalDamageElement) {
        totalDamageElement.textContent = `Суммарный урон: ${totalDamage}`;
    }
}
window.updateTotalDamage = updateTotalDamage;


function calculateHeroStats(level, baseDamage, baseCost) {
    const damageMultiplier = 2; // Множитель для урона
    const costMultiplier = 2.4; // Множитель для стоимости
    const newDamage = Math.floor(baseDamage * Math.pow(damageMultiplier, level - 1));
    const newCost = Math.floor(baseCost * Math.pow(costMultiplier, level - 1));
    console.log(`Расчет новых значений для уровня ${level}: урон ${newDamage}, стоимость ${newCost}`);
    return { newDamage, newCost };
}
window.calculateHeroStats = calculateHeroStats;





import { initializeApp } from "https://www.gstatic.com/firebasejs/9.8.4/firebase-app.js";
import { getDatabase, ref, set, get, child, runTransaction, onValue, push, off, remove } from "https://www.gstatic.com/firebasejs/9.8.4/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCPQFqbWCL3XaM-sLYDWgWMdslhS7O7WC8",
            authDomain: "game-7bdb0.firebaseapp.com",
            databaseURL: "https://game-7bdb0-default-rtdb.firebaseio.com",
            projectId: "game-7bdb0",
            storageBucket: "game-7bdb0.appspot.com",
            messagingSenderId: "327382187542",
            appId: "1:327382187542:web:cc82e8673791983404bf37",
            measurementId: "G-8JBZ9PEV84"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        window.currentSessionId = null;

function startSession(nickname) {
    const sessionId = generateSessionId();
    set(ref(database, 'players/' + nickname + '/session'), sessionId);
    return sessionId;
}











async function saveProgress() {
    if (!nickname || !currentSessionId) {
        console.error('Cannot save progress: no nickname or session ID');
        return;
    }

    const progressData = {
        currentLevel,
        gold,
        playerHealth,
        weaponPower,
        weaponName,
        weaponLevel: weaponLevel || 0,
        heroes,
        levels,
        session: currentSessionId,
        monsterHealth,
        rewardMultiplier,
        rebornCount // Сохранение количества перерождений
    };
    console.log('Saving progress:', progressData);
    try {
        const dbRef = ref(database, `players/${nickname}/progress`);
        const sessionRef = ref(database, `players/${nickname}/session`);
        const sessionSnapshot = await get(sessionRef);
        if (sessionSnapshot.val() !== currentSessionId) {
            console.log(`Session mismatch, progress not saved. Current session: ${currentSessionId}, Server session: ${sessionSnapshot.val()}`);
            alert('Сессия изменилась. Прогресс не сохранен.');
            return;
        }
        await set(dbRef, progressData);
        console.log('Data saved successfully:', progressData);
    } catch (error) {
        console.error('Error saving progress:', error);
    }
}

window.saveProgress = saveProgress;








function savePlayerData() {
    if (nickname && currentSessionId) {
        saveProgress(nickname, currentSessionId, {
            currentLevel,
            gold,
            playerHealth,
            weaponPower,
            weaponName,
            weaponLevel,
            levels,
            heroes // Сохранение данных о героях
        });
    }
}



function validateData(data) {
    if (!data || typeof data !== 'object') return false;
    if (!Array.isArray(data.heroes)) return false;
    return true;
}


async function loadProgress(nickname) {
    if (!nickname) {
        console.error('Cannot load progress: no nickname');
        return;
    }

    try {
        const dbRef = ref(database, `players/${nickname}/progress`);
        const snapshot = await get(dbRef);
        if (snapshot.exists()) {
            const data = snapshot.val();
            console.log('Loaded progress:', data);

            data.heroes = migrateHeroData(data.heroes); // Миграция данных героев

            applyProgress(data);
            saveProgress();

            return data;
        } else {
            console.log('No progress found for', nickname);
            return null;
        }
    } catch (error) {
        console.error('Error loading progress:', error);
        return null;
    }
}


window.loadProgress = loadProgress;



// Функция для применения загруженного прогресса
function applyProgress(data) {
    if (data && validateData(data)) {
        currentLevel = data.currentLevel;
        gold = data.gold;
        playerHealth = data.playerHealth;
        weaponPower = data.weaponPower;
        weaponName = data.weaponName;
        weaponLevel = data.weaponLevel || 0;

        heroes = data.heroes.map(hero => {
            const baseDamage = hero.baseDamage !== undefined ? hero.baseDamage : 0;
            const baseCost = hero.baseCost !== undefined ? hero.baseCost : 0;
            const level = hero.level || 1;

            return {
                ...hero,
                baseDamage: baseDamage,
                baseCost: baseCost,
                cost: isNaN(hero.cost) || hero.cost === undefined ? baseCost : hero.cost,
                damage: isNaN(hero.damage) || hero.damage === undefined ? calculateHeroStats(level, baseDamage, baseCost).newDamage : hero.damage,
                level: level
            };
        });

        levels = data.levels || levels;
        monsterHealth = data.monsterHealth || baseMonsterHealth; 
        rewardMultiplier = data.rewardMultiplier || 1;
        rebornCount = data.rebornCount || 0;
        console.log('Applying progress:', data);
        console.log(`Gold after applying progress: ${gold}`);

        updateCharacterMenu();
        addHeroesToMenu();
        updateTotalDamage();
        updateStatusBar();
    }
}

window.applyProgress = applyProgress;

async function startGame() {
    const input = document.getElementById('nicknameInput').value;
    console.log(`Nickname entered: ${input}`);
    if (input) {
        nickname = input;
        const dbRef = ref(database, `players/${nickname}/session`);

        try {
            const sessionSnapshot = await get(dbRef);
            if (sessionSnapshot.exists()) {
                const existingSessionId = sessionSnapshot.val();
                console.log(`Existing session found for ${nickname}: ${existingSessionId}`);
                await endSession(nickname, existingSessionId);
            } else {
                console.log(`No existing session found for ${nickname}`);
            }

            const newSessionId = generateSessionId();
            await set(dbRef, newSessionId);
            currentSessionId = newSessionId;
            console.log(`New session started for ${nickname}: ${newSessionId}`);
            watchSessionChanges();
            listenForOpponent(); // Call listenForOpponent once here

            // Загружаем прогресс игрока и применяем миграцию данных
            const progressData = await loadProgress(nickname);

            if (!progressData) {
                // Устанавливаем начальное количество золота для нового игрока, если прогресс не найден
                const playerGoldRef = ref(database, `players/${nickname}/gold`);
                await set(playerGoldRef, 100); // Устанавливаем начальное значение золота
                console.log('Initial gold set to 100 for new player');
            }

            continueGameSetup();
        } catch (error) {
            console.error('Error starting new session:', error);
        }
    } else {
        alert('Пожалуйста, введите никнейм.');
    }
}
window.startGame = startGame;

async function continueGameSetup() {
    const data = await loadProgress(nickname);
    console.log(`Data loaded: ${JSON.stringify(data)}`);
    applyProgress(data);
    //document.getElementById('leftCharacterMenu ').style.display = 'none';
    document.getElementById('nicknameMenu').style.display = 'none';
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('bottomMenu').style.display = 'flex';
    document.getElementById('leftCharacterMenu').style.display = 'block'; // Показываем меню персонажа
    currentScreen = 'dungeon';
    console.log(`Screen set to: ${currentScreen}`);

    // Убедитесь, что загружаемый прогресс корректен
    if (data && data.levels) {
        levels = data.levels;
    }

    initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
    drawMenu();
    changeScreen('dungeon'); // Переключение на экран подземелья
    updateStatusBar(); // Отображение status bar
}
window.continueGameSetup = continueGameSetup;









function updateHeroCost(hero, heroDiv) {
    const stats = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost);
    const upgradeCost = stats.newCost;
    heroDiv.querySelector('p:nth-child(5)').textContent = `Стоимость: ${upgradeCost}`;
    hero.cost = upgradeCost; // Обновляем стоимость героя
}
window.updateHeroCost = updateHeroCost;



// Установка начального состояния автобоя
let isAutoHitting = true; // Автобой включен по умолчанию
let autoHitInterval;

function startAutoHit() {
    if (isAutoHitting) {
        autoHitInterval = setInterval(() => {
            if (currentScreen === 'battle') {
                hitMonster({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
            }
        }, 300);
    }
}
window.startAutoHit = startAutoHit;
function stopAutoHit() {
    clearInterval(autoHitInterval);
}
window.stopAutoHit = stopAutoHit;
function toggleAutoboy() {
    if (isAutoHitting) {
        stopAutoHit();
        isAutoHitting = false;
        document.getElementById('toggleAutoboyButton').textContent = 'Включить автобой';
    } else {
        isAutoHitting = true;
        startAutoHit();
        document.getElementById('toggleAutoboyButton').textContent = 'Отключить автобой';
    }
}
window.toggleAutoboy = toggleAutoboy;
// Запуск автобоя при загрузке страницы
window.addEventListener('load', startAutoHit);


function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        window.toggleFullscreen = toggleFullscreen;

        function toggleMailWindow() {
    const mailWindow = document.getElementById('mailWindow');
    if (mailWindow.style.display === 'block') {
        mailWindow.style.display = 'none';
    } else {
        mailWindow.innerHTML = ''; // Очищаем содержимое перед загрузкой новой почты
        loadMail();
        mailWindow.style.display = 'block';
    }
}
window.toggleMailWindow = toggleMailWindow;


const characterImages = [
    'peasant.png',     // 0-9 уровень
    'warrior.png',     // 10-19 уровень
    'knight.png',      // 20-29 уровень
    'mage.png',        // 30-39 уровень
    'archer.png',      // 40-49 уровень
    'paladin.png',     // 50-59 уровень
    'barbarian.png',   // 60-69 уровень
    'assassin.png',    // 70-79 уровень
    'samurai.png',     // 80-89 уровень
    'dragon_knight.png' // 90-99 уровень
];

function updateCharacterImage() {
    const index = Math.floor(currentLevel / 10);
    const imageIndex = index < characterImages.length ? index : characterImages.length - 1;
    document.getElementById('characterImage').src = characterImages[imageIndex];
}
window.updateCharacterImage = updateCharacterImage;



function getMonsterImage(level) {
    if (level >= 90) {
        return monsterImages[monsterImages.length - 1];
    }
    const index = Math.floor(level / 10);
    return monsterImages[index % monsterImages.length];
}

window.getMonsterImage = getMonsterImage;

function updateMonsterImage(level) {
    const imageSrc = getMonsterImage(level);
    monsterImage.src = imageSrc;
    //console.log(`Updated monster image to: ${imageSrc} for level ${level}`);
}
window.updateMonsterImage = updateMonsterImage;


        function updateTopPlayers(nickname, playerData) {
            set(ref(database, 'topPlayers/' + nickname), playerData);
        }

        function displayTopPlayers() {
    const dbRef = ref(database);
    return get(child(dbRef, 'topPlayers')).then((snapshot) => {
        if (snapshot.exists()) {
            const topPlayers = snapshot.val();
            // Преобразование объекта в массив и сортировка по уровню
            const sortedPlayers = Object.values(topPlayers).sort((a, b) => b.level - a.level);
            
            let topListHTML = '<h2>Топ игроки</h2>';
            sortedPlayers.forEach(player => {
                topListHTML += `<p>${player.nickname} - Уровень ${player.level}</p>`;
            });
            document.getElementById('topPlayersMenu').innerHTML = topListHTML;
            return topPlayers;
        } else {
            console.log("No data available");
            return {};
        }
    }).catch((error) => {
        console.error(error);
    });
}

let rebornCount = 0; // Переменная для отслеживания количества перерождений
        let nickname = '';
        let currentSessionId = null;
        
        let currentLevel = 1;
        let gold = 100;
        
        let weaponPower = 10;
        let weaponName = 'Кулаки';
        let weaponLevel = 0;
        //let selectedItem = {};
        const monsterMessages = ["Не бейте меня", "За что мне это все ?? ", "как честный человек, ты должен на мне жениться ", "я не буду больше читерить", "простите я просто сплю с админами :( )"];

        const monsterImages = [
            'monster1.png',
            'monster2.png',
            'monster3.png',
            'monster4.png',
            'monster5.png',
            'monster6.png',
            'monster7.png',
            'monster8.png',
            'monster9.png',
            'monster10.png'
        ];

let worldBossHealth = 1000000;
let playersDamage = {};
let isUpdating = false;



        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let currentScreen = 'menu';
            let hits = 0;
            let baseMonsterHealth = 100; // Установите это значение на начальное здоровье монстра
            let monsterHealth = baseMonsterHealth;
            let levels = new Array(10000).fill().map((_, i) => ({ number: i + 1, stars: 0, completed: false }));


        const backgroundImage = new Image();
        backgroundImage.src = 'background.png';
        const castle = new Image();
        castle.src = 'castle.png';
        const arena2 = new Image();
        arena2.src = 'arena.png';
        const dungeonGateImage = new Image();
        dungeonGateImage.src = 'dung.png';
        const monsterImage = new Image();
        //monsterImage.src = 'mob.png';
        const mapImage = new Image();
        mapImage.src = 'map.png';
        const starImage = new Image();
        starImage.src = 'star.png';
        const peasantImage = 'peasant.png';
        const peasantWithSwordImage = 'peasant_with_sword.png';






        starImage.onload = function() {
            drawLevelMap();
        };
        
        // Crosshair logic
        const crosshair = document.getElementById('crosshair');
        document.addEventListener('mousemove', (event) => {
    if (currentScreen === 'battle') {
        crosshair.style.left = `${event.clientX}px`;
        crosshair.style.top = `${event.clientY}px`;
    } else {
        crosshair.style.display = 'none'; // Скрываем прицел, если не в режиме "battle"
    }
});









        function showHitAnimation() {
            crosshair.style.transition = 'transform 0.1s ease-in-out';
            crosshair.style.transform = 'translate(-50%, -50%) scale(0.8)';
            showMonsterMessage();
            setTimeout(() => {
                crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 100);
        }
        window.showHitAnimation = showHitAnimation;

        function showMonsterMessage() {
            const message = monsterMessages[Math.floor(Math.random() * monsterMessages.length)];
            const monsterMessage = document.getElementById('monsterMessage');
            monsterMessage.textContent = message;
            monsterMessage.style.display = 'block';
            setTimeout(() => {
                monsterMessage.style.display = 'none';
            }, 500);
        }
        window.showMonsterMessage = showMonsterMessage;
      
        function drawStars(x, y, count) {
    //console.log(`Drawing ${count} stars at (${x}, ${y})`);
    for (let i = 0; i < count; i++) {
        ctx.drawImage(starImage, x + i * 30, y, 20, 20);
    }
}
        window.drawStars = drawStars;

        function toggleShop() {
            const shopMenu = document.getElementById('shopMenu');
            shopMenu.style.display = shopMenu.style.display === 'block' ? 'none' : 'block';
            updateShop();
        }
        window.toggleShop = toggleShop; // Добавляем в глобальную область видимости

        function drawShop() {
            document.getElementById('shopGold').textContent = gold;
        }
        window.drawShop = drawShop;



        function updateGold(amount) {
    return new Promise((resolve, reject) => {
        console.log(`Updating gold: current gold = ${gold}, new gold = ${amount}`);
        gold = amount;
        document.getElementById('statusGold').textContent = gold;
        const playerGoldRef = ref(database, `players/${nickname}/gold`);
        set(playerGoldRef, gold).then(() => {
            console.log(`Gold updated in database: ${gold}`);
            resolve();
        }).catch((error) => {
            console.error('Error updating gold:', error);
            reject(error);
        });
    });
}


window.updateGold = updateGold;



async function endSession(nickname, sessionId) {
    const dbRef = ref(database, `players/${nickname}/session`);
    console.log(`В endSession, nickname: ${nickname}, sessionid: ${sessionId}`);
    try {
        const result = await runTransaction(dbRef, (currentSession) => {
            if (currentSession === null) {
                console.log(`No session to end for ${nickname}.`);
                return null; // Ignore if there's no session
            }
            if (currentSession === sessionId) {
                console.log(`Ending session ${sessionId} for ${nickname}`);
                return null;
            } else {
                console.error(`Session mismatch during transaction: currentSession=${currentSession}, sessionId=${sessionId}`);
                throw new Error("Session mismatch");
            }
        });
        if (result.committed) {
            console.log(`Session ${sessionId} for ${nickname} ended successfully`);
            currentSessionId = null;
        } else {
            console.log(`Session ${sessionId} for ${nickname} was not ended`);
        }
    } catch (error) {
        console.error('Error ending session:', error);
    }
}
window.endSession = endSession;

function watchSessionChanges() {
    const dbRef = ref(database, `players/${nickname}/session`);
    onValue(dbRef, (snapshot) => {
        const sessionId = snapshot.val();
        if (sessionId !== currentSessionId && sessionId !== null) {
            console.log(`Session changed from ${currentSessionId} to ${sessionId}`);
            alert('Вы были выброшены из игры, так как сессия была начата с другого устройства или вкладки.');
            endCurrentSession();
            location.reload();  // Перезагрузка страницы для выхода из игры
        }
    });
}
window.watchSessionChanges = watchSessionChanges;

function generateSessionId() {
    return Math.random().toString(36).substr(2, 9);
}

function endCurrentSession() {
    if (nickname && currentSessionId) {
        endSession(nickname, currentSessionId);
    }
}
window.endCurrentSession = endCurrentSession;




function hideRebornPrompt() {
    document.getElementById('rebornPrompt').style.display = 'none';
}






window.showRebornPrompt = showRebornPrompt;
window.hideRebornPrompt = hideRebornPrompt;



function sendRewards() {
    const sortedPlayers = Object.entries(playersDamage).sort(([, damageA], [, damageB]) => damageB - damageA);
    const rewards = {
        top3: 10000,
        top10: 1000
    };

    sortedPlayers.forEach(([player, damage], index) => {
        let reward = 0;
        if (index < 3) {
            reward = rewards.top3;
        } else if (index < 10) {
            reward = rewards.top10;
        }
        if (reward > 0) {
            sendMail(player, reward, index + 1, damage);
            console.log(`Reward sent to player ${player}: ${reward} gold for rank ${index + 1} with damage ${damage}`);
        }
    });

    // Обнуление рейтинга
    playersDamage = {};
    syncPlayersDamage();
}
window.sendRewards = sendRewards;


function sendMail(player, reward, rank, damage) {
    const mailMessage = `Поздравляем! Вы заняли ${rank}-е место в рейтинге с уроном ${damage}. Ваша награда: ${reward} золота.`;
    const playerMailRef = ref(database, `players/${player}/mail`);
    console.log(`Preparing to send mail to ${player}: ${mailMessage}`);
    get(playerMailRef).then((snapshot) => {
        let playerMail = snapshot.val() || {};
        // Проверка на существование аналогичного письма
        const existingMail = Object.values(playerMail).find(mail => mail.message === mailMessage);
        if (existingMail) {
            console.log(`Mail already exists for player ${player}: ${mailMessage}`);
            return;
        }
        const mailId = `mail_${Date.now()}`;
        playerMail[mailId] = {
            reward: reward,
            message: mailMessage,
            timestamp: Date.now()
        };
        set(playerMailRef, playerMail).then(() => {
            console.log(`Mail sent to player ${player}: ${mailMessage}`);
        }).catch((error) => {
            console.error('Error setting mail data:', error);
        });
    }).catch((error) => {
        console.error('Error getting mail data:', error);
    });
}
window.sendMail = sendMail;





function loadMail() {
    const mailWindow = document.getElementById('mailWindow');
    mailWindow.innerHTML = '<h2>Ваша почта</h2><div id="mailContent"></div><button onclick="toggleMailWindow()">Закрыть</button>';
    const mailContent = document.getElementById('mailContent');
    const playerMailRef = ref(database, `players/${nickname}/mail`);
    console.log(`Loading mail for player ${nickname}`);
    get(playerMailRef).then((snapshot) => {
        const mailsObject = snapshot.val() || {};
        console.log('Mails Object:', mailsObject);
        const mails = Object.entries(mailsObject); // Преобразуем объект в массив [ключ, значение]
        mails.forEach(([mailId, mail]) => {
            const mailItem = document.createElement('div');
            console.log('Mail Item:', mail);
            mailItem.innerHTML = `
                <p>${mail.message}</p>
                <p>Награда: ${mail.reward} золота</p>
                <button onclick="claimReward('${mailId}', ${mail.reward})">Получить награду</button>
            `;
            mailContent.appendChild(mailItem);
        });
    }).catch((error) => {
        console.error('Error loading mail:', error);
    });
}
window.loadMail = loadMail;

function claimReward(mailId, reward) {
    const playerMailRef = ref(database, `players/${nickname}/mail/${mailId}`);
    const playerGoldRef = ref(database, `players/${nickname}/gold`);

    // Получаем текущее количество золота
    get(playerGoldRef).then((snapshot) => {
        let currentGold = snapshot.val() || 0;
        let newGold = currentGold + reward;
        updateGold(newGold);  // Используем updateGold

        // Удаляем письмо
        set(playerMailRef, null).then(() => {
            console.log(`Mail ${mailId} deleted`);

            // Перезагружаем почту
            loadMail();
            saveProgress(); // Сохраняем прогресс
            updateStatusBar(); // Обновляем статус бар
        }).catch((error) => {
            console.error('Error deleting mail:', error);
        });
    }).catch((error) => {
        console.error('Error getting current gold:', error);
    });
}

window.claimReward = claimReward;



function spendGold(amount) {
    const playerGoldRef = ref(database, `players/${nickname}/gold`);

    // Получаем текущее количество золота
    get(playerGoldRef).then((snapshot) => {
        let currentGold = snapshot.val() || 0;
        if (currentGold >= amount) {
            updateGold(currentGold - amount);  // Используем updateGold

            // Обновляем количество золота и сохраняем прогресс
            set(playerGoldRef, currentGold).then(() => {
                console.log(`Gold spent: ${amount}, remaining gold: ${currentGold}`);
                gold = currentGold; // Обновляем глобальную переменную золота
                document.getElementById('statusGold').textContent = gold; // Обновляем отображение золота в интерфейсе
                saveProgress(); // Сохраняем прогресс
                updateStatusBar(); // Обновляем статус бар
            }).catch((error) => {
                console.error('Error updating gold:', error);
            });
        } else {
            console.log('Not enough gold to spend.');
        }
    }).catch((error) => {
        console.error('Error getting current gold:', error);
    });
}
window.spendGold = spendGold;










function resetWorldBossHealth() {
    worldBossHealth = 1000000; // Установите максимальное здоровье босса
    syncWorldBossHealth(); // Синхронизируйте новое значение здоровья с базой данных
    console.log("World Boss Health has been reset to 100%");
    updateWorldBossHealthDisplay(); // Обновите отображение здоровья на экране
    drawWorldBossBattle(); // Перерисуйте экран боя с боссом
}
function getTimeUntilNextHour() {
    const now = new Date();
    const nextHour = new Date(now.getTime() + (60 - now.getMinutes()) * 60 * 1000);
    nextHour.setMinutes(0, 0, 0);
    return nextHour - now;
}
function startHourlyReset() {
    const timeUntilNextHour = getTimeUntilNextHour();
    
    // Запускаем таймер, который сбросит здоровье в начале следующего часа
    setTimeout(() => {
        resetWorldBossHealth();
        
        // После сброса здоровья запускаем интервал на каждый час
        setInterval(resetWorldBossHealth, 3600000);
    }, timeUntilNextHour);
}




 

        function buyWeapon(type, power, cost) {
            if (gold >= cost) {
                weaponPower = power;
                updateGold(gold - cost);  // Используем updateGold
                weaponLevel = 1;
                if (type === 'sword') {
                    weaponName = 'Меч';
                    document.getElementById('characterImage').src = peasantWithSwordImage;
                }
                updateCharacterMenu();
                updateShop();
                saveProgress(nickname, {
                    currentLevel,
                    gold,
                    playerHealth,
                    weaponPower,
                    weaponName,
                    weaponLevel
                });
            }
        }

        window.buyWeapon = buyWeapon;

        function upgradeWeapon(type, costPerLevel) {
            if (gold >= costPerLevel && weaponName === 'Меч') {
                weaponPower += 15;
                updateGold(gold - costPerLevel);  // Используем updateGold
                weaponLevel++;
                updateCharacterMenu();
                updateShop();
                saveProgress(nickname, {
                    currentLevel,
                    gold,
                    playerHealth,
                    weaponPower,
                    weaponName,
                    weaponLevel
                });
            }
        }

        window.upgradeWeapon = upgradeWeapon;

        function continueGame() {
    document.getElementById('shopMenu').style.display = 'none';
    if (currentLevel < 10000) {
        currentLevel++;
        initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
        startLevel(currentLevel);
    } else {
        currentScreen = 'victory';
        drawVictoryScreen();
    }
    updateTopPlayers(nickname, { nickname, level: currentLevel });
    drawLevelMap();
}


        window.continueGame = continueGame;

        function getHealthColor(percentage) {
    let color;
    if (percentage > 50) {
        color = 'green';
    } else if (percentage > 20) {
        color = 'yellow';
    } else {
        color = 'red';
    }
   // console.log(`Health percentage: ${percentage}, Color: ${color}`);
    return color;
}

function updateMonsterHealthDisplay() {
    const healthBar = document.getElementById('monsterHealthBar');
    const healthValue = document.getElementById('monsterHealthValue');
    //console.log('Current monsterHealth:', monsterHealth);

    if (healthBar) {
        const maxHealth = 100 * Math.pow(1.1, currentLevel - 1);
        const healthPercentage = (monsterHealth / maxHealth) * 100;
        const color = getHealthColor(healthPercentage);
        healthBar.style.width = `${Math.min(healthPercentage, 100)}%`;
        healthBar.style.backgroundColor = color; // Обновляем цвет фона
        //console.log(`Updated monster health bar: Width: ${healthPercentage}%, Color: ${color}`);
       // console.log(`Health bar style:`, healthBar.style);
    }

    if (healthValue) {
        healthValue.textContent = monsterHealth.toFixed(0); // Обновляем текстовое значение здоровья
        //console.log(`Updated monster health value: ${monsterHealth.toFixed(0)}`);
    }
}

window.updateMonsterHealthDisplay = updateMonsterHealthDisplay;
window.getHealthColor = getHealthColor;


function drawArena() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаем холст
    ctx.drawImage(arena2, 0, 0, canvas.width, canvas.height); // Рисуем арену
    //drawStatusBar(); // Рисуем статусную панель
    // Дополнительный код для рисования элементов арены
}
window.drawArena = drawArena;


let turnTimeout; // Тайм-аут для управления ходами
let opponent; // Объявление глобальной переменной для хранения данных о противнике
let totalDamage = 100; // Урон игрока
let opponentDamage = 50; // Урон противника
let opponentHealth = 300; // Здоровье противника
let playerHealth = 300;
let currentPlayer = null;
let battleInProgress = false; // Отслеживает состояние боя
let playerRef;
let opponentRef;
let onValueListener; // Глобальная переменная для хранения ссылки на обработчик
let turnDuration = 5000; // Продолжительность хода в миллисекундах

//let opponentDamage = 0; // Урон противника (будет обновляться при каждом ударе)


// Открытие окна регистрации на PvP
function openPvpRegistration() {
            document.getElementById('pvpRegistration').style.display = 'block';
        }

// Закрытие окна регистрации на PvP
function closePvpRegistration() {
document.getElementById('pvpRegistration').style.display = 'none';
}

// Регистрация на PvP
function registerForPvp() {
    console.log("Попытка регистрации на PvP. Текущее здоровье: ", playerHealth);

    if (battleInProgress) {
        console.log("Вы уже участвуете в бою!");
        return;
    }
    playerHealth = 300;
    nickname = document.getElementById('nicknameInput').value;
    playerRef = ref(database, 'pvpQueue/' + nickname);
    console.log(`Регистрация игрока ${nickname} с данными: здоровье ${playerHealth}, урон ${totalDamage}`);
    set(playerRef, {
        nickname: nickname,
        health: playerHealth,
        damage: totalDamage,
        inBattle: false,
        timestamp: Date.now()
    })
    .then(() => {
        console.log(`${nickname} зарегистрирован на PvP с данными:`, {
            nickname: nickname,
            health: playerHealth,
            damage: totalDamage,
            timestamp: Date.now()
        });
        closePvpRegistration();
        showWaitingForOpponent();
        listenForOpponent();
    })
    .catch((error) => {
        console.error(`Ошибка при регистрации ${nickname} на PvP:`, error);
    });
}










// Показ надписи "идет поиск соперника"
function showWaitingForOpponent() {
    const waitingMessage = document.createElement('div');
    waitingMessage.id = 'waitingMessage';
    waitingMessage.style.position = 'fixed';
    waitingMessage.style.top = '50%';
    waitingMessage.style.left = '50%';
    waitingMessage.style.transform = 'translate(-50%, -50%)';
    waitingMessage.style.background = 'rgba(0, 0, 0, 0.8)';
    waitingMessage.style.color = 'white';
    waitingMessage.style.padding = '20px';
    waitingMessage.style.borderRadius = '10px';
    waitingMessage.style.textAlign = 'center';
    waitingMessage.innerText = 'Идет поиск соперника...';
    document.body.appendChild(waitingMessage);
}
let isFinalizingBattle = false; // Флаг для предотвращения повторных вызовов 

// Начало PvP боя
// Начало PvP боя
function startPvpBattle(opponentData) {
    console.log("Начало битвы. Данные оппонента:", opponentData);
    if (battleInProgress) {
        console.log("Битва уже идет. Прерывание вызова startPvpBattle.");
        return;
    }
    
    if (!opponentData || !opponentData.nickname || !opponentData.health || !opponentData.damage) {
        console.error("Некорректные данные оппонента. Прерывание вызова startPvpBattle.");
        return;
    }

    battleInProgress = true;
    opponent = opponentData;
    opponentRef = ref(database, 'pvpQueue/' + opponent.nickname);
    opponentHealth = opponent.health;
    opponentDamage = opponent.damage;

    currentPlayer = (Math.random() > 0.5) ? 'player' : 'opponent';
    console.log("Начало битвы. Текущий игрок:", currentPlayer);

    document.getElementById('pvpOpponentInfo').innerText = `Противник: ${opponent.nickname}\nЗдоровье: ${opponent.health}\nУрон: ${opponent.damage}`;
    document.getElementById('pvpFightLog').innerText = '';
    document.getElementById('pvpBattle').style.display = 'block';

    Promise.all([
        set(ref(database, 'pvpQueue/' + nickname + '/inBattle'), true),
        set(ref(database, 'pvpQueue/' + opponent.nickname + '/inBattle'), true)
    ]).then(() => {
        console.log(`Игроки ${nickname} и ${opponent.nickname} отмечены как участвующие в бою.`);

        if (currentPlayer === 'player') {
            playerTurn();
        } else {
            opponentTurn();
        }
    }).catch((error) => {
        console.error('Ошибка при установке статуса боя для игроков:', error);
        battleInProgress = false;
    });
}





    // Завершение PvP боя по кнопке
    function endPvpBattle() {
        if (!battleInProgress) {
            console.log("Битва уже завершена.");
            return;
        }
        
        console.log("Завершение битвы вручную.");
        finalizePvpBattle(currentPlayer);
    }


    function resetBattleState() {
        console.log("Сброс состояния боя. Текущее здоровье: ", playerHealth);
    currentPlayer = null;
    playerRef = null;
    opponentRef = null;
    opponent = null;
    playerHealth = 300; // Сброс здоровья игрока
    opponentHealth = 300; // Сброс здоровья противника
    battleInProgress = false; // Отметка о завершении боя
    console.log("Состояние после сброса. Игрок здоровье: ", playerHealth, " Оппонент здоровье: ", opponentHealth);

    console.log("Данные после сброса состояния боя:", {
        currentPlayer,
        playerRef,
        opponentRef,
        opponent,
        playerHealth,
        opponentHealth,
        battleInProgress
    });
}




function playerTurn() {
    if (!battleInProgress) {
        console.log("Битва не идет. Прерывание хода игрока.");
        return;
    }
    console.log("Ход игрока. Урон:", totalDamage);
    opponentHealth -= totalDamage;
    if (opponentHealth < 0) opponentHealth = 0;
    console.log(`Урон по оппоненту: ${totalDamage}. Здоровье оппонента: ${opponentHealth}`);

    if (opponentHealth <= 0) {
        console.log("Оппонент побежден игроком.");
        finalizePvpBattle('player');
        return;
    }

    document.getElementById('pvpFightLog').innerText += `Вы нанесли ${totalDamage} урона противнику!\n`;
    updateOpponentHealth();
    currentPlayer = 'opponent';
    console.log("Передача хода оппоненту.");
    scheduleNextTurn();
}

function opponentTurn() {
    if (!battleInProgress) {
        console.log("Битва не идет. Прерывание хода оппонента.");
        return;
    }
    console.log("Ход оппонента. Урон:", opponentDamage);
    playerHealth -= opponentDamage;
    if (playerHealth < 0) playerHealth = 0;
    console.log(`Урон по игроку: ${opponentDamage}. Здоровье игрока: ${playerHealth}`);

    if (playerHealth <= 0) {
        console.log("Игрок побежден оппонентом.");
        finalizePvpBattle('opponent');
        return;
    }

    document.getElementById('pvpFightLog').innerText += `Противник нанес вам ${opponentDamage} урона!\n`;
    updatePlayerHealth();
    currentPlayer = 'player';
    scheduleNextTurn();
}

function updateOpponentHealth() {
    if (opponent && opponent.nickname) {
        const opponentHealthRef = ref(database, 'pvpQueue/' + opponent.nickname + '/health');
        set(opponentHealthRef, opponentHealth)
            .then(() => {
                console.log(`Здоровье противника обновлено: ${opponentHealth}`);
            })
            .catch((error) => {
                console.error(`Ошибка при обновлении здоровья противника:`, error);
            });
    } else {
        console.error("Не удалось обновить здоровье противника: некорректные данные оппонента.");
    }
}

function updatePlayerHealth() {
    const playerHealthRef = ref(database, 'pvpQueue/' + nickname + '/health');
    set(playerHealthRef, playerHealth)
        .then(() => {
            console.log(`Здоровье игрока обновлено: ${playerHealth}`);
        })
        .catch((error) => {
            console.error(`Ошибка при обновлении здоровья игрока:`, error);
        });
}

function scheduleNextTurn() {
    if (!battleInProgress) {
        console.log("Битва не идет. Прерывание scheduleNextTurn.");
        return;
    }

    if (currentPlayer === 'player') {
        setTimeout(playerTurn, turnDuration);
    } else {
        setTimeout(opponentTurn, turnDuration);
    }
}





function autoAttack() {
    if (currentPlayer === 'player') {
        handleAttack();
    }
}

function handleAttack() {
    if (!battleInProgress) return;

    console.log(`Состояние боя: ${battleInProgress}`);
    console.log(`Урон игрока: ${totalDamage}, Урон противника: ${opponentDamage}`);

    let damage = totalDamage; // Урон игрока
    opponentHealth -= damage;

    document.getElementById('pvpFightLog').innerText += `Вы нанесли удар! Урон: ${damage}, Здоровье противника: ${opponentHealth}\n`;

    if (opponentHealth <= 0) {
        finalizePvpBattle();
    } else {
        currentPlayer = 'opponent';
        scheduleNextTurn();
    }
}






function opponentAttack() {
    if (!battleInProgress) return;

    console.log(`Состояние боя: ${battleInProgress}`);
    console.log(`Урон игрока: ${totalDamage}, Урон противника: ${opponentDamage}`);

    let damage = opponentDamage; // Урон противника
    playerHealth -= damage;

    // Логирование урона и здоровья
    console.log(`Урон оппонента: ${damage}, Ваше здоровье: ${playerHealth}`);

    document.getElementById('pvpFightLog').innerText += `Противник нанёс удар! Урон: ${damage}, Ваше здоровье: ${playerHealth}\n`;

    if (playerHealth <= 0) {
        finalizePvpBattle();
    } else {
        currentPlayer = 'player';
        scheduleNextTurn();
    }
}




window.handleAttack = function () {
    if (!battleInProgress) return;

    if (currentPlayer === 'player') {
        opponentHealth -= totalDamage;
        document.getElementById('pvpFightLog').innerText += `Вы нанесли урон! Здоровье противника: ${opponentHealth}\n`;
        if (opponentHealth <= 0) {
            finalizePvpBattle('player');
        } else {
            currentPlayer = 'opponent';
            scheduleNextTurn();
        }
    }
}
let opponentListenerRef;
// Синхронизация очереди PvP
function listenForOpponent() {
    const opponentRef = ref(database, 'pvpQueue');
    console.log("Запуск прослушивания очереди PvP");
    opponentListenerRef = onValue(opponentRef, (snapshot) => {
        const queue = snapshot.val();
        console.log("Изменения в очереди PvP:", queue);

        if (queue && !battleInProgress) {
            const players = Object.entries(queue).filter(([key, value]) => key && value && !value.inBattle && key !== 'undefined');
            console.log("Найденные игроки в очереди:", players);

            if (players.length >= 2) {
                const player1 = players.find(([key, value]) => key === nickname);
                const player2 = players.find(([key, value]) => key !== nickname);

                if (player1 && player2) {
                    console.log("Начало PvP боя между игроками:", player1, player2);
                    startPvpBattle(player2[1]);
                    Promise.all([
                        set(ref(database, `pvpQueue/${player1[0]}/inBattle`), true),
                        set(ref(database, `pvpQueue/${player2[0]}/inBattle`), true)
                    ]).then(() => {
                        console.log(`Игроки ${player1[0]} и ${player2[0]} отмечены как участвующие в бою.`);
                    }).catch((error) => {
                        console.error('Ошибка при обновлении статуса боя игроков:', error);
                    });
                } else {
                    console.log("Не найден подходящий оппонент для боя.");
                }
            }
        }
    });
}




// Дополнительная функция для проверки, находится ли игрок в бою
function isPlayerInBattle(playerNickname) {
    const battleRef = ref(database, 'pvpQueue/' + playerNickname);
    return get(battleRef).then((snapshot) => {
        if (snapshot.exists()) {
            const playerData = snapshot.val();
            return playerData.inBattle; // Поле, которое указывает, находится ли игрок в бою
        }
        return false;
    }).catch((error) => {
        console.error(`Ошибка при проверке статуса боя игрока ${playerNickname}:`, error);
        return false;
    });
}





// Завершение PvP боя
function finalizePvpBattle(winner) {
    if (!battleInProgress) {
        console.log("Битва уже завершена.");
        return;
    }
    console.log(`Завершение битвы. Победитель: ${winner}`);

    const opponentNickname = opponent ? opponent.nickname : null;

    // Сбрасываем флаг боя для обоих игроков и удаляем их из очереди
    Promise.all([
        set(ref(database, 'pvpQueue/' + nickname + '/inBattle'), false),
        opponentNickname ? set(ref(database, 'pvpQueue/' + opponentNickname + '/inBattle'), false) : Promise.resolve()
    ]).then(() => {
        console.log(`Флаг боя сброшен для игроков ${nickname} и ${opponentNickname}.`);
        return Promise.all([
            remove(ref(database, 'pvpQueue/' + nickname)),
            opponentNickname ? remove(ref(database, 'pvpQueue/' + opponentNickname)) : Promise.resolve()
        ]);
    }).then(() => {
        console.log(`Игроки ${nickname} и ${opponentNickname} удалены из очереди.`);
        // Сбрасываем состояние боя
        battleInProgress = false;
        currentPlayer = null;
        playerRef = null;
        opponentRef = null;
        opponent = null;
        playerHealth = 300;

        if (winner === 'player') {
            document.getElementById('pvpFightLog').innerText += 'Вы победили!\n';
        } else if (winner === 'opponent') {
            document.getElementById('pvpFightLog').innerText += 'Вы проиграли!\n';
        }

        document.getElementById('pvpBattle').style.display = 'none';
        const waitingMessage = document.getElementById('waitingMessage');
        if (waitingMessage) {
            document.body.removeChild(waitingMessage);
        }

        // Перезапускаем прослушивание очереди
        listenForOpponent();
    }).catch((error) => {
        console.error('Ошибка при сбросе флага боя или удалении игроков из очереди:', error);
    });
}







        function clearQueue() {
    const queueRef = ref(database, 'pvpQueue');
    set(queueRef, null)
    .then(() => {
        console.log('Очередь очищена.');
    })
    .catch((error) => {
        console.error('Ошибка при очистке очереди:', error);
    });
}
window.clearQueue = clearQueue;



function findOpponent() {
    const queueRef = ref(database, 'pvpQueue');
    onValue(queueRef, (snapshot) => {
        const queue = snapshot.val();
        if (!queue) {
            console.log('Очередь пуста');
            return;
        }

        const playerEntries = Object.entries(queue);
        const opponentEntry = playerEntries.find(([key, value]) => key !== nickname);
        if (opponentEntry) {
            const [opponentNickname, opponentData] = opponentEntry;
            startPvpBattle(opponentData);
            remove(ref(database, 'pvpQueue/' + nickname));
            remove(ref(database, 'pvpQueue/' + opponentNickname));
        } else {
            console.log('Соперников не найдено');
        }
    });
}




window.findOpponent = findOpponent;

window.listenForOpponent = listenForOpponent;
        window.openPvpRegistration = openPvpRegistration;
        window.closePvpRegistration = closePvpRegistration;
        window.registerForPvp = registerForPvp;
        window.showWaitingForOpponent = showWaitingForOpponent;
        window.startPvpBattle = startPvpBattle;

        window.scheduleNextTurn = scheduleNextTurn;
        window.autoAttack = autoAttack;
        window.opponentAttack = opponentAttack;
        window.handleAttack = handleAttack;
        window.opponentTurn = opponentTurn;
        window.playerTurn = playerTurn;
        window.updateOpponentHealth = updateOpponentHealth;
        window.updatePlayerHealth = updatePlayerHealth;
        window.finalizePvpBattle = finalizePvpBattle;
        window.endPvpBattle = endPvpBattle;
        window.isPlayerInBattle = isPlayerInBattle;
        







function hitMonster(event) {
    if (currentScreen !== 'battle') return;
    if (monsterHealth <= 0) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    const monsterX = canvas.width / 2 - monsterImage.width / 2;
    const monsterY = canvas.height / 2 - monsterImage.height / 2;

    if (
        mouseX >= monsterX &&
        mouseX <= monsterX + monsterImage.width &&
        mouseY >= monsterY &&
        mouseY <= monsterY + monsterImage.height
    ) {
        showHitAnimation();
        const totalDamage = calculateTotalDamage();
        monsterHealth -= totalDamage;
        if (monsterHealth < 0) {
            monsterHealth = 0;
        }
        hits += 1;
        updateMonsterHealthDisplay();

        if (monsterHealth <= 0) {
            let goldReward = Math.round(10 * currentLevel * rewardMultiplier); // Используем Math.round для округления
            console.log(`Monster defeated. Awarding gold: ${goldReward}`);
            updateGold(gold + goldReward).then(() => {
                console.log(`Gold after defeating monster: ${gold}`);
                document.getElementById('goldAmount').textContent = goldReward;
                return saveProgress();
            }).then(() => {
                showVictoryMessage();
            }).catch(error => {
                console.error('Error updating gold and saving progress:', error);
            });
        }
        updateCharacterImage();
    }
}





window.hitMonster = hitMonster;


// Начальное создание монстра с базовым здоровьем
function initializeMonster(initialHealth) {
    monsterHealth = initialHealth;
    console.log('Initializing monster with health:', initialHealth);
    updateMonsterImage(currentLevel);
    updateMonsterHealthDisplay();
}

window.initializeMonster = initializeMonster;

const level = 5;
const baseHealth = 100; // Предположим, базовое здоровье
const calculatedHealth = baseHealth * Math.pow(1.1, level - 1);
console.log(`Calculated health for level ${level}: ${calculatedHealth}`);




// Функция для продолжения игры после победы над монстром
function showContinuePrompt() {
    currentLevel++; // Переход к следующему уровню
    console.log(`Proceeding to level ${currentLevel}`);

    // Используем фиксированное baseMonsterHealth для расчета нового здоровья монстра
    const newMonsterHealth = baseMonsterHealth * Math.pow(1.1, currentLevel - 1);
    console.log(`New monster health for level ${currentLevel}: ${newMonsterHealth}`);
    console.log(`Base monster health: ${baseMonsterHealth}`); // Логирование начального значения здоровья
    monsterHealth = newMonsterHealth;

    // Логирование прогресса перед сохранением на новом уровне
    console.log('Saving progress after proceeding to next level:', {
        currentLevel,
        gold,
        playerHealth,
        weaponPower,
        weaponName,
        weaponLevel,
        heroes,
        levels,
        monsterHealth // Добавляем здоровье монстра для сохранения
    });

    // Сохранение прогресса на новом уровне
    saveProgress();

    initializeMonster(newMonsterHealth);
    drawMenu();
}




window.showContinuePrompt = showContinuePrompt;

function resetMonsterState() {
    initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
    console.log(`Monster health reset to: ${monsterHealth}`);
}





function hideContinuePrompt() {
    document.getElementById('continuePrompt').style.display = 'none';
    document.getElementById('victoryImage').style.display = 'none';
    document.getElementById('goldEarned').style.display = 'none'; // Скрыть текст с количеством золота
}



function continueToNextLevel() {
    hideContinuePrompt();
    if (currentLevel < 10000) {
        currentLevel++;
        startLevel(currentLevel);
        updateCharacterImage(); // вызов функции для смены изображения
    } else {
        currentScreen = 'victory';
        drawVictoryScreen();
    }
    updateTopPlayers(nickname, { nickname, level: currentLevel });
    drawLevelMap();
}



window.continueToNextLevel = continueToNextLevel;




        function drawMenu() {
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        }
        function drawCastle() {
            ctx.drawImage(castle, 0, 0, canvas.width, canvas.height);
            document.getElementById('mailButton').style.display = 'block'; // Отображаем кнопку почты

            // Логирование координат и размеров кнопки почты
            const mailButton = document.getElementById('mailButton');
            const rect = mailButton.getBoundingClientRect();
            console.log(`Mail button coordinates: (${rect.left}, ${rect.top})`);
            console.log(`Mail button size: ${rect.width}x${rect.height}`);
        }
        window.drawCastle = drawCastle;
        function arena() {
            ctx.drawImage(arena2, 0, 0, canvas.width, canvas.height);
        }

        function drawDungeonEntrance() {
           // ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            ctx.drawImage(dungeonGateImage,0, 0, canvas.width, canvas.height);
        }

        function drawVictoryScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Вы победили!', canvas.width / 2, canvas.height / 2);
        }
        
        function showVictoryMessage() {
    console.log("Victory message displayed");

    // Создаем контейнер для сообщения о победе
    const victoryMessage = document.createElement('div');
    victoryMessage.id = 'victoryMessage';
    victoryMessage.style.position = 'absolute';
    victoryMessage.style.top = '50%';
    victoryMessage.style.left = '50%';
    victoryMessage.style.transform = 'translate(-50%, -50%)';
    victoryMessage.style.padding = '20px';
    victoryMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    victoryMessage.style.color = 'white';
    victoryMessage.style.fontSize = '24px';
    victoryMessage.style.textAlign = 'center';
    document.body.appendChild(victoryMessage);

    // Добавляем картинку победы
    const victoryImage = document.createElement('img');
    victoryImage.id = 'victoryImage';
    victoryImage.src = 'win2.png';
    victoryImage.alt = 'Вы победили';
    victoryImage.style.width = '700px';
    victoryImage.style.height = 'auto';
    victoryImage.onclick = () => {
        document.body.removeChild(victoryMessage);
        showContinuePrompt();
    };
    victoryMessage.appendChild(victoryImage);

    // Добавляем отображение заработанного золота
    const goldEarnedDiv = document.createElement('div');
    goldEarnedDiv.id = 'goldEarned';
    goldEarnedDiv.style.fontSize = '24px';
    goldEarnedDiv.style.color = 'gold';
    goldEarnedDiv.style.fontFamily = "'Comic Sans MS', cursive, sans-serif";
    goldEarnedDiv.textContent = `Золото: ${document.getElementById('goldAmount').textContent}`;
    victoryMessage.appendChild(goldEarnedDiv);

    // Добавляем текст сообщения о победе
    const victoryText = document.createElement('p');
    victoryText.textContent = 'Победа! Вы хотите продолжить унижать Shap и убить следующего монстра?';
    victoryMessage.appendChild(victoryText);

    // Убираем сообщение через 3 секунды
    setTimeout(() => {
        if (document.body.contains(victoryMessage)) {
            document.body.removeChild(victoryMessage);
            showContinuePrompt();
        }
    }, 3000); // Время отображения сообщения о победе
}

window.showVictoryMessage = showVictoryMessage;


function calculateStars() {
    // Логика расчета количества звезд, например, на основе оставшегося здоровья игрока или времени
    if (playerHealth > 80) {
        return 3;
    } else if (playerHealth > 50) {
        return 2;
    } else {
        return 1;
    }
}

function startLevel(levelNumber) {
    currentLevel = levelNumber;
    monsterHealth = 100 * Math.pow(1.1, levelNumber - 1); // Устанавливаем здоровье монстра на основе уровня
    console.log(`Starting level ${levelNumber}`);
    console.log(`Monster health set to: ${monsterHealth}`);
    document.getElementById('monsterHealthContainer').style.display = 'block'; // Отображение контейнера здоровья монстра
    document.getElementById('monsterHealthBar').style.width = '100%'; // Полная ширина при начале уровня
    updateMonsterImage(levelNumber); // Устанавливаем изображение монстра
    
    currentScreen = 'battle';
    drawBattle();
    updateMonsterHealthDisplay(); // Обновление отображения здоровья при начале уровня
    updateCharacterImage(); // вызов функции для смены изображения
}

window.startLevel = startLevel;

function showHealthBar() {
    const healthContainer = document.getElementById('monsterHealthContainer');
    healthContainer.style.display = 'block';
}

window.showHealthBar = showHealthBar;





function completeLevel(levelNumber, stars) {
    if (levels[levelNumber - 1]) {
        levels[levelNumber - 1].completed = true;
        levels[levelNumber - 1].stars = stars;
        saveProgress(nickname, {
            currentLevel,
            gold,
            playerHealth,
            weaponPower,
            weaponName,
            weaponLevel,
            levels
        });
        drawLevelMap();
    }
    updateCharacterImage(); // вызов функции для смены изображения
}
window.completeLevel = completeLevel;


function drawLevelsScreen() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'white';
    ctx.font = '30px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Уровни и Звезды', canvas.width / 2, 50);

    levels.forEach((level, index) => {
        const { x, y } = getLevelPosition(index);

        ctx.fillStyle = level.completed ? 'gold' : 'silver';
        ctx.beginPath();
        ctx.arc(x, y, 25, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.fillText(level.number, x, y + 8);

        drawStars(x - 30, y + 35, level.stars);
    });
}





        function drawLevelMap() {
            //console.log(levels);  // Вывод данных уровней в консоль
           // console.log('Drawing level map');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);

            levels.forEach((level, index) => {
                const { x, y } = getLevelPosition(index);

                ctx.fillStyle = level.completed ? 'gold' : 'silver';
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(level.number, x, y + 8);

                drawStars(x - 30, y + 35, level.stars);
            });
        }

        function getLevelPosition(index) {
            const perRow = 5;
            const spacing = 80;
            const offsetX = (canvas.width - perRow * spacing) / 2;
            const offsetY = 100;

            const x = offsetX + (index % perRow) * spacing;
            const y = offsetY + Math.floor(index / perRow) * spacing;
            return { x, y };
        }
        




        const updateInterval = 1000; // Интервал обновления в миллисекундах (1 секунда)

// Функция для регулярного обновления данных
function startUpdating() {
    if (!isUpdating) {
        isUpdating = true;
        setInterval(() => {
            // Получаем последние данные с сервера
            updateWorldBossData();
        }, updateInterval);
    }
}


// Функция для обновления данных босса и игроков
function updateWorldBossData() {
    const dbRef = ref(database);
    get(child(dbRef, 'worldBoss')).then((snapshot) => {
        if (snapshot.exists()) {
            const data = snapshot.val();
            worldBossHealth = data.health;
            playersDamage = data.playersDamage || {};
            if (currentScreen === 'worldBoss') {
                drawWorldBossBattle();
            }
        } else {
            console.log("No data available for world boss");
        }
    }).catch((error) => {
        console.error(error);
    });
}













        
        function drawWorldBossBattle() {
    //console.log('Drawing World Boss Battle');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const worldBossImage = document.getElementById('worldBossImage');
    const bossX = canvas.width / 2 - worldBossImage.width / 2;
    const bossY = canvas.height / 2 - worldBossImage.height / 2;

    ctx.drawImage(worldBossImage, bossX, bossY);

    // Устанавливаем координаты текста выше босса и проверяем, что они в пределах экрана
    const healthTextY = bossY - 40 > 0 ? bossY - 40 : 40;

    // Добавляем лог для проверки координат
    //console.log(`Drawing health text at: ${canvas.width / 2}, ${healthTextY}`);

    // Добавляем отображение здоровья босса над его изображением с жирным шрифтом и обводкой
    ctx.fillStyle = 'white';
    ctx.font = 'bold 32px Comic Sans MS';
    ctx.textAlign = 'center';
    
    // Обводка текста
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.strokeText(`Здоровье: ${worldBossHealth}`, canvas.width / 2, healthTextY);
    
    // Основной текст
    ctx.fillText(`Здоровье: ${worldBossHealth}`, canvas.width / 2, healthTextY);

    // Рисуем полоску здоровья
    drawHealthBar(worldBossHealth, canvas.width - 210, 10, 200, 20, 'red');
    

    // Добавляем отображение рейтинга игроков
    const playersListX = canvas.width - 350; // смещение на 200 пикселей от правого края
const playersListStartY = canvas.height - 700; // смещение на 100 пикселей от низа экрана
    //const playersListStartY = canvas.height / 2 - (Object.keys(playersDamage).length * 15); // вертикальная координата для списка игроков, чтобы он был по центру
    let playersListY = playersListStartY - (Object.keys(playersDamage).length * 15); // вертикальная координата для списка игроков, чтобы он был по центру

    const lineHeight = 30; // задаем отступ между строками

    ctx.textAlign = 'right';
    ctx.font = '26px Roboto';
    ctx.strokeStyle = 'black'; // цвет обводки
    ctx.lineWidth = 4; // ширина обводки
    ctx.fillStyle = 'white'; // цвет текста
    // Отрисовка заголовка
    ctx.strokeText('Рейтинг игроков:', playersListX, playersListY);
    ctx.fillText('Рейтинг игроков:', playersListX, playersListY);
    playersListY += lineHeight; // увеличение отступа после заголовка
 

    Object.entries(playersDamage).sort(([, damageA], [, damageB]) => damageB - damageA).forEach(([player, damage], index) => {
        playersListY += lineHeight; // вертикальное смещение для каждой строки
        ctx.strokeText(`${index + 1}. ${player}: ${damage}`, playersListX, playersListY);
        ctx.fillText(`${index + 1}. ${player}: ${damage}`, playersListX, playersListY);
    });

    updateStatusBar();
}












function drawBattle() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (currentScreen === 'worldBoss') {
        ctx.drawImage(document.getElementById('worldBossImage'), canvas.width / 2 - document.getElementById('worldBossImage').width / 2, canvas.height / 2 - document.getElementById('worldBossImage').height / 2);
        drawHealthBar(worldBossHealth, canvas.width - 210, 10, 200, 20, 'red');
    } else {
        const mobWidth = 600;
        const mobHeight = 580;
        const x = (canvas.width / 2) - (mobWidth / 2);
        const y = (canvas.height / 2) - (mobHeight / 2);
        ctx.drawImage(monsterImage, x, y, mobWidth, mobHeight); // Рисуем текущее изображение монстра

        drawHealthBar(monsterHealth, canvas.width - 210, 10, 200, 20, 'red');
    }

    
    updateStatusBar();
}




function drawHealthBar(health, x, y, width, height, color) {
    ctx.fillStyle = 'grey';
    ctx.fillRect(x, y, width, height);
    ctx.fillStyle = color;
    ctx.fillRect(x, y, width * (health / 1000000), height);  // Учитывая максимальное здоровье босса 1000000
}


        function updateShop() {
            document.getElementById('shopGold').textContent = gold;
        }



// Вызов функции загрузки данных при старте игры





function updateDamageList() {
    const damageList = document.getElementById('damageList');
    damageList.innerHTML = '';

    const sortedPlayers = Object.entries(playersDamage).sort(([, a], [, b]) => b - a);
    sortedPlayers.forEach(([player, damage]) => {
        const listItem = document.createElement('li');
        listItem.textContent = `${player}: ${damage} урона`;
        damageList.appendChild(listItem);
    });
}

function hitWorldBoss(playerName, damage) {
    if (worldBossHealth <= 0) return; // Проверка, чтобы не засчитывать урон после смерти босса

    if (!playersDamage[playerName]) {
        playersDamage[playerName] = 0;
    }
    playersDamage[playerName] += damage;
    worldBossHealth -= damage;
    if (worldBossHealth < 0) worldBossHealth = 0;
    updateWorldBossHealthDisplay();
    updateDamageList();
    syncWorldBossHealth();
    syncPlayersDamage();

    if (worldBossHealth <= 0) {
        // Вызов функции отправки наград при смерти босса
        sendRewards();
    }
}



function updateWorldBossHealthDisplay() {
    //console.log(`Updating World Boss Health Display: ${worldBossHealth}`);
    document.getElementById('worldBossHealthValue').textContent = worldBossHealth;
}

function startBossBattle() {
    changeScreen('worldBoss');
    startUpdating(); // Убедитесь, что обновление запущено
}

function changeScreen(screen) {
    console.log(`Changing screen to: ${screen}`);
    currentScreen = screen;
    document.getElementById('shopMenu').style.display = 'none';
    document.getElementById('statusBar').style.display = 'none';
    document.getElementById('monsterHealthDisplay').style.display = (screen === 'dungeon') ? 'block' : 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mailButton').style.display = (screen === 'castle') ? 'block' : 'none';
    crosshair.style.display = (screen === 'battle' || screen === 'worldBoss') ? 'block' : 'none';
    document.getElementById('rebornButton').style.display = (screen === 'dungeon') ? 'block' : 'none'; // Отображаем кнопку только на экране "battle"
    document.getElementById('pvpButton').style.display = 'none'; // Скрываем кнопку по умолчанию
    // Hide the monster health bar when changing screens
    if (screen !== 'dungeon' && screen !== 'battle') {
        document.getElementById('monsterHealthContainer').style.display = 'none';
        updateStatusBar();
    }
    if (screen === 'worldBoss') {
        document.getElementById('worldBossScreen').style.display = 'block';
        document.getElementById('statusBar').style.display = 'block';
        updateStatusBar();
        drawWorldBossBattle();
    } else {
        document.getElementById('worldBossScreen').style.display = 'none';
    }

    if (screen === 'raid') {
        drawMenu();
    } else if (screen === 'dungeon') {
        showHealthBar(); // Показать полоску здоровья на экране dungeon
        drawDungeonEntrance();
        document.getElementById('statusBar').style.display = 'block';
        //updateStatusBar();
    } else if (screen === 'arena') {
        drawArena();
        document.getElementById('pvpButton').style.display = 'block'; // Показываем кнопку на экране арены
        arena();
        
    } else if (screen === 'castle') {
        drawCastle();
    } else if (screen === 'shop') {
        drawShop();
    } else if (screen === 'battle') {
        loadProgress(nickname).then(data => {
            console.log('Data after loading progress:', data);
            if (data) {
                currentLevel = data.currentLevel;
                gold = data.gold;
                playerHealth = data.playerHealth;
                weaponPower = data.weaponPower;
                weaponName = data.weaponName;
                weaponLevel = data.weaponLevel;
                levels = data.levels || levels;
                updateCharacterMenu();
            }
            document.getElementById('statusBar').style.display = 'block';
            updateStatusBar();
            startLevel(currentLevel); // Инициализация уровня перед отрисовкой боя
        });
    } else if (screen === 'levels') {
        drawLevelsScreen();
    }
}

window.changeScreen = changeScreen;

// Пример использования
document.getElementById('bottomMenu').querySelector('div').addEventListener('click', function() {
    changeScreen('arena');
});


function syncWorldBossHealth() {
    set(ref(database, 'worldBoss/health'), worldBossHealth);
}

function syncPlayersDamage() {
    set(ref(database, 'worldBoss/playersDamage'), playersDamage);
}

function loadWorldBossData() {
    const dbRef = ref(database);
    return get(child(dbRef, 'worldBoss')).then((snapshot) => {
        if (snapshot.exists()) {
            const data = snapshot.val();
            worldBossHealth = data.health;
            playersDamage = data.playersDamage || {};
            //console.log(`Loaded World Boss Health: ${worldBossHealth}`);
            updateWorldBossHealthDisplay();
            updateDamageList();
        } else {
            console.log("No data available for world boss");
        }
    }).catch((error) => {
        console.error(error);
    });
}
       


function updateCharacterMenu() {
    playerHealth = calculateTotalHealth(); // Обновление текущего здоровья игрока
    document.getElementById('weapon').textContent = weaponName;
    document.getElementById('health').textContent = playerHealth;
    document.getElementById('damage').textContent = calculateTotalDamage();
    document.getElementById('gold').textContent = gold;
    document.getElementById('level').textContent = currentLevel;

    // Смена изображения персонажа при достижении уровня выше 10
    updateCharacterImage(); // Вызов функции для смены изображения

    updateStatusBar(); // Обновление статус бара
}
window.updateCharacterMenu = updateCharacterMenu;


function calculateTotalDamage() {
    let totalDamage = 0;
    heroes.forEach(hero => {
        if (hero.hired) {
            totalDamage += hero.damage;
        }
    });
    return totalDamage;
}


window.calculateTotalDamage = calculateTotalDamage;

function calculateTotalHealth() {
    let totalHealth = 100; // базовое здоровье

    return totalHealth;
}
window.calculateTotalHealth = calculateTotalHealth;

let localGoldUpdated = false;

function updateStatusBar() {
    //console.log('updateStatusBar called'); // Логирование вызова функции

    if (!localGoldUpdated) {
        const playerGoldRef = ref(database, `players/${nickname}/gold`);
        get(playerGoldRef).then((snapshot) => {
            const goldAmount = snapshot.val() || 0;
           // console.log(`Gold amount retrieved from database: ${goldAmount}`); // Логирование полученного значения из базы данных

            document.getElementById('statusGold').textContent = goldAmount;
            gold = goldAmount; // Обновляем глобальную переменную золота
          //  console.log(`Global gold variable updated: ${gold}`); // Логирование обновленного значения глобальной переменной

        }).catch((error) => {
            console.error('Error getting gold:', error);
        });
    } else {
        localGoldUpdated = false; // Сбрасываем флаг после использования
    }

    document.getElementById('statusLevel').textContent = currentLevel;
    document.getElementById('playerHealthBar').style.width = playerHealth + '%'; // Обновление ширины полосы здоровья
    document.getElementById('statusDamage').textContent = calculateTotalDamage(); // Обновление значения урона
    document.getElementById('statusRewardMultiplier').textContent = rewardMultiplier.toFixed(1); // Обновление множителя награды

    //console.log('Status bar updated'); // Логирование обновления статус бара
}
window.updateStatusBar = updateStatusBar;







        function toggleTopPlayers() {
    const menu = document.getElementById('topPlayersMenu');
    if (menu.style.display === 'block') {
        menu.style.display = 'none';
    } else {
        displayTopPlayers().then(topPlayers => {
            let topListHTML = '<h2>Топ игроки</h2>';
            // Преобразование объекта в массив и сортировка по уровню
            const sortedPlayers = Object.values(topPlayers).sort((a, b) => b.level - a.level);
            sortedPlayers.forEach(player => {
                topListHTML += `<p>${player.nickname} - Уровень ${player.level}</p>`;
            });
            document.getElementById('topPlayersMenu').innerHTML = topListHTML;
            menu.style.display = 'block';
        });
    }
}


        window.toggleTopPlayers = toggleTopPlayers;



        canvas.addEventListener('click', function(event) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    if (currentScreen === 'menu') {
        currentScreen = 'dungeon';
        drawDungeonEntrance();
    } else if (currentScreen === 'dungeon') {
        const gateCenterX = canvas.width / 2;
        const gateCenterY = canvas.height / 2;
        if (mouseX > gateCenterX - dungeonGateImage.width / 2 &&
            mouseX < gateCenterX + dungeonGateImage.width / 2 &&
            mouseY > gateCenterY - dungeonGateImage.height / 2) {
            currentScreen = 'battle';
            drawBattle();
            crosshair.style.display = 'block';
        } else {
            levels.forEach((level, index) => {
                const { x, y } = getLevelPosition(index);
                const radius = 25;

                if (Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2) < radius) {
                    if (levels[index].completed || index === currentLevel - 1) {
                        startLevel(level.number);
                    }
                }
            });
        }
    } else if (currentScreen === 'battle') {
        hitMonster(event);
    } else if (currentScreen === 'worldBoss') {
        console.log('Click detected on World Boss screen.');
        hitWorldBoss(nickname, calculateTotalDamage());
        syncWorldBossHealth();
        syncPlayersDamage();
    }
});


       
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            if (currentScreen === 'menu') {
                drawMenu();
            } else if (currentScreen === 'dungeon') {
                drawDungeonEntrance();
            } else if (currentScreen === 'battle') {
                drawBattle();
            } else if (currentScreen === 'levelMap') {
                drawLevelMap();
            } else if (currentScreen === 'victory') {
                drawVictoryScreen();
            } else if (currentScreen === 'shop') {
                drawShop();
            }
        }

        window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (currentScreen === 'battle') {
        drawBattle(); // Перерисовка экрана боя
    } else if (currentScreen === 'arena') {
        drawArena(); // Перерисовка арены
    } else if (currentScreen === 'menu') {
        drawMenu(); // Перерисовка меню
    } else if (currentScreen === 'dungeon') {
        drawDungeonEntrance(); // Перерисовка подземелья
    } else if (currentScreen === 'worldBoss') {
        drawWorldBossBattle(); // Перерисовка боя с мировым боссом
    }
});



        gameLoop();


        window.onload = function() {
            console.log("Page loaded, initializing game.");
            addHeroesToMenu();
    loadWorldBossData();
    gameLoop();
    changeScreen('menu'); // Начальный экран
    startUpdating(); // Запуск обновления при старте игры
    startHourlyReset(); // Запуск таймера для сброса здоровья босса
    updateMonsterHealthDisplay();
    clearQueue(); // Очистка очереди перед регистрацией
    
}

// function clearQueue() {
//     const queueRef = ref(database, 'pvpQueue');
//     set(queueRef, null)
//     .then(() => {
//         console.log('Очередь очищена.');
//     })
//     .catch((error) => {
//         console.error('Ошибка при очистке очереди:', error);
//     });
// }
// window.clearQueue = clearQueue;




// Функция для отправки сообщений
function sendMessage() {
    const chatMessageInput = document.getElementById('chatMessageInput');
    const message = chatMessageInput.value.trim();
    if (message && nickname) {
        const messageData = {
            text: message,
            timestamp: new Date().toISOString(),
            nickname: nickname
        };
        const newMessageRef = push(ref(database, 'chat/messages'));
        set(newMessageRef, messageData);
        chatMessageInput.value = '';
    } else if (!nickname) {
        alert('Пожалуйста, введите никнейм, прежде чем отправлять сообщение.');
    }
}

// Слушатель для отправки сообщений при нажатии на Enter
document.getElementById('chatMessageInput').addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
        sendMessage();
    }
});
window.sendMessage = sendMessage;
// Слушатель для новых сообщений
const chatMessages = document.getElementById('chatMessages');
onValue(ref(database, 'chat/messages'), function(snapshot) {
    chatMessages.innerHTML = '';
    snapshot.forEach(function(childSnapshot) {
        const message = childSnapshot.val();
        const messageElement = document.createElement('div');
        messageElement.innerHTML = `<strong>${message.nickname}:</strong> ${message.text}`;
        chatMessages.appendChild(messageElement);
    });
    chatMessages.scrollTop = chatMessages.scrollHeight; // Прокрутка вниз для новых сообщений
});




    </script>
</body>
</html>