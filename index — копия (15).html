<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Средневековое Подземелье</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            background: #000;
        }
        .crosshair {
            position: absolute;
            width: 60px;
            height: 60px;
            background: url('crosshair.png') no-repeat center;
            background-size: contain;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-in-out;
            display: none;
        }
        #bottomMenu {
            position: fixed;
            bottom: 0;
            width: 100%;
            height: 60px;
            background: #333;
            color: white;
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 18px;
        }
        #characterMenu {
    position: fixed;
    top: 0px;
    right: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    display: block; 
    font-size: 16px;
    text-align: center;
    max-width: calc(100vw - 20px); 
    max-height: calc(100vh - 120px); 
    overflow: auto; 
}

#leftCharacterMenu {
        position: fixed;
        top: 0px;
        left: 0px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        display: block;
        font-size: 16px;
        text-align: center;
        max-width: calc(100vw - 20px);
        max-height: calc(100vh - 20px);
        overflow: auto;
    }
        /* Добавляем стили для новой кнопки */
        #fullscreenButton {
            position: fixed;
            bottom: 60px;
            right: 0px;
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }



        #shopMenu {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        #shopItems {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .shop-item {
            margin: 10px;
            text-align: center;
            cursor: pointer;
        }
        .shop-item img {
            width: 100px;
            height: 100px;
            border-radius: 10px;
            transition: transform 0.3s;
        }
        .shop-item img:hover {
            transform: scale(1.1);
        }
        #itemDetail {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #itemDetail img {
            max-width: 100%;
            max-height: 80vh;
        }
        #itemDetail button {
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }
        .status-bar {
            position: fixed;
            top: 10px;
            left: 300px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
        .status-bar p {
            margin: 5px 0;
        }
        .health-bar {
            background: #555;
            border-radius: 5px;
            overflow: hidden;
            width: 200px;
            height: 20px;
            margin-bottom: 10px;
        }
        .health-bar-inner {
            height: 100%;
            background: #0f0;
        }
        .monster-health-bar-inner {
            height: 100%;
            background: #f00; /* Red for monster health */
        }
        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        .hero img {
        width: 175px;
        height: 242px;
        border-radius: 10px;
        transition: filter 0.3s;
    }

    .hero.not-hired img {
        filter: brightness(20%);
    }

    .hero.hired img {
        filter: brightness(100%);
    }
        #characterImage {
            width: 297px;
            height: 500px;
        }
        #nicknameMenu {
            display: block;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #topPlayersMenu {
            display: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #gameVersion {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
        }
        #continuePrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        #continuePrompt button {
            margin: 5px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #fff;
            border: none;
            padding: 5px;
            cursor: pointer;
        }
        .monster-message {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
            display: none;
        }
        #weaponInfo, #healthInfo {
            display: none; /* Скрываем элементы оружия и здоровья */
        }

        #mailButton {
            position: fixed;
            top: 100px;
            left: 300px;
            width: 150px;
            height: 150px;
            background: url('mail.png') no-repeat center;
            background-size: cover;
            cursor: pointer;
            transition: transform 0.3s;
            display: none; /* Скрыта по умолчанию */
        }
        #mailButton:hover {
            transform: scale(1.1);
        }
        #mailWindow {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 400px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
        }
        #rebornButton {
    position: fixed;
    top: 5px;
    right: 325px;
    width: 200px;
    height: 200px;
    background: url('reborn.png') no-repeat center;
    background-size: contain;
    cursor: pointer;
    z-index: 1000;
    transition: transform 0.3s, box-shadow 0.3s;
}
#rebornButton:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 255, 0, 0.8); /* Добавьте красивую тень */
}
#rebornPrompt {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    z-index: 2000;
}

#rebornPrompt button {
    margin: 10px;
    padding: 10px;
    background: #fff;
    border: none;
    cursor: pointer;
}
#monsterHealthContainer {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 30%; /* Ширина контейнера */
    height: 50px; /* Высота контейнера */
    background-color: rgba(255, 0, 0, 0.2); /* Полупрозрачный фон для контейнера */
    border-radius: 15px;
    overflow: hidden; /* Обрезка содержимого */
    display: none; /* Скрыть по умолчанию */
}

#monsterHealthBar {
    height: 100%; /* Высота полоски равна высоте контейнера */
    background-color: green; /* Цвет полоски */
    border-radius: 15px; /* Округленные углы */
    transition: width 0.5s; /* Плавный переход ширины */
}

#monsterHealthValue {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 32px;
    line-height: 50px; /* Высота строки совпадает с высотой контейнера */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Тень для текста */
    font-weight: bold; /* Жирный текст */
    padding: 0 10px; /* Отступы по бокам */
    border: 2px solid rgba(0, 0, 0, 0.5); /* Обводка вокруг текста */
    border-radius: 5px; /* Скругленные углы */
    background-color: rgba(0, 0, 0, 0.3); /* Полупрозрачный фон */
}





    </style>
</head>
<body>
    <button id="fullscreenButton" onclick="toggleFullscreen()">Полноэкранный режим</button>
    <div id="nicknameMenu">
        <h2>Введите свой никнейм</h2>
        <input type="text" id="nicknameInput" placeholder="Ваш никнейм">
        <button onclick="startGame()">Начать игру</button>
        <div id="gameVersion">Версия игры: 1.15</div>
    </div>
    <canvas id="gameCanvas" style="display:none;"></canvas>
    <div id="bottomMenu" style="display:none;">
        <div onclick="changeScreen('arena')">Арена</div>
        <div onclick="changeScreen('dungeon')">Подземелье</div>
        <div onclick="changeScreen('raid')">Рейд</div>
        <div onclick="changeScreen('castle')">Замок</div>
        <div onclick="changeScreen('levels')">Уровни</div>
        <div onclick="changeScreen('worldBoss')">Мировой Босс</div>
        <div onclick="toggleShop()">Магазин</div>
        <div onclick="toggleTopPlayers()">Топ игроки</div>
        <button id="autoboyButton" onclick="toggleAutoHit()">Автобой</button> 
    </div>

    <div id="monsterHealthContainer">
        <div id="monsterHealthBar"></div>
        <div id="monsterHealthValue"></div>
    </div>
    <div id="monsterHealthDisplay">
        <span style="font-size: 30px; margin-right: 10px;">❤️</span>
        Здоровье монстра <span id="monsterHealthValue"></span>
    </div>
    
    
    


    <!-- Добавляем кнопку с изображением письма -->
    <div id="mailButton" onclick="toggleMailWindow()"></div>

    <!-- Окно почты -->
    <div id="mailWindow">
        <h2>Ваша почта</h2>
        <p>Здесь будут отображаться ваши награды.</p>
        <button onclick="toggleMailWindow()">Закрыть</button>
    </div>

    <div id="rebornButton" onclick="showRebornPrompt()"></div>
    <div id="rebornPrompt">
        <h2>Вы хотите переродиться?</h2>
        <p>Прогресс уровней, нанятые герои и накопленное золото будут сброшены. Но вы будете получать награды за убийство монстров в два раза выше.</p>
        <button onclick="confirmReborn()">Да</button>
        <button onclick="hideRebornPrompt()">Нет</button>
    </div>
    
    
    
    
    

    <div id="worldBossScreen" style="display:none;">
        <h2>Мировой Босс</h2>
        <img id="worldBossImage" src="world_boss.png" alt="Мировой Босс">
        <div id="worldBossHealth">Здоровье Босса: <span id="worldBossHealthValue">1000000</span></div>
        <div id="playersDamageList">
            <h3>Список игроков</h3>
            <ul id="damageList"></ul>
        </div>
    </div>
   
    <div id="leftCharacterMenu">
        <!-- Контент меню для найма героев слева будет динамически добавлен через JavaScript -->
    </div>
    
    </div>
    <div id="characterMenu">
        <img id="characterImage" src="peasant.png" alt="Character">
        <p style="display:none;">Оружие: <span id="weapon"></span></p> <!-- Скрытый элемент для отображения оружия -->
        <p style="display:none;">Здоровье: <span id="health"></span></p> <!-- Скрытый элемент для отображения здоровья -->
        <p style="display:none;">Уровень: <span id="level"></span></p>
        <p style="display:none;">Золото: <span id="gold"></span></p>
        <p style="display:none;"><span id="totalDamage">Суммарный урон: 0</p>

        <p style="display:none;">Урон: <span id="damage"></span></p>
        
        
        
    </div>
    <div id="shopMenu">
        <button class="close-btn" onclick="toggleShop()">X</button>
        <h2>Магазин</h2>
        <p>Золото: <span id="shopGold"></span></p>
        <div id="shopItems">
            <div class="shop-item" onclick="showItemDetail('sword.png', 'Меч (+10 сила)', 50, 'sword', 10)">
                <img src="sword_thumb.png" alt="Меч">
                <p>Меч</p>
                <p>50 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('bow.png', 'Лук (+8 сила)', 40, 'bow', 8)">
                <img src="bow_thumb.png" alt="Лук">
                <p>Лук</p>
                <p>40 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('crossbow.png', 'Арбалет (+12 сила)', 60, 'crossbow', 12)">
                <img src="crossbow_thumb.png" alt="Арбалет">
                <p>Арбалет</p>
                <p>60 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('armor.png', 'Доспехи (+15 защита)', 70, 'armor', 15)">
                <img src="armor_thumb.png" alt="Доспехи">
                <p>Доспехи</p>
                <p>70 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('helmet.png', 'Шлем (+5 защита)', 30, 'helmet', 5)">
                <img src="helmet_thumb.png" alt="Шлем">
                <p>Шлем</p>
                <p>30 золота</p>
            </div>
            
        </div>
    </div>
    <div id="topPlayersMenu">
        <button onclick="toggleTopPlayers()">Закрыть</button>
    </div>

<div class="status-bar" id="statusBar" style="display:none;">
    <div class="health-bar">
        <div class="health-bar-inner" id="playerHealthBar"></div>
    </div>
    <p>Уровень: <span id="statusLevel"></span></p>
    <p>Золото: <img src="gold_icon.png" alt="Gold Icon" style="width: 20px; height: 20px; vertical-align: middle;"> <span id="statusGold"></span></p>
    <p>Урон: <img src="damage_icon.png" alt="Gold Icon" style="width: 20px; height: 20px; vertical-align: middle;"> <span id="statusDamage"></span></p>
    
</div>



    
    <div class="victory-message" id="victoryMessage">
        <p>Shap в печали, что вы его бьете :(</p>
    </div>
    

    
    
    <div class="crosshair" id="crosshair"></div>
    <div id="itemDetail">
        <img id="itemDetailImage" src="" alt="Item Detail">
        <p id="itemDetailName"></p>
        <button onclick="buyItem()">Купить</button>
        <button onclick="closeItemDetail()">Закрыть</button>
    </div>
    <div id="continuePrompt">
        <img id="victoryImage" src="win2.png" alt="Вы победили" style="display: none; width: 700px; height: auto;">
        <p>Shap в печали, что вы его бьете :(</p>
        <p>Вы хотите продолжить унижать Shap и убить следующего монстра?</p>
        <div id="goldEarned" style="display: none; font-size: 24px; color: gold; font-family: 'Comic Sans MS', cursive, sans-serif;">Золото: <span id="goldAmount"></span></div>
        
    </div>
    
    
    
    <div class="monster-message" id="monsterMessage"></div>
    <script type="module">

let rewardMultiplier = 1; // Начальное значение множителя награды


    // Данные о героях
    let heroes = [
        { name: 'Эльф', level: 0, damage: 1, cost: 15, img: 'hero1.png', hired: false },
        { name: 'Гном', level: 0, damage: 10, cost: 100, img: 'hero2.png', hired: false },
        { name: 'хоббит', level: 0, damage: 120, cost: 1000, img: 'hero3.png', hired: false },
        { name: 'Тор', level: 0, damage: 1000, cost: 5000, img: 'hero4.png', hired: false },
        { name: 'Кузнечик', level: 0, damage: 2500, cost: 15000, img: 'hero5.png' , hired: false},
    ];

    function createHeroElement(hero) {
    const heroDiv = document.createElement('div');
    heroDiv.className = `hero ${hero.hired ? 'hired' : 'not-hired'}`;

    const heroImg = document.createElement('img');
    heroImg.src = hero.img;
    heroImg.alt = hero.name;
    heroDiv.appendChild(heroImg);

    const heroName = document.createElement('p');
    heroName.textContent = hero.name;
    heroDiv.appendChild(heroName);

    const heroLevel = document.createElement('p');
    heroLevel.textContent = `Ур.: ${hero.level}`;
    heroDiv.appendChild(heroLevel);

    const heroDamage = document.createElement('p');
    heroDamage.textContent = `Урон: ${hero.damage}`;
    heroDiv.appendChild(heroDamage);

    const heroCost = document.createElement('p');
    const upgradeCost = hero.hired ? hero.cost * (hero.level + 1) : hero.cost;
    heroCost.textContent = `Стоимость: ${upgradeCost}`;
    heroDiv.appendChild(heroCost);

    const hireButton = document.createElement('button');
    hireButton.textContent = hero.hired ? 'Улучшить' : 'Нанять';
    hireButton.onclick = () => {
        hireOrUpgradeHero(hero, heroDiv, hireButton);
    };
    heroDiv.appendChild(hireButton);

    return heroDiv;
}

window.createHeroElement = createHeroElement;

    // Функция для добавления героев в меню
    function addHeroesToMenu() {
    const leftCharacterMenu = document.getElementById('leftCharacterMenu');
    leftCharacterMenu.innerHTML = ''; // Очистка меню перед добавлением героев
    heroes.forEach(hero => {
        const heroElement = createHeroElement(hero);
        leftCharacterMenu.appendChild(heroElement);
    });
}

    window.addHeroesToMenu = addHeroesToMenu;


    function hireOrUpgradeHero(hero, heroDiv, hireButton) {
    if (!hero.hired && gold >= hero.cost) {
        gold -= hero.cost;
        hero.hired = true;
        totalDamage += hero.damage;
        heroDiv.classList.remove('not-hired');
        heroDiv.classList.add('hired');
        hireButton.textContent = 'Улучшить';
        console.log(`${hero.name} нанят за ${hero.cost} золота! Осталось золота: ${gold}`);
    } else if (hero.hired) {
        const upgradeCost = hero.cost * (hero.level + 1);
        if (gold >= upgradeCost) {
            gold -= upgradeCost;
            totalDamage -= hero.damage;
            hero.level++;
            hero.damage += 10; // Пример повышения урона
            totalDamage += hero.damage;
            hireButton.textContent = 'Улучшить';
            heroDiv.querySelector('p:nth-child(3)').textContent = `Ур.: ${hero.level}`;
            heroDiv.querySelector('p:nth-child(4)').textContent = `Урон: ${hero.damage}`;
            updateHeroCost(hero, heroDiv); // Обновление стоимости до нажатия кнопки
            console.log(`${hero.name} улучшен до уровня ${hero.level} за ${upgradeCost} золота! Осталось золота: ${gold}`);
        } else {
            console.log('Недостаточно золота для улучшения!');
        }
    } else {
        console.log('Недостаточно золота для найма!');
    }
    updateTotalDamage();
    localGoldUpdated = true; // Устанавливаем флаг перед обновлением статус бара
    updateStatusBar(); // Обновление статус бара после найма/улучшения героя
    saveGoldToDatabase(); // Явное сохранение золота в базу данных
    savePlayerData(); // Сохранение прогресса после изменения состояния героя
}

window.hireOrUpgradeHero = hireOrUpgradeHero;


function saveGoldToDatabase() {
    const playerGoldRef = ref(database, `players/${nickname}/gold`);
    set(playerGoldRef, gold).then(() => {
        console.log(`Gold saved to database: ${gold}`);
    }).catch((error) => {
        console.error('Error saving gold to database:', error);
    });
}



// Функция для обновления суммарного урона
function updateTotalDamage() {
    totalDamage = calculateTotalDamage();
    const totalDamageElement = document.getElementById('totalDamage');
    if (totalDamageElement) {
        totalDamageElement.textContent = `Суммарный урон: ${totalDamage}`;
    }
}
window.updateTotalDamage = updateTotalDamage;






import { initializeApp } from "https://www.gstatic.com/firebasejs/9.1.1/firebase-app.js";
import { getDatabase, ref, set, get, child, runTransaction, onValue } from "https://www.gstatic.com/firebasejs/9.1.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCPQFqbWCL3XaM-sLYDWgWMdslhS7O7WC8",
            authDomain: "game-7bdb0.firebaseapp.com",
            databaseURL: "https://game-7bdb0-default-rtdb.firebaseio.com",
            projectId: "game-7bdb0",
            storageBucket: "game-7bdb0.appspot.com",
            messagingSenderId: "327382187542",
            appId: "1:327382187542:web:cc82e8673791983404bf37",
            measurementId: "G-8JBZ9PEV84"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        window.currentSessionId = null;

function startSession(nickname) {
    const sessionId = generateSessionId();
    set(ref(database, 'players/' + nickname + '/session'), sessionId);
    return sessionId;
}












async function saveProgress() {
    if (!nickname || !currentSessionId) {
        console.error('Cannot save progress: no nickname or session ID');
        return;
    }

    const progressData = {
        currentLevel,
        gold,
        playerHealth,
        weaponPower,
        weaponName,
        weaponLevel,
        heroes,
        levels,
        session: currentSessionId,
        monsterHealth // Добавляем здоровье монстра для сохранения
    };
    console.log('Saving progress:', progressData); // Логирование данных перед сохранением
    try {
        const dbRef = ref(database, `players/${nickname}/progress`);
        const sessionRef = ref(database, `players/${nickname}/session`);
        const sessionSnapshot = await get(sessionRef);
        if (sessionSnapshot.val() !== currentSessionId) {
            console.log(`Session mismatch, progress not saved. Current session: ${currentSessionId}, Server session: ${sessionSnapshot.val()}`);
            alert('Сессия изменилась. Прогресс не сохранен.');
            return;
        }
        await set(dbRef, progressData);
        console.log('Data saved successfully:', progressData); // Логирование успешного сохранения
    } catch (error) {
        console.error('Error saving progress:', error);
    }
}
window.saveProgress = saveProgress;








function savePlayerData() {
    if (nickname && currentSessionId) {
        saveProgress(nickname, currentSessionId, {
            currentLevel,
            gold,
            playerHealth,
            weaponPower,
            weaponName,
            weaponLevel,
            levels,
            heroes // Сохранение данных о героях
        });
    }
}



function validateData(data) {
    if (!data || !data.heroes || !Array.isArray(data.heroes)) {
        console.error('Invalid data format:', data);
        return false;
    }
    return true;
}

// Функция для загрузки прогресса
async function loadProgress(nickname) {
    if (!nickname) {
        console.error('Cannot load progress: no nickname');
        return;
    }

    try {
        const dbRef = ref(database, `players/${nickname}/progress`);
        const snapshot = await get(dbRef);
        if (snapshot.exists()) {
            const data = snapshot.val();
            console.log('Loaded progress:', data);
            applyProgress(data);
        } else {
            console.log('No progress found for', nickname);
            return null;
        }
    } catch (error) {
        console.error('Error loading progress:', error);
        return null;
    }
}


// Функция для применения загруженного прогресса
function applyProgress(data) {
    if (data && validateData(data)) {
        currentLevel = data.currentLevel;
        gold = data.gold;
        playerHealth = data.playerHealth;
        weaponPower = data.weaponPower;
        weaponName = data.weaponName;
        weaponLevel = data.weaponLevel;
        heroes = data.heroes || heroes;
        levels = data.levels || levels;
        monsterHealth = data.monsterHealth || baseMonsterHealth; // Восстанавливаем здоровье монстра

        console.log('Loaded progress:', data); // Логирование загруженных данных

        updateCharacterMenu();
        addHeroesToMenu();
    }
}


function updateHeroCost(hero, heroDiv) {
    const upgradeCost = hero.cost * (hero.level + 1);
    heroDiv.querySelector('p:nth-child(5)').textContent = `Стоимость: ${upgradeCost}`;
}


function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        window.toggleFullscreen = toggleFullscreen;

        function toggleMailWindow() {
    const mailWindow = document.getElementById('mailWindow');
    if (mailWindow.style.display === 'block') {
        mailWindow.style.display = 'none';
    } else {
        mailWindow.innerHTML = ''; // Очищаем содержимое перед загрузкой новой почты
        loadMail();
        mailWindow.style.display = 'block';
    }
}
window.toggleMailWindow = toggleMailWindow;


const characterImages = [
    'peasant.png',     // 0-9 уровень
    'warrior.png',     // 10-19 уровень
    'knight.png',      // 20-29 уровень
    'mage.png',        // 30-39 уровень
    'archer.png',      // 40-49 уровень
    'paladin.png',     // 50-59 уровень
    'barbarian.png',   // 60-69 уровень
    'assassin.png',    // 70-79 уровень
    'samurai.png',     // 80-89 уровень
    'dragon_knight.png' // 90-99 уровень
];

function updateCharacterImage() {
    const index = Math.floor(currentLevel / 10);
    const imageIndex = index < characterImages.length ? index : characterImages.length - 1;
    document.getElementById('characterImage').src = characterImages[imageIndex];
}
window.updateCharacterImage = updateCharacterImage;



function getMonsterImage(level) {
    if (level >= 90) {
        return monsterImages[monsterImages.length - 1];
    }
    const index = Math.floor(level / 10);
    return monsterImages[index % monsterImages.length];
}

window.getMonsterImage = getMonsterImage;

function updateMonsterImage(level) {
    const imageSrc = getMonsterImage(level);
    monsterImage.src = imageSrc;
    console.log(`Updated monster image to: ${imageSrc} for level ${level}`);
}
window.updateMonsterImage = updateMonsterImage;


        function updateTopPlayers(nickname, playerData) {
            set(ref(database, 'topPlayers/' + nickname), playerData);
        }

        function displayTopPlayers() {
    const dbRef = ref(database);
    return get(child(dbRef, 'topPlayers')).then((snapshot) => {
        if (snapshot.exists()) {
            const topPlayers = snapshot.val();
            // Преобразование объекта в массив и сортировка по уровню
            const sortedPlayers = Object.values(topPlayers).sort((a, b) => b.level - a.level);
            
            let topListHTML = '<h2>Топ игроки</h2>';
            sortedPlayers.forEach(player => {
                topListHTML += `<p>${player.nickname} - Уровень ${player.level}</p>`;
            });
            document.getElementById('topPlayersMenu').innerHTML = topListHTML;
            return topPlayers;
        } else {
            console.log("No data available");
            return {};
        }
    }).catch((error) => {
        console.error(error);
    });
}


        let nickname = '';
        let currentSessionId = null;
        let totalDamage = 10;
        let currentLevel = 1;
        
        let playerHealth = 100;
        let weaponPower = 10;
        let weaponName = 'Кулаки';
        let weaponLevel = 0;
        //let selectedItem = {};
        const monsterMessages = ["Не бейте меня", "За что мне это все ?? ", "я не буду больше читерить", "простите я просто сплю с админами :( )"];

        const monsterImages = [
            'monster1.png',
            'monster2.png',
            'monster3.png',
            'monster4.png',
            'monster5.png',
            'monster6.png',
            'monster7.png',
            'monster8.png',
            'monster9.png',
            'monster10.png'
        ];

let worldBossHealth = 1000000;
let playersDamage = {};
let isUpdating = false;
let isAutoHitting = false;
let autoHitInterval;


        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let currentScreen = 'menu';
            let hits = 0;
            let baseMonsterHealth = 100; // Установите это значение на начальное здоровье монстра
            let monsterHealth = baseMonsterHealth;
            let levels = new Array(10000).fill().map((_, i) => ({ number: i + 1, stars: 0, completed: false }));


        const backgroundImage = new Image();
        backgroundImage.src = 'background.png';
        const castle = new Image();
        castle.src = 'castle.png';
        const arena2 = new Image();
        arena2.src = 'arena.png';
        const dungeonGateImage = new Image();
        dungeonGateImage.src = 'dung.png';
        const monsterImage = new Image();
        //monsterImage.src = 'mob.png';
        const mapImage = new Image();
        mapImage.src = 'map.png';
        const starImage = new Image();
        starImage.src = 'star.png';
        const peasantImage = 'peasant.png';
        const peasantWithSwordImage = 'peasant_with_sword.png';






        starImage.onload = function() {
            drawLevelMap();
        };
        
        // Crosshair logic
        const crosshair = document.getElementById('crosshair');
        document.addEventListener('mousemove', (event) => {
    if (currentScreen === 'battle') {
        crosshair.style.left = `${event.clientX}px`;
        crosshair.style.top = `${event.clientY}px`;
    } else {
        crosshair.style.display = 'none'; // Скрываем прицел, если не в режиме "battle"
    }
});




function toggleAutoHit() {
    if (isAutoHitting) {
        clearInterval(autoHitInterval);
        isAutoHitting = false;
        document.getElementById('autoboyButton').textContent = 'Автобой';
    } else {
        isAutoHitting = true;
        document.getElementById('autoboyButton').textContent = 'Стоп Автобой';
        autoHitInterval = setInterval(() => {
            if (currentScreen === 'battle') {
                hitMonster({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
            }
        }, 1000);
    }
}
window.toggleAutoHit = toggleAutoHit;





        function showHitAnimation() {
            crosshair.style.transition = 'transform 0.1s ease-in-out';
            crosshair.style.transform = 'translate(-50%, -50%) scale(0.8)';
            showMonsterMessage();
            setTimeout(() => {
                crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 100);
        }
        window.showHitAnimation = showHitAnimation;

        function showMonsterMessage() {
            const message = monsterMessages[Math.floor(Math.random() * monsterMessages.length)];
            const monsterMessage = document.getElementById('monsterMessage');
            monsterMessage.textContent = message;
            monsterMessage.style.display = 'block';
            setTimeout(() => {
                monsterMessage.style.display = 'none';
            }, 500);
        }
        window.showMonsterMessage = showMonsterMessage;
      
        function drawStars(x, y, count) {
    //console.log(`Drawing ${count} stars at (${x}, ${y})`);
    for (let i = 0; i < count; i++) {
        ctx.drawImage(starImage, x + i * 30, y, 20, 20);
    }
}
        window.drawStars = drawStars;

        function toggleShop() {
            const shopMenu = document.getElementById('shopMenu');
            shopMenu.style.display = shopMenu.style.display === 'block' ? 'none' : 'block';
            updateShop();
        }
        window.toggleShop = toggleShop; // Добавляем в глобальную область видимости

        function drawShop() {
            document.getElementById('shopGold').textContent = gold;
        }
        window.drawShop = drawShop;

        let gold = 100;

        function updateGold(amount) {
    return new Promise((resolve, reject) => {
        gold = amount;
        document.getElementById('statusGold').textContent = gold;
        const playerGoldRef = ref(database, `players/${nickname}/gold`);
        set(playerGoldRef, gold).then(() => {
            console.log(`Gold updated in database: ${gold}`);
            resolve();
        }).catch((error) => {
            console.error('Error updating gold:', error);
            reject(error);
        });
    });
}

window.updateGold = updateGold;

async function startGame() {
    const input = document.getElementById('nicknameInput').value;
    console.log(`Nickname entered: ${input}`);
    if (input) {
        nickname = input;
        const dbRef = ref(database, `players/${nickname}/session`);

        try {
            const sessionSnapshot = await get(dbRef);
            if (sessionSnapshot.exists()) {
                const existingSessionId = sessionSnapshot.val();
                console.log(`Existing session found for ${nickname}: ${existingSessionId}`);
                await endSession(nickname, existingSessionId);
            } else {
                console.log(`No existing session found for ${nickname}`);
            }

            const newSessionId = generateSessionId();
            await set(dbRef, newSessionId);
            currentSessionId = newSessionId;
            console.log(`New session started for ${nickname}: ${newSessionId}`);
            watchSessionChanges();

            // Загружаем прогресс игрока
            const progressData = await loadProgress(nickname);

            if (!progressData) {
                // Устанавливаем начальное количество золота для нового игрока, если прогресс не найден
                const playerGoldRef = ref(database, `players/${nickname}/gold`);
                await set(playerGoldRef, 100); // Устанавливаем начальное значение золота
            }

            continueGameSetup();
        } catch (error) {
            console.error('Error starting new session:', error);
        }
    } else {
        alert('Пожалуйста, введите никнейм.');
    }
}


window.startGame = startGame;

async function endSession(nickname, sessionId) {
    const dbRef = ref(database, `players/${nickname}/session`);
    try {
        const result = await runTransaction(dbRef, (currentSession) => {
            if (currentSession === null) {
                console.log(`No session to end for ${nickname}.`);
                return null; // Ignore if there's no session
            }
            if (currentSession === sessionId) {
                console.log(`Ending session ${sessionId} for ${nickname}`);
                return null;
            } else {
                console.error(`Session mismatch during transaction: currentSession=${currentSession}, sessionId=${sessionId}`);
                throw new Error("Session mismatch");
            }
        });
        if (result.committed) {
            console.log(`Session ${sessionId} for ${nickname} ended successfully`);
            currentSessionId = null;
        } else {
            console.log(`Session ${sessionId} for ${nickname} was not ended`);
        }
    } catch (error) {
        console.error('Error ending session:', error);
    }
}
window.endSession = endSession;

function watchSessionChanges() {
    const dbRef = ref(database, `players/${nickname}/session`);
    onValue(dbRef, (snapshot) => {
        const sessionId = snapshot.val();
        if (sessionId !== currentSessionId && sessionId !== null) {
            console.log(`Session changed from ${currentSessionId} to ${sessionId}`);
            alert('Вы были выброшены из игры, так как сессия была начата с другого устройства или вкладки.');
            endCurrentSession();
            location.reload();  // Перезагрузка страницы для выхода из игры
        }
    });
}
window.watchSessionChanges = watchSessionChanges;

function generateSessionId() {
    return Math.random().toString(36).substr(2, 9);
}

function endCurrentSession() {
    if (nickname && currentSessionId) {
        endSession(nickname, currentSessionId);
    }
}
window.endCurrentSession = endCurrentSession;

async function continueGameSetup() {
    const data = await loadProgress(nickname);
    console.log(`Data loaded: ${JSON.stringify(data)}`);
    applyProgress(data);

    document.getElementById('nicknameMenu').style.display = 'none';
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('bottomMenu').style.display = 'flex';
    currentScreen = 'menu';
    console.log(`Screen set to: ${currentScreen}`);

    // Убедитесь, что загружаемый прогресс корректен
    if (data && data.levels) {
        levels = data.levels;
    }

    initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
    drawMenu();
}

window.continueGameSetup = continueGameSetup;


function showRebornPrompt() {
    document.getElementById('rebornPrompt').style.display = 'block';
}

function hideRebornPrompt() {
    document.getElementById('rebornPrompt').style.display = 'none';
}

function confirmReborn() {
    hideRebornPrompt();
    // Сбросить прогресс уровней, нанятые герои и золото
    levels = new Array(10000).fill().map((_, i) => ({ number: i + 1, stars: 0, completed: false }));
    heroes.forEach(hero => {
        hero.level = 0;
        hero.hired = false;
        hero.damage = hero.name === 'Эльф' ? 1 : (hero.name === 'Гном' ? 10 : 0); // Устанавливаем базовый урон для каждого героя
    });
    currentLevel = 1;
    rewardMultiplier = 2; // Установите множитель награды
    
    // Обновляем золото и сохраняем прогресс
    updateGold(100).then(() => {
        // Обновление интерфейса
        updateCharacterMenu();
        addHeroesToMenu(); // Обновляем меню героев
        startLevel(currentLevel);
        alert('Вы переродились! Теперь вы будете получать награды за убийство монстров в два раза выше.');
    }).catch(error => {
        console.error('Error updating gold:', error);
    });
}



window.showRebornPrompt = showRebornPrompt;
window.hideRebornPrompt = hideRebornPrompt;
window.confirmReborn = confirmReborn;



function sendRewards() {
    const sortedPlayers = Object.entries(playersDamage).sort(([, damageA], [, damageB]) => damageB - damageA);
    const rewards = {
        top3: 10000,
        top10: 1000
    };

    sortedPlayers.forEach(([player, damage], index) => {
        let reward = 0;
        if (index < 3) {
            reward = rewards.top3;
        } else if (index < 10) {
            reward = rewards.top10;
        }
        if (reward > 0) {
            sendMail(player, reward, index + 1, damage);
            console.log(`Reward sent to player ${player}: ${reward} gold for rank ${index + 1} with damage ${damage}`);
        }
    });

    // Обнуление рейтинга
    playersDamage = {};
    syncPlayersDamage();
}
window.sendRewards = sendRewards;


function sendMail(player, reward, rank, damage) {
    const mailMessage = `Поздравляем! Вы заняли ${rank}-е место в рейтинге с уроном ${damage}. Ваша награда: ${reward} золота.`;
    const playerMailRef = ref(database, `players/${player}/mail`);
    console.log(`Preparing to send mail to ${player}: ${mailMessage}`);
    get(playerMailRef).then((snapshot) => {
        let playerMail = snapshot.val() || {};
        // Проверка на существование аналогичного письма
        const existingMail = Object.values(playerMail).find(mail => mail.message === mailMessage);
        if (existingMail) {
            console.log(`Mail already exists for player ${player}: ${mailMessage}`);
            return;
        }
        const mailId = `mail_${Date.now()}`;
        playerMail[mailId] = {
            reward: reward,
            message: mailMessage,
            timestamp: Date.now()
        };
        set(playerMailRef, playerMail).then(() => {
            console.log(`Mail sent to player ${player}: ${mailMessage}`);
        }).catch((error) => {
            console.error('Error setting mail data:', error);
        });
    }).catch((error) => {
        console.error('Error getting mail data:', error);
    });
}
window.sendMail = sendMail;





function loadMail() {
    const mailWindow = document.getElementById('mailWindow');
    mailWindow.innerHTML = '<h2>Ваша почта</h2><div id="mailContent"></div><button onclick="toggleMailWindow()">Закрыть</button>';
    const mailContent = document.getElementById('mailContent');
    const playerMailRef = ref(database, `players/${nickname}/mail`);
    console.log(`Loading mail for player ${nickname}`);
    get(playerMailRef).then((snapshot) => {
        const mailsObject = snapshot.val() || {};
        console.log('Mails Object:', mailsObject);
        const mails = Object.entries(mailsObject); // Преобразуем объект в массив [ключ, значение]
        mails.forEach(([mailId, mail]) => {
            const mailItem = document.createElement('div');
            console.log('Mail Item:', mail);
            mailItem.innerHTML = `
                <p>${mail.message}</p>
                <p>Награда: ${mail.reward} золота</p>
                <button onclick="claimReward('${mailId}', ${mail.reward})">Получить награду</button>
            `;
            mailContent.appendChild(mailItem);
        });
    }).catch((error) => {
        console.error('Error loading mail:', error);
    });
}
window.loadMail = loadMail;

function claimReward(mailId, reward) {
    const playerMailRef = ref(database, `players/${nickname}/mail/${mailId}`);
    const playerGoldRef = ref(database, `players/${nickname}/gold`);

    // Получаем текущее количество золота
    get(playerGoldRef).then((snapshot) => {
        let currentGold = snapshot.val() || 0;
        let newGold = currentGold + reward;
        updateGold(newGold);  // Используем updateGold

        // Удаляем письмо
        set(playerMailRef, null).then(() => {
            console.log(`Mail ${mailId} deleted`);

            // Перезагружаем почту
            loadMail();
            saveProgress(); // Сохраняем прогресс
            updateStatusBar(); // Обновляем статус бар
        }).catch((error) => {
            console.error('Error deleting mail:', error);
        });
    }).catch((error) => {
        console.error('Error getting current gold:', error);
    });
}

window.claimReward = claimReward;



function spendGold(amount) {
    const playerGoldRef = ref(database, `players/${nickname}/gold`);

    // Получаем текущее количество золота
    get(playerGoldRef).then((snapshot) => {
        let currentGold = snapshot.val() || 0;
        if (currentGold >= amount) {
            updateGold(currentGold - amount);  // Используем updateGold

            // Обновляем количество золота и сохраняем прогресс
            set(playerGoldRef, currentGold).then(() => {
                console.log(`Gold spent: ${amount}, remaining gold: ${currentGold}`);
                gold = currentGold; // Обновляем глобальную переменную золота
                document.getElementById('statusGold').textContent = gold; // Обновляем отображение золота в интерфейсе
                saveProgress(); // Сохраняем прогресс
                updateStatusBar(); // Обновляем статус бар
            }).catch((error) => {
                console.error('Error updating gold:', error);
            });
        } else {
            console.log('Not enough gold to spend.');
        }
    }).catch((error) => {
        console.error('Error getting current gold:', error);
    });
}
window.spendGold = spendGold;










function resetWorldBossHealth() {
    worldBossHealth = 1000000; // Установите максимальное здоровье босса
    syncWorldBossHealth(); // Синхронизируйте новое значение здоровья с базой данных
    console.log("World Boss Health has been reset to 100%");
    updateWorldBossHealthDisplay(); // Обновите отображение здоровья на экране
    drawWorldBossBattle(); // Перерисуйте экран боя с боссом
}
function getTimeUntilNextHour() {
    const now = new Date();
    const nextHour = new Date(now.getTime() + (60 - now.getMinutes()) * 60 * 1000);
    nextHour.setMinutes(0, 0, 0);
    return nextHour - now;
}
function startHourlyReset() {
    const timeUntilNextHour = getTimeUntilNextHour();
    
    // Запускаем таймер, который сбросит здоровье в начале следующего часа
    setTimeout(() => {
        resetWorldBossHealth();
        
        // После сброса здоровья запускаем интервал на каждый час
        setInterval(resetWorldBossHealth, 3600000);
    }, timeUntilNextHour);
}




 

        function buyWeapon(type, power, cost) {
            if (gold >= cost) {
                weaponPower = power;
                updateGold(gold - cost);  // Используем updateGold
                weaponLevel = 1;
                if (type === 'sword') {
                    weaponName = 'Меч';
                    document.getElementById('characterImage').src = peasantWithSwordImage;
                }
                updateCharacterMenu();
                updateShop();
                saveProgress(nickname, {
                    currentLevel,
                    gold,
                    playerHealth,
                    weaponPower,
                    weaponName,
                    weaponLevel
                });
            }
        }

        window.buyWeapon = buyWeapon;

        function upgradeWeapon(type, costPerLevel) {
            if (gold >= costPerLevel && weaponName === 'Меч') {
                weaponPower += 15;
                updateGold(gold - costPerLevel);  // Используем updateGold
                weaponLevel++;
                updateCharacterMenu();
                updateShop();
                saveProgress(nickname, {
                    currentLevel,
                    gold,
                    playerHealth,
                    weaponPower,
                    weaponName,
                    weaponLevel
                });
            }
        }

        window.upgradeWeapon = upgradeWeapon;

        function continueGame() {
    document.getElementById('shopMenu').style.display = 'none';
    if (currentLevel < 10000) {
        currentLevel++;
        initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
        startLevel(currentLevel);
    } else {
        currentScreen = 'victory';
        drawVictoryScreen();
    }
    updateTopPlayers(nickname, { nickname, level: currentLevel });
    drawLevelMap();
}


        window.continueGame = continueGame;

        function getHealthColor(percentage) {
    let color;
    if (percentage > 50) {
        color = 'green';
    } else if (percentage > 20) {
        color = 'yellow';
    } else {
        color = 'red';
    }
    console.log(`Health percentage: ${percentage}, Color: ${color}`);
    return color;
}

function updateMonsterHealthDisplay() {
    const healthBar = document.getElementById('monsterHealthBar');
    const healthValue = document.getElementById('monsterHealthValue');
    console.log('Current monsterHealth:', monsterHealth);

    if (healthBar) {
        const maxHealth = 100 * Math.pow(1.1, currentLevel - 1);
        const healthPercentage = (monsterHealth / maxHealth) * 100;
        const color = getHealthColor(healthPercentage);
        healthBar.style.width = `${Math.min(healthPercentage, 100)}%`;
        healthBar.style.backgroundColor = color; // Обновляем цвет фона
        console.log(`Updated monster health bar: Width: ${healthPercentage}%, Color: ${color}`);
        console.log(`Health bar style:`, healthBar.style);
    }

    if (healthValue) {
        healthValue.textContent = monsterHealth.toFixed(0); // Обновляем текстовое значение здоровья
        console.log(`Updated monster health value: ${monsterHealth.toFixed(0)}`);
    }
}

window.updateMonsterHealthDisplay = updateMonsterHealthDisplay;
window.getHealthColor = getHealthColor;





function hitMonster(event) {
    if (currentScreen !== 'battle') return;
    if (monsterHealth <= 0) return; // Если жизни монстра меньше или равны нулю, не обрабатываем удар

    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    const monsterX = canvas.width / 2 - monsterImage.width / 2;
    const monsterY = canvas.height / 2 - monsterImage.height / 2;

    if (
        mouseX >= monsterX &&
        mouseX <= monsterX + monsterImage.width &&
        mouseY >= monsterY &&
        mouseY <= monsterY + monsterImage.height
    ) {
        showHitAnimation();
        const totalDamage = calculateTotalDamage(); // Получение общего урона
        console.log(`Monster Health before hit: ${monsterHealth}, Total Damage: ${totalDamage}`);
        monsterHealth -= totalDamage;
        if (monsterHealth < 0) {
            monsterHealth = 0;
        }
        console.log(`Monster Health after hit: ${monsterHealth}`); // Логирование здоровья после удара
        hits += 1;
        updateMonsterHealthDisplay(); // Обновление отображения здоровья

        if (monsterHealth <= 0) {
            let goldReward = 10 * currentLevel * rewardMultiplier; // Прогрессия награды золота с учетом множителя
            updateGold(gold + goldReward).then(() => {
                console.log('Gold updated and saved to database:', gold);
            }).catch(error => {
                console.error('Error updating gold:', error);
            });

            if (levels[currentLevel - 1]) {
                levels[currentLevel - 1].completed = true;
            } else {
                console.error(`Level ${currentLevel} is not defined in levels array.`);
            }

            // Логирование прогресса перед сохранением
            console.log('Saving progress after monster kill:', {
                currentLevel,
                gold,
                playerHealth,
                weaponPower,
                weaponName,
                weaponLevel,
                heroes,
                levels,
                monsterHealth // Добавляем здоровье монстра для сохранения
            });

            // Сохранение прогресса после убийства монстра
            saveProgress();

            console.log("Calling showVictoryMessage()");
            showVictoryMessage();
        }
        updateCharacterImage(); // вызов функции для смены изображения
    }
}

window.hitMonster = hitMonster;


// Начальное создание монстра с базовым здоровьем
function initializeMonster(initialHealth) {
    monsterHealth = initialHealth;
    console.log('Initializing monster with health:', initialHealth);
    updateMonsterImage(currentLevel);
    updateMonsterHealthDisplay();
}

window.initializeMonster = initializeMonster;

const level = 5;
const baseHealth = 100; // Предположим, базовое здоровье
const calculatedHealth = baseHealth * Math.pow(1.1, level - 1);
console.log(`Calculated health for level ${level}: ${calculatedHealth}`);




// Функция для продолжения игры после победы над монстром
function showContinuePrompt() {
    currentLevel++; // Переход к следующему уровню
    console.log(`Proceeding to level ${currentLevel}`);

    // Используем фиксированное baseMonsterHealth для расчета нового здоровья монстра
    const newMonsterHealth = baseMonsterHealth * Math.pow(1.1, currentLevel - 1);
    console.log(`New monster health for level ${currentLevel}: ${newMonsterHealth}`);
    console.log(`Base monster health: ${baseMonsterHealth}`); // Логирование начального значения здоровья
    monsterHealth = newMonsterHealth;

    // Логирование прогресса перед сохранением на новом уровне
    console.log('Saving progress after proceeding to next level:', {
        currentLevel,
        gold,
        playerHealth,
        weaponPower,
        weaponName,
        weaponLevel,
        heroes,
        levels,
        monsterHealth // Добавляем здоровье монстра для сохранения
    });

    // Сохранение прогресса на новом уровне
    saveProgress();

    initializeMonster(newMonsterHealth);
    drawMenu();
}




window.showContinuePrompt = showContinuePrompt;

function resetMonsterState() {
    initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
    console.log(`Monster health reset to: ${monsterHealth}`);
}





function hideContinuePrompt() {
    document.getElementById('continuePrompt').style.display = 'none';
    document.getElementById('victoryImage').style.display = 'none';
    document.getElementById('goldEarned').style.display = 'none'; // Скрыть текст с количеством золота
}



function continueToNextLevel() {
    hideContinuePrompt();
    if (currentLevel < 10000) {
        currentLevel++;
        startLevel(currentLevel);
        updateCharacterImage(); // вызов функции для смены изображения
    } else {
        currentScreen = 'victory';
        drawVictoryScreen();
    }
    updateTopPlayers(nickname, { nickname, level: currentLevel });
    drawLevelMap();
}



window.continueToNextLevel = continueToNextLevel;




        function drawMenu() {
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        }
        function drawCastle() {
            ctx.drawImage(castle, 0, 0, canvas.width, canvas.height);
            document.getElementById('mailButton').style.display = 'block'; // Отображаем кнопку почты

            // Логирование координат и размеров кнопки почты
            const mailButton = document.getElementById('mailButton');
            const rect = mailButton.getBoundingClientRect();
            console.log(`Mail button coordinates: (${rect.left}, ${rect.top})`);
            console.log(`Mail button size: ${rect.width}x${rect.height}`);
        }
        window.drawCastle = drawCastle;
        function arena() {
            ctx.drawImage(arena2, 0, 0, canvas.width, canvas.height);
        }

        function drawDungeonEntrance() {
           // ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            ctx.drawImage(dungeonGateImage,0, 0, canvas.width, canvas.height);
        }

        function drawVictoryScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Вы победили!', canvas.width / 2, canvas.height / 2);
        }
        
        function showVictoryMessage() {
    console.log("Victory message displayed");

    // Создаем контейнер для сообщения о победе
    const victoryMessage = document.createElement('div');
    victoryMessage.id = 'victoryMessage';
    victoryMessage.style.position = 'absolute';
    victoryMessage.style.top = '50%';
    victoryMessage.style.left = '50%';
    victoryMessage.style.transform = 'translate(-50%, -50%)';
    victoryMessage.style.padding = '20px';
    victoryMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    victoryMessage.style.color = 'white';
    victoryMessage.style.fontSize = '24px';
    victoryMessage.style.textAlign = 'center';
    document.body.appendChild(victoryMessage);

    // Добавляем картинку победы
    const victoryImage = document.createElement('img');
    victoryImage.id = 'victoryImage';
    victoryImage.src = 'win2.png';
    victoryImage.alt = 'Вы победили';
    victoryImage.style.width = '700px';
    victoryImage.style.height = 'auto';
    victoryImage.onclick = () => {
        document.body.removeChild(victoryMessage);
        showContinuePrompt();
    };
    victoryMessage.appendChild(victoryImage);

    // Добавляем отображение заработанного золота
    const goldEarnedDiv = document.createElement('div');
    goldEarnedDiv.id = 'goldEarned';
    goldEarnedDiv.style.fontSize = '24px';
    goldEarnedDiv.style.color = 'gold';
    goldEarnedDiv.style.fontFamily = "'Comic Sans MS', cursive, sans-serif";
    goldEarnedDiv.textContent = `Золото: ${document.getElementById('goldAmount').textContent}`;
    victoryMessage.appendChild(goldEarnedDiv);

    // Добавляем текст сообщения о победе
    const victoryText = document.createElement('p');
    victoryText.textContent = 'Победа! Вы хотите продолжить унижать Shap и убить следующего монстра?';
    victoryMessage.appendChild(victoryText);

    // Убираем сообщение через 3 секунды
    setTimeout(() => {
        if (document.body.contains(victoryMessage)) {
            document.body.removeChild(victoryMessage);
            showContinuePrompt();
        }
    }, 3000); // Время отображения сообщения о победе
}

window.showVictoryMessage = showVictoryMessage;


function calculateStars() {
    // Логика расчета количества звезд, например, на основе оставшегося здоровья игрока или времени
    if (playerHealth > 80) {
        return 3;
    } else if (playerHealth > 50) {
        return 2;
    } else {
        return 1;
    }
}

function startLevel(levelNumber) {
    currentLevel = levelNumber;
    monsterHealth = 100 * Math.pow(1.1, levelNumber - 1); // Устанавливаем здоровье монстра на основе уровня
    console.log(`Starting level ${levelNumber}`);
    console.log(`Monster health set to: ${monsterHealth}`);
    document.getElementById('monsterHealthContainer').style.display = 'block'; // Отображение контейнера здоровья монстра
    document.getElementById('monsterHealthBar').style.width = '100%'; // Полная ширина при начале уровня
    updateMonsterImage(levelNumber); // Устанавливаем изображение монстра
    
    currentScreen = 'battle';
    drawBattle();
    updateMonsterHealthDisplay(); // Обновление отображения здоровья при начале уровня
    updateCharacterImage(); // вызов функции для смены изображения
}

window.startLevel = startLevel;

function showHealthBar() {
    const healthContainer = document.getElementById('monsterHealthContainer');
    healthContainer.style.display = 'block';
}

window.showHealthBar = showHealthBar;





function completeLevel(levelNumber, stars) {
    if (levels[levelNumber - 1]) {
        levels[levelNumber - 1].completed = true;
        levels[levelNumber - 1].stars = stars;
        saveProgress(nickname, {
            currentLevel,
            gold,
            playerHealth,
            weaponPower,
            weaponName,
            weaponLevel,
            levels
        });
        drawLevelMap();
    }
    updateCharacterImage(); // вызов функции для смены изображения
}
window.completeLevel = completeLevel;


function drawLevelsScreen() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'white';
    ctx.font = '30px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Уровни и Звезды', canvas.width / 2, 50);

    levels.forEach((level, index) => {
        const { x, y } = getLevelPosition(index);

        ctx.fillStyle = level.completed ? 'gold' : 'silver';
        ctx.beginPath();
        ctx.arc(x, y, 25, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.fillText(level.number, x, y + 8);

        drawStars(x - 30, y + 35, level.stars);
    });
}





        function drawLevelMap() {
            console.log(levels);  // Вывод данных уровней в консоль
            console.log('Drawing level map');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);

            levels.forEach((level, index) => {
                const { x, y } = getLevelPosition(index);

                ctx.fillStyle = level.completed ? 'gold' : 'silver';
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(level.number, x, y + 8);

                drawStars(x - 30, y + 35, level.stars);
            });
        }

        function getLevelPosition(index) {
            const perRow = 5;
            const spacing = 80;
            const offsetX = (canvas.width - perRow * spacing) / 2;
            const offsetY = 100;

            const x = offsetX + (index % perRow) * spacing;
            const y = offsetY + Math.floor(index / perRow) * spacing;
            return { x, y };
        }
        




        const updateInterval = 1000; // Интервал обновления в миллисекундах (1 секунда)

// Функция для регулярного обновления данных
function startUpdating() {
    if (!isUpdating) {
        isUpdating = true;
        setInterval(() => {
            // Получаем последние данные с сервера
            updateWorldBossData();
        }, updateInterval);
    }
}


// Функция для обновления данных босса и игроков
function updateWorldBossData() {
    const dbRef = ref(database);
    get(child(dbRef, 'worldBoss')).then((snapshot) => {
        if (snapshot.exists()) {
            const data = snapshot.val();
            worldBossHealth = data.health;
            playersDamage = data.playersDamage || {};
            if (currentScreen === 'worldBoss') {
                drawWorldBossBattle();
            }
        } else {
            console.log("No data available for world boss");
        }
    }).catch((error) => {
        console.error(error);
    });
}













        
        function drawWorldBossBattle() {
    //console.log('Drawing World Boss Battle');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const worldBossImage = document.getElementById('worldBossImage');
    const bossX = canvas.width / 2 - worldBossImage.width / 2;
    const bossY = canvas.height / 2 - worldBossImage.height / 2;

    ctx.drawImage(worldBossImage, bossX, bossY);

    // Устанавливаем координаты текста выше босса и проверяем, что они в пределах экрана
    const healthTextY = bossY - 40 > 0 ? bossY - 40 : 40;

    // Добавляем лог для проверки координат
    //console.log(`Drawing health text at: ${canvas.width / 2}, ${healthTextY}`);

    // Добавляем отображение здоровья босса над его изображением с жирным шрифтом и обводкой
    ctx.fillStyle = 'white';
    ctx.font = 'bold 32px Comic Sans MS';
    ctx.textAlign = 'center';
    
    // Обводка текста
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.strokeText(`Здоровье: ${worldBossHealth}`, canvas.width / 2, healthTextY);
    
    // Основной текст
    ctx.fillText(`Здоровье: ${worldBossHealth}`, canvas.width / 2, healthTextY);

    // Рисуем полоску здоровья
    drawHealthBar(worldBossHealth, canvas.width - 210, 10, 200, 20, 'red');
    

    // Добавляем отображение рейтинга игроков
    const playersListX = canvas.width - 350; // смещение на 200 пикселей от правого края
const playersListStartY = canvas.height - 700; // смещение на 100 пикселей от низа экрана
    //const playersListStartY = canvas.height / 2 - (Object.keys(playersDamage).length * 15); // вертикальная координата для списка игроков, чтобы он был по центру
    let playersListY = playersListStartY - (Object.keys(playersDamage).length * 15); // вертикальная координата для списка игроков, чтобы он был по центру

    const lineHeight = 30; // задаем отступ между строками

    ctx.textAlign = 'right';
    ctx.font = '26px Roboto';
    ctx.strokeStyle = 'black'; // цвет обводки
    ctx.lineWidth = 4; // ширина обводки
    ctx.fillStyle = 'white'; // цвет текста
    // Отрисовка заголовка
    ctx.strokeText('Рейтинг игроков:', playersListX, playersListY);
    ctx.fillText('Рейтинг игроков:', playersListX, playersListY);
    playersListY += lineHeight; // увеличение отступа после заголовка
 

    Object.entries(playersDamage).sort(([, damageA], [, damageB]) => damageB - damageA).forEach(([player, damage], index) => {
        playersListY += lineHeight; // вертикальное смещение для каждой строки
        ctx.strokeText(`${index + 1}. ${player}: ${damage}`, playersListX, playersListY);
        ctx.fillText(`${index + 1}. ${player}: ${damage}`, playersListX, playersListY);
    });

    updateStatusBar();
}












function drawBattle() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (currentScreen === 'worldBoss') {
        ctx.drawImage(document.getElementById('worldBossImage'), canvas.width / 2 - document.getElementById('worldBossImage').width / 2, canvas.height / 2 - document.getElementById('worldBossImage').height / 2);
        drawHealthBar(worldBossHealth, canvas.width - 210, 10, 200, 20, 'red');
    } else {
        const mobWidth = 600;
        const mobHeight = 580;
        const x = (canvas.width / 2) - (mobWidth / 2);
        const y = (canvas.height / 2) - (mobHeight / 2);
        ctx.drawImage(monsterImage, x, y, mobWidth, mobHeight); // Рисуем текущее изображение монстра

        drawHealthBar(monsterHealth, canvas.width - 210, 10, 200, 20, 'red');
    }

    
    updateStatusBar();
}




function drawHealthBar(health, x, y, width, height, color) {
    ctx.fillStyle = 'grey';
    ctx.fillRect(x, y, width, height);
    ctx.fillStyle = color;
    ctx.fillRect(x, y, width * (health / 1000000), height);  // Учитывая максимальное здоровье босса 1000000
}


        function updateShop() {
            document.getElementById('shopGold').textContent = gold;
        }



// Вызов функции загрузки данных при старте игры





function updateDamageList() {
    const damageList = document.getElementById('damageList');
    damageList.innerHTML = '';

    const sortedPlayers = Object.entries(playersDamage).sort(([, a], [, b]) => b - a);
    sortedPlayers.forEach(([player, damage]) => {
        const listItem = document.createElement('li');
        listItem.textContent = `${player}: ${damage} урона`;
        damageList.appendChild(listItem);
    });
}

function hitWorldBoss(playerName, damage) {
    if (worldBossHealth <= 0) return; // Проверка, чтобы не засчитывать урон после смерти босса

    if (!playersDamage[playerName]) {
        playersDamage[playerName] = 0;
    }
    playersDamage[playerName] += damage;
    worldBossHealth -= damage;
    if (worldBossHealth < 0) worldBossHealth = 0;
    updateWorldBossHealthDisplay();
    updateDamageList();
    syncWorldBossHealth();
    syncPlayersDamage();

    if (worldBossHealth <= 0) {
        // Вызов функции отправки наград при смерти босса
        sendRewards();
    }
}



function updateWorldBossHealthDisplay() {
    //console.log(`Updating World Boss Health Display: ${worldBossHealth}`);
    document.getElementById('worldBossHealthValue').textContent = worldBossHealth;
}

function startBossBattle() {
    changeScreen('worldBoss');
    startUpdating(); // Убедитесь, что обновление запущено
}

function changeScreen(screen) {
    console.log(`Changing screen to: ${screen}`);
    currentScreen = screen;
    document.getElementById('shopMenu').style.display = 'none';
    document.getElementById('statusBar').style.display = 'none';
    document.getElementById('monsterHealthDisplay').style.display = (screen === 'dungeon') ? 'block' : 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mailButton').style.display = (screen === 'castle') ? 'block' : 'none';
    crosshair.style.display = (screen === 'battle' || screen === 'worldBoss') ? 'block' : 'none';
    document.getElementById('rebornButton').style.display = (screen === 'dungeon') ? 'block' : 'none'; // Отображаем кнопку только на экране "battle"
    // Hide the monster health bar when changing screens
    if (screen !== 'dungeon' && screen !== 'battle') {
        document.getElementById('monsterHealthContainer').style.display = 'none';
    }
    if (screen === 'worldBoss') {
        document.getElementById('worldBossScreen').style.display = 'block';
        document.getElementById('statusBar').style.display = 'block';
        updateStatusBar();
        drawWorldBossBattle();
    } else {
        document.getElementById('worldBossScreen').style.display = 'none';
    }

    if (screen === 'raid') {
        drawMenu();
    } else if (screen === 'dungeon') {
        showHealthBar(); // Показать полоску здоровья на экране dungeon
        drawDungeonEntrance();
        document.getElementById('statusBar').style.display = 'block';
        updateStatusBar();
    } else if (screen === 'arena') {
        arena();
    } else if (screen === 'castle') {
        drawCastle();
    } else if (screen === 'shop') {
        drawShop();
    } else if (screen === 'battle') {
        loadProgress(nickname).then(data => {
            console.log('Data after loading progress:', data);
            if (data) {
                currentLevel = data.currentLevel;
                gold = data.gold;
                playerHealth = data.playerHealth;
                weaponPower = data.weaponPower;
                weaponName = data.weaponName;
                weaponLevel = data.weaponLevel;
                levels = data.levels || levels;
                updateCharacterMenu();
            }
            document.getElementById('statusBar').style.display = 'block';
            updateStatusBar();
            startLevel(currentLevel); // Инициализация уровня перед отрисовкой боя
        });
    } else if (screen === 'levels') {
        drawLevelsScreen();
    }
}

window.changeScreen = changeScreen;




function syncWorldBossHealth() {
    set(ref(database, 'worldBoss/health'), worldBossHealth);
}

function syncPlayersDamage() {
    set(ref(database, 'worldBoss/playersDamage'), playersDamage);
}

function loadWorldBossData() {
    const dbRef = ref(database);
    return get(child(dbRef, 'worldBoss')).then((snapshot) => {
        if (snapshot.exists()) {
            const data = snapshot.val();
            worldBossHealth = data.health;
            playersDamage = data.playersDamage || {};
            //console.log(`Loaded World Boss Health: ${worldBossHealth}`);
            updateWorldBossHealthDisplay();
            updateDamageList();
        } else {
            console.log("No data available for world boss");
        }
    }).catch((error) => {
        console.error(error);
    });
}
       


function updateCharacterMenu() {
    playerHealth = calculateTotalHealth(); // Обновление текущего здоровья игрока
    document.getElementById('weapon').textContent = weaponName;
    document.getElementById('health').textContent = playerHealth;
    document.getElementById('damage').textContent = calculateTotalDamage();
    document.getElementById('gold').textContent = gold;
    document.getElementById('level').textContent = currentLevel;

    // Смена изображения персонажа при достижении уровня выше 10
    updateCharacterImage(); // Вызов функции для смены изображения

    updateStatusBar(); // Обновление статус бара
}
window.updateCharacterMenu = updateCharacterMenu;


function calculateTotalDamage() {
    let totalDamage = 0;
    for (const hero of heroes) {
        if (hero.hired) {
            totalDamage += hero.damage;
        }
    }

    return totalDamage;
}
window.calculateTotalDamage = calculateTotalDamage;

function calculateTotalHealth() {
    let totalHealth = 100; // базовое здоровье

    return totalHealth;
}
window.calculateTotalHealth = calculateTotalHealth;

let localGoldUpdated = false;

function updateStatusBar() {
    //console.log('updateStatusBar called'); // Логирование вызова функции

    if (!localGoldUpdated) {
        const playerGoldRef = ref(database, `players/${nickname}/gold`);
        get(playerGoldRef).then((snapshot) => {
            const goldAmount = snapshot.val() || 0;
           // console.log(`Gold amount retrieved from database: ${goldAmount}`); // Логирование полученного значения из базы данных

            document.getElementById('statusGold').textContent = goldAmount;
            gold = goldAmount; // Обновляем глобальную переменную золота
          //  console.log(`Global gold variable updated: ${gold}`); // Логирование обновленного значения глобальной переменной

        }).catch((error) => {
            console.error('Error getting gold:', error);
        });
    } else {
        localGoldUpdated = false; // Сбрасываем флаг после использования
    }

    document.getElementById('statusLevel').textContent = currentLevel;
    document.getElementById('playerHealthBar').style.width = playerHealth + '%'; // Обновление ширины полосы здоровья
    document.getElementById('statusDamage').textContent = calculateTotalDamage(); // Обновление значения урона

    //console.log('Status bar updated'); // Логирование обновления статус бара
}
window.updateStatusBar = updateStatusBar;














        function toggleTopPlayers() {
    const menu = document.getElementById('topPlayersMenu');
    if (menu.style.display === 'block') {
        menu.style.display = 'none';
    } else {
        displayTopPlayers().then(topPlayers => {
            let topListHTML = '<h2>Топ игроки</h2>';
            // Преобразование объекта в массив и сортировка по уровню
            const sortedPlayers = Object.values(topPlayers).sort((a, b) => b.level - a.level);
            sortedPlayers.forEach(player => {
                topListHTML += `<p>${player.nickname} - Уровень ${player.level}</p>`;
            });
            document.getElementById('topPlayersMenu').innerHTML = topListHTML;
            menu.style.display = 'block';
        });
    }
}


        window.toggleTopPlayers = toggleTopPlayers;



        canvas.addEventListener('click', function(event) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    if (currentScreen === 'menu') {
        currentScreen = 'dungeon';
        drawDungeonEntrance();
    } else if (currentScreen === 'dungeon') {
        const gateCenterX = canvas.width / 2;
        const gateCenterY = canvas.height / 2;
        if (mouseX > gateCenterX - dungeonGateImage.width / 2 &&
            mouseX < gateCenterX + dungeonGateImage.width / 2 &&
            mouseY > gateCenterY - dungeonGateImage.height / 2) {
            currentScreen = 'battle';
            drawBattle();
            crosshair.style.display = 'block';
        } else {
            levels.forEach((level, index) => {
                const { x, y } = getLevelPosition(index);
                const radius = 25;

                if (Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2) < radius) {
                    if (levels[index].completed || index === currentLevel - 1) {
                        startLevel(level.number);
                    }
                }
            });
        }
    } else if (currentScreen === 'battle') {
        hitMonster(event);
    } else if (currentScreen === 'worldBoss') {
        console.log('Click detected on World Boss screen.');
        hitWorldBoss(nickname, calculateTotalDamage());
        syncWorldBossHealth();
        syncPlayersDamage();
    }
});


       
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            if (currentScreen === 'menu') {
                drawMenu();
            } else if (currentScreen === 'dungeon') {
                drawDungeonEntrance();
            } else if (currentScreen === 'battle') {
                drawBattle();
            } else if (currentScreen === 'levelMap') {
                drawLevelMap();
            } else if (currentScreen === 'victory') {
                drawVictoryScreen();
            } else if (currentScreen === 'shop') {
                drawShop();
            }
        }

        window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (currentScreen === 'battle') {
        drawBattle(); // Перерисовка экрана боя
    } else if (currentScreen === 'arena') {
        drawArena(); // Перерисовка арены
    } else if (currentScreen === 'menu') {
        drawMenu(); // Перерисовка меню
    } else if (currentScreen === 'dungeon') {
        drawDungeonEntrance(); // Перерисовка подземелья
    } else if (currentScreen === 'worldBoss') {
        drawWorldBossBattle(); // Перерисовка боя с мировым боссом
    }
});



        gameLoop();


        window.onload = function() {
            console.log("Page loaded, initializing game.");
            addHeroesToMenu();
    loadWorldBossData();
    gameLoop();
    changeScreen('menu'); // Начальный экран
    startUpdating(); // Запуск обновления при старте игры
    startHourlyReset(); // Запуск таймера для сброса здоровья босса
    updateMonsterHealthDisplay();
    
}

    </script>
</body>
</html>