<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Средневековое Подземелье</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background: url('background.png') no-repeat center center fixed;
    background-size: cover;
}

        canvas {
            display: block;
            background: #000;
        }
        .crosshair {
            position: absolute;
            width: 60px;
            height: 60px;
            background: url('crosshair.png') no-repeat center;
            background-size: contain;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-in-out;
            display: none;
        }
        #bottomMenu {
            position: fixed;
            bottom: 0;
            left: 16vw;
            width: 100%;
            height: 8vh;
            background: #333;
            color: white;
            display: flex;
            justify-content: flex-start;  /*  Изменено  justify-content  */ 
            align-items: center;
            font-size: 1.5vw;
            
        }
        #bottomMenu div {
  background: url('stone_texture.png'); /* Текстура камня */
  border: 3px outset #b38f66; /* "Выпуклая" обводка под бронзу */
  color: #f0f0f0;
  padding: 0.5vh 1vw;
  font-family: 'Cinzel', serif; /* Фэнтезийный шрифт */
  font-size: 20px; 
  margin: 0 1vw; /* Отступы между кнопками */
  cursor: pointer;
  text-shadow: 2px 2px 3px black;
  transition: all 0.3s ease;
  display: flex;            /* Используем Flexbox для центрирования */
  align-items: center;      /* Вертикальное центрирование */
  justify-content: center;  /* Горизонтальное центрирование */
  text-align: center;       /* Дополнительное центрирование текста */
  min-width: 10vw; /*  Минимальная  ширина  кнопки  */
  /* max-width: 5vw; */
}

#bottomMenu div:hover {
  transform: scale(1.1);
  border-color: gold; /* Золотая обводка при наведении */
  box-shadow: 0 0 15px gold; /* Золотое свечение при наведении */
}

#bottomMenu div:active {
  transform: scale(0.95); /* Эффект нажатия */
  box-shadow: inset 0 0 10px black; /* Эффект вдавленной кнопки */
}

#bottomMenu div:nth-child(1)::before { /* Иконка для арены */
  content: "";
  background: url('sword_icon.png') no-repeat center;
  background-size: contain;
  width: 24px;
  height: 24px;
  display: inline-block;
  margin-right: 10px;
  vertical-align: middle;
}

#bottomMenu div:nth-child(2)::before { /* Иконка для подземелья */
  content: "";
  background: url('skull_icon.png') no-repeat center;
  background-size: contain;
  width: 24px;
  height: 24px;
  display: inline-block;
  margin-right: 10px;
  vertical-align: middle;
}

#bottomMenu div:nth-child(3)::before { /* Иконка для рейда */
  content: "";
  background: url('flag_icon.png') no-repeat center;
  background-size: contain;
  width: 24px;
  height: 24px;
  display: inline-block;
  margin-right: 10px;
  vertical-align: middle;
}
        #characterMenu {
    position: fixed;
    top: 0px;
    right: 0px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    display: block; 
    font-size: 1.2vw;
    text-align: center;
    width: 15vw;
    height: 53vh;
    /* overflow: auto;  */
}
#characterMenu img { 
    width: 100%; 
  height: 100%; 
  object-fit: cover; 
}

#leftCharacterMenu {
        position: fixed;
        top: 0px;
        left: 0px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        display: block;
        font-size: 1.2vw;
        text-align: center;
        width: 15vw;
        max-height: calc(100vh - 20px);
        overflow: auto;
        display: none; /* Скрываем по умолчанию */
    }
    #leftCharacterMenu::-webkit-scrollbar {
    width: 15px; /* Ширина  полосы  прокрутки */ 
} 

#leftCharacterMenu::-webkit-scrollbar-track {
    background: rgba(0, 0,  0,  0.5); /* Цвет  фона */
}

#leftCharacterMenu::-webkit-scrollbar-thumb {
    background: #ff4b2b;  /* Цвет  ползунка */ 
    border-radius: 5px;  /* Радиус  скругления  ползунка */ 
}

#leftCharacterMenu::-webkit-scrollbar-thumb:hover  { 
    background: #ff416c; /* Цвет  ползунка  при наведении */
}
        /* Добавляем стили для новой кнопки */
        #fullscreenButton {
            position: fixed;
            bottom: 60px;
            right: 0px;
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 0.8vw;
            z-index: 1000;
        }



        /* #shopMenu {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        #shopItems {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .shop-item {
            margin: 10px;
            text-align: center;
            cursor: pointer;
        }
        .shop-item img {
            width: 100px;
            height: 100px;
            border-radius: 10px;
            transition: transform 0.3s;
        }
        .shop-item img:hover {
            transform: scale(1.1);
        }
        #itemDetail {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #itemDetail img {
            max-width: 100%;
            max-height: 80vh;
        }
        #itemDetail button {
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        } */
        .status-bar {
            position: fixed;
            top: 10px;
            left: 16.5vw;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 1.2vw;
        }
        .status-bar p {
            margin: 8px 0;
            font-size: 18px; /* Установите желаемый размер шрифта */
        }
        .health-bar {
            background: #555;
            border-radius: 5px;
            overflow: hidden;
            width: 200px;
            height: 20px;
            margin-bottom: 10px;
        }
        .health-bar-inner {
            height: 100%;
            background: #0f0;
        }
        .monster-health-bar-inner {
            height: 100%;
            background: #f00; /* Red for monster health */
        }
        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
            z-index: 2001;
        }
        .hero { 
    /* ...  другие стили  */ 
    opacity: 1; 
}

        .hero img {
        width: 175px;
        height: 242px;
        border-radius: 10px;
        transition: filter 0.3s;
    }

    .hero.not-hired img {
        filter: brightness(10%);
    }

    .hero.hired img {
        filter: brightness(100%);
    }
        #characterImage {
            width: 250px;
            height: 420px;
        }
        #nicknameMenu {
            display: block;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #topPlayersMenu {
            display: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #gameVersion {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
        }
        #continuePrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }
        #continuePrompt button {
            margin: 5px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }

        .monster-message {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 16px;
            display: none;
        }
        #weaponInfo, #healthInfo {
            display: none; /* Скрываем элементы оружия и здоровья */
        }

        #mailButton {
            position: fixed;
            top: 190px;
            left: 300px;
            width: 150px;
            height: 150px;
            background: url('mail.png') no-repeat center;
            background-size: cover;
            cursor: pointer;
            transition: transform 0.3s;
            display: none; /* Скрыта по умолчанию */
        }
        #mailButton:hover {
            transform: scale(1.1);
        }
        #mailWindow {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 400px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
        }
        #rebornButton {
    position: fixed;
    top: 0px; /* Отступ сверху */
    right: calc(21px + 250px); /* Отступ справа от экрана с учетом ширины #characterMenu */
    width: 150px;
    height: 150px;
    background: url('reborn.png') no-repeat center;
    background-size: contain;
    cursor: pointer;
    z-index: 1000;
    transition: transform 0.3s, box-shadow 0.3s;
}
#rebornButton:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 255, 0, 0.8); /* Добавьте красивую тень */
}
#rebornPrompt {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    z-index: 2000;
}

#rebornPrompt button {
    margin: 10px;
    padding: 10px;
    background: #fff;
    border: none;
    cursor: pointer;
}
#monsterHealthContainer {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 30%; /* Ширина контейнера */
    height: 50px; /* Высота контейнера */
    background-color: rgba(255, 0, 0, 0.2); /* Полупрозрачный фон для контейнера */
    border-radius: 15px;
    overflow: hidden; /* Обрезка содержимого */
    display: none; /* Скрыть по умолчанию */
}

#monsterHealthBar {
    height: 100%; /* Высота полоски равна высоте контейнера */
    background-color: green; /* Цвет полоски */
    border-radius: 15px; /* Округленные углы */
    transition: width 0.5s; /* Плавный переход ширины */
}

#monsterHealthValue {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-size: 2.4vw;
    line-height: 50px; /* Высота строки совпадает с высотой контейнера */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Тень для текста */
    font-weight: bold; /* Жирный текст */
    padding: 0 10px; /* Отступы по бокам */
    border: 2px solid rgba(0, 0, 0, 0.5); /* Обводка вокруг текста */
    border-radius: 5px; /* Скругленные углы */
    background-color: rgba(0, 0, 0, 0.3); /* Полупрозрачный фон */
}

#chatContainer {
    position: fixed;
    bottom: 8vh;
    left: 16vw;
    width: 300px;
    max-height: 400px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    border-radius: 5px;
    overflow: auto;
    display: flex;
    flex-direction: column;
    padding: 10px;
    display: none; /* Скрыть по умолчанию */
}
#chatContainer button {
  background-color: rgba(0, 0, 0, 0.8); /* Полупрозрачный фон */
  border: 2px solid white; /* Белая обводка */
  color: white; 
  padding: 8px 16px; 
  font-size: 1.2vw;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s; /* Переходы для эффекта наведения */
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Тень для текста */
}

#chatContainer button:hover {
  transform: scale(1.05); /* Легкое увеличение при наведении */
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); /* Светлая тень при наведении */
}
#chatMessages {
    flex-grow: 1;
    overflow-y: auto;
}

#chatInput {
    display: flex;
    margin-top: 10px;
}

#chatInput input {
    flex-grow: 1;
    padding: 5px;
    border: none;
    border-radius: 3px;
}

#chatInput button {
    margin-left: 5px;
    padding: 5px 10px;
    border: none;
    border-radius: 3px;
    background-color: #333;
    color: white;
    cursor: pointer;
}
/* Основные стили кнопок */
button.upgrade-button, button.hire-button {
    background: linear-gradient(to right, #ff416c, #ff4b2b); /* Градиентный фон */
    border: none;
    border-radius: 10px; /* Скругленные углы */
    color: white;
    cursor: pointer;
    font-size: 18px; /* Увеличенный размер шрифта */
    padding: 10px 20px;
    transition: background 0.3s ease; /* Добавьте плавный переход для background */ 
    box-shadow: 0 4px 15px rgba(255, 75, 43, 0.4); /* Тень для кнопок */
}

/* Эффект наведения на кнопку */
button.upgrade-button:hover, button.hire-button:hover {
    transform: scale(1.05); /* Легкое увеличение кнопки */
    box-shadow: 0 6px 20px rgba(255, 75, 43, 0.6); /* Более яркая тень при наведении */
}
#toggleAutoboyButton {
    position: fixed;
    bottom: 100px; /* Расположение кнопки над кнопкой "Полноэкранный режим" */
    right: 0px;
    padding: 10px 20px;
    background: #333;
    color: white;
    border: none;
    cursor: pointer;
    font-size: 1.2vw;
    z-index: 1000;
    display: none; /* Скрываем по умолчанию */
}
#pvpButton {
            position: fixed;
            bottom: 210px;
            left: 790px;
            width: 200px;
            height: 200px;
            background: url('Sworddouble.png') no-repeat center;
            background-size: contain;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            display: none; /* Скрываем по умолчанию */
        }

        #pvpButton:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
        }
        
        /* Стиль для окна регистрации на PvP */
        #pvpRegistration {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
        }

        #pvpRegistration button {
            margin: 10px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }
        #pvpBattle {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
        }
        #pvpBattle button {
            margin: 10px;
            padding: 10px;
            background: #fff;
            border: none;
            cursor: pointer;
        }
        #clanListMenu, #clanMenu {
  display: none; 
  position: fixed; 
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 5px; 
  z-index: 1001; /* Убедитесь, что меню выше других элементов */
}

#clanDonateMenu {
  display: none;
  position: fixed;
  top: 25%;
  left: 50%;
  transform: translate(-50%, -50%); 
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 5px;
  z-index: 1003;
}
#rebornMenu  {
  display:  none; 
  position:  fixed; 
  top:  50%;
  left:  50%;
  transform:  translate(-50%,  -50%); 
  background:  rgba(0,  0,  0,  0.8);
  color:  white; 
  padding:  20px;
  border-radius:  5px;
  z-index:  1001;  
}
#errorMessage {
    display: none;
    position: fixed; 
    top: 50%; 
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8); 
    color: white;
    padding: 20px; 
    border-radius: 5px;
    z-index: 1001; 
}
#rebornSuccessMessage  {
    /*  Используйте  те  же  стили,  что  и  для  rebornMenu  и  errorMessage */
    display: none; 
    position: fixed; 
    top: 50%;
    left: 50%; 
    transform: translate(-50%,  -50%);
    background: rgba(0, 0, 0, 0.8); 
    color: white; 
    padding: 20px;
    border-radius: 5px;
    z-index: 1001;
}
#gameMessage  {
  display:  none;
  position:  fixed;
  top:  50%; 
  left:  50%;
  transform:  translate(-50%,  -50%); 
  background:  rgba(0,  0,  0,  0.8);
  color:  rgb(240, 9, 9);
  padding:  20px; 
  border-radius:  5px; 
  z-index:  9999; 
  text-align:  center; /*  Центрируем  текст */ 
  font-weight:  bold; /*  Делаем  текст  жирным  */
}
#arenaScreen  {
    display:  none;
    position:  fixed;
    top:  50%;
    left:  50%;
    transform:  translate(-50%,  -50%);
    background:  rgba(0,  0,  0,  0.8); 
    color:  white; 
    padding:  20px; 
    border-radius:  5px; 
    z-index:  1001;
    text-align: center;
} 
#pvpLastBattles {
  list-style-type: none;
  padding: 0;
  position: fixed;
  top: 10%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 3002;
  font-size: 18px;
}

#pvpLastBattles li {
  margin-bottom: 5px;
  text-align: left;
  color: white; 
  text-shadow: 
    -1px -1px 0 #000, 
    1px -1px 0 #000,
    -1px 1px 0 #000,
    1px 1px 0 #000;  /*  Черная  обводка */
}

/*  Цветные  обводки  для  каждой  битвы  */ 
#pvpLastBattles  li:nth-child(1) {
  text-shadow: 
    -1px -1px 0 red, 
    1px -1px 0 red, 
    -1px 1px 0 red,
    1px 1px 0 red;
}

#pvpLastBattles  li:nth-child(2)  { 
  text-shadow:
    -1px -1px 0  blue,
    1px  -1px 0  blue, 
    -1px 1px  0  blue,
    1px 1px  0  blue;
}

#pvpLastBattles  li:nth-child(3)  {
  text-shadow: 
    -1px -1px 0  green, 
    1px  -1px 0  green, 
    -1px 1px 0  green,
    1px 1px  0  green;
}

#dailyQuestsMenu {
    display: none;
    position:  fixed;
    top: 50%;
    left: 50%; 
    transform:  translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8); 
    color: white; 
    padding:  20px;
    border-radius: 5px;
    z-index: 1001;
    text-align:  center; 
    font-size:  16px;  /*  Уменьшаем размер шрифта  */ 
}

#dailyQuestsList {
    list-style-type:  none;  
    padding: 0;
    text-align:  left;  
    max-height:  300px; /*   Ограничиваем высоту  списка */ 
    overflow-y:  auto;  /*  Добавляем полосу прокрутки */ 
}

#dailyQuestsList  li {
    margin-bottom: 5px; 
    /*  Добавляем фон  и  рамку  для  лучшей  читаемости */ 
    background-color: rgba(0, 0, 0, 0.5);  
    border: 1px solid white;  
    padding:  8px;  /*  Добавляем  отступы  */
}

#dailyQuestResetTime {
    margin-top: 10px; 
    font-size: 14px;
    text-align:  center;  
}
#dailyQuestsButton {
    position: fixed; /* Фиксированное положение относительно окна браузера */
    top: calc(53vh + 20px); /* 40vh (высота #characterMenu) + 10px (отступ) */
    right: 1px; /* Совпадает с правым отступом #characterMenu */
    cursor: pointer;
}
    
#dailyQuestsButton img  {
    width: 100%;
    height: 100%;
}
.daily-quests-text {
    display: inline-block;
    padding: 0.8vh 1.6vw;
    background-color: rgba(0, 0, 0, 0.8); /* Полупрозрачный фон */
    color: white; /* Цвет текста */
    font-size: 1.2vw;
    font-weight: bold; /* Жирный текст */
    border: 2px solid white; /* Белая рамка */
    border-radius: 10px; /* Скругленные углы */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Тень для текста */
    cursor: pointer; /* Курсор указателя */
    transition: transform 0.3s, box-shadow 0.3s; /* Переходы для эффекта наведения */
}

.daily-quests-text:hover {
    transform: scale(1.05); /* Легкое увеличение при наведении */
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); /* Светлая тень при наведении */
}

/* В styles.css или внутри <style> в index.html */

    .rare-monster-health-bar-inner {
  height: 100%;
  background: purple; /* Фиолетовый цвет для полоски здоровья редкого монстра */
}

#rareMonsterTimer {
  position: absolute;
  top: 80px; /* Под полоской здоровья монстра */
  left: 50%;
  transform: translateX(-50%);
  font-size: 24px;
  color: red; 
  display: none; /* Скрываем по умолчанию */
}
#worldBossTimer {
  position: fixed;
  top: 10px;  
  left: 50%; 
  transform: translateX(-50%); 
  z-index:  9001;
}
.hero button {
  display: block;  /*  Заставляет  каждую кнопку занимать всю ширину */ 
  width: 100%;     /*  Убедитесь,  что  кнопки занимают 100%  ширины контейнера */ 
  margin-bottom:  5px;  /*  Добавляем отступ между  кнопками */ 
}

button.skill-button  { 
    background: linear-gradient(to  right,  #00c6ff, #0072ff); /*  Сине-голубой  градиент  */ 
    border:  none; 
    border-radius: 8px;  /*  Скругленные  углы */ 
    color:  white; 
    cursor:  pointer; 
    font-size:  14px; /*  Немного  меньший размер шрифта */
    font-weight: bold; /*  Жирный  шрифт */ 
    padding: 8px  16px; 
    transition:  transform  0.2s,  box-shadow 0.2s,  opacity  0.3s  ease; /*  ДОБАВЛЕНО  opacity */
    box-shadow:  0  3px  12px rgba(0,  198,  255, 0.5); /*  Тень синего цвета */ 
    position:  relative;  /*  Для позиционирования индикатора  cooldown */ 
    opacity: 1!important;
    
}

/* Эффект  наведения  на кнопку */ 
button.skill-button:hover { 
    transform: scale(1.05); /*  Легкое  увеличение  кнопки */ 
    box-shadow:  0  5px  18px rgba(0, 198, 255, 0.7);  /* Более  яркая тень  при наведении */
}

/*  Индикатор cooldown */
button.skill-button::before {
    content: '';
    position: absolute;
    top: 0;
    left:  0; 
    width: 100%;
    height: 100%;
    background-color:  rgba(0,  0,  0,  0.7); /*  Темно-серый  индикатор */ 
    border-radius: 8px;  
    z-index:  1; /*  Поверх  кнопки */ 
    opacity:  0!important; /*  Изначально  скрываем  с  помощью  opacity  */
    transform:  none;  /*  Убираем  transform  */ 
    transition: opacity  0.3s  ease!important; /*  Анимируем  opacity  */ 
    
}

button.skill-button[disabled]::before  {
    opacity:  1!important;  /* Показываем  с помощью  opacity  */ 
}

#skillBook { 
    position: fixed; 
    bottom: 8vh;  
    left:  41vw;  
    background:  rgba(0,  0,  0,  0.8); 
    color:  white;  
    padding:  10px;  
    border-radius:  5px;  
    z-index: 1001;
}
#skillButtonsContainer { 
    display:  flex; 
    flex-wrap:  wrap;
}

#skillButtonsContainer img.skill-button  { 
    width: 64px;  /*  Примерный  размер  */  
    height: 64px;  
    margin: 5px;  
    cursor:  pointer;  
    border-radius: 5px;
    opacity: 1; 
    transition: opacity 0.3s ease;
    position:  relative;  /*  ДОБАВЛЕНО  */
} 

#skillButtonsContainer  img.skill-button[disabled] { 
    opacity: 0.5;
    cursor:  default; 
}

#skillButtonsContainer  img.skill-button:hover  { 
    transform:  scale(1.1);  
} 
.onCooldown {
    opacity: 0.3!important; /*  Затемняем кнопку  */ 
    animation: cooldown 5s linear forwards; /* Анимация перезарядки */
}

.onCooldown::before, 
#skillButtonsContainer img.onCooldown::before  { 
    content:  '';  
    position: absolute; 
    top:  0;
    left:  0;  
    width: 100%;  
    height: 100%;  
    background-color: rgba(0, 0, 0,  0.7); /*  Серый полупрозрачный  фон  */ 
    border-radius:  8px; /*  Соответствует border-radius кнопки  */
    z-index:  9999; /*  Увеличиваем  z-index  */
    opacity: 1;  /*  Показываем  индикатор cooldown  */
    transition: opacity 0.3s ease;  /*  Анимируем opacity  */
}
#talentsButton {
    position: fixed; /* Фиксированное положение относительно окна браузера */
    top: calc(53vh + 20px + 6vh );
    right: 1px; /* Совпадает с правым отступом #characterMenu */
    cursor: pointer;
}
#talentsMenu {
  display: none;
  position: fixed; 
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8); 
  color: white;
  padding: 20px; 
  border-radius: 5px; 
  z-index: 2001; 
}
 .close-btn  
{
  position: absolute;
  top: 10px;
  right: 10px;
  background: none; /* Убираем фон */
  border: none;
  padding: 5px; /*  Настройте отступ, если нужно */
  cursor: pointer;
}
.close-btn img {
  width: 2vw; /*  Настройте размер изображения */
  height: auto;
}
.close-btn:hover {
  transform: scale(1.3); /* Увеличение при наведении */
}

.close-btn:active {
  transform: scale(0.95); /* Уменьшение при нажатии */
}

.talent {
  margin-bottom: 15px;
  border: 2px solid white; 
  padding: 10px; 
  border-radius: 5px;
}

.talent h3 {
  margin-top: 0;
}
.flash {
  animation: flash 0.2s linear;
}

@keyframes flash {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

/* Медиазапросы для мобильной версии */
@media (max-width: 768px) {
          
            #fullscreenButton {
            position: fixed;
            bottom: 60px;
            right: 0px;
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
            transform: scale(0.5); /* Уменьшить масштаб до 30% */
        }
    #bottomMenu {
        left: 0;
        width: 100%;
        flex-direction: column;
        height: auto;
        font-size: 20px;
    }
    #leftCharacterMenu {
        position: fixed;
        top: 0px;
        left: 0px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        display: block;
        font-size: 16px;
        text-align: center;
        max-width: calc(100vw - 20px);
        height: 100vh; /* Установить высоту 100% высоты экрана */
        max-height: 100vh; /* Максимальная высота 100% высоты экрана */
        overflow: auto;
        display: none; /* Скрываем по умолчанию */
        transform: scale(0.6); /* Уменьшить масштаб до 30% */
        transform-origin: top left; /* Указать точку начала масштабирования */
        opacity:  1;
    }
    .health-bar {
        display: none; /* Скрываем по умолчанию */
        }
        .health-bar-inner {
            display: none; /* Скрываем по умолчанию */
        }
    #characterMenu {
        right: 0;
        top: 0;
        width: 100%;
        height: auto;
        font-size: 14px;
        transform: scale(0.35); /* Уменьшить масштаб до 30% */
        transform-origin: top right; /* Указать точку начала масштабирования */
    }

    .status-bar {
        left: 30%;
        top: 80px;
        right: 0;
        width: 20%;
        font-size: 14px;
    }
    #dailyQuestsMenu {
    display: none;
    position:  fixed;
    top: 50%;
    left: 50%; 
    transform:  translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8); 
    color: white; 
    padding:  20px;
    border-radius: 5px;
    z-index: 1001;
    text-align:  center; 
    font-size:  16px;  /*  Уменьшаем размер шрифта  */ 
    transform: scale(0.8); /* Уменьшить масштаб до 30% */
  
}
.daily-quests-text {
    display: inline-block;
    padding: 10px 20px;
    background-color: rgba(0, 0, 0, 0.8); /* Полупрозрачный фон */
    color: white; /* Цвет текста */
    font-size: 18px; /* Размер шрифта */
    font-weight: bold; /* Жирный текст */
    border: 2px solid white; /* Белая рамка */
    border-radius: 10px; /* Скругленные углы */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Тень для текста */
    cursor: pointer; /* Курсор указателя */
    transition: transform 0.3s, box-shadow 0.3s; /* Переходы для эффекта наведения */
    transform: scale(0.7); /* Уменьшить масштаб до 30% */
}

.daily-quests-text:hover {
    transform: scale(1.05); /* Легкое увеличение при наведении */
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.8); /* Светлая тень при наведении */
    transform: scale(0.7); /* Уменьшить масштаб до 30% */
}
    /* Дополнительные изменения для мобильной версии */
    .crosshair {
        width: 40px;
        height: 40px;
    }

    #mailButton {
        width: 100px;
        height: 100px;
    }

    #rebornButton {
        width: 60px;
        height: 60px;
        right: 10px;
    }

    #monsterHealthContainer {
        width: 40%;
    }

    #chatContainer {
        width: 100%;
        left: 0;
        top: 59%;
        max-height: 14vh; /* Максимальная высота 100% высоты экрана */
    }
    #chatMessages {
    flex-grow: 1;
    overflow-y: auto;
    }

    #clanListMenu, #clanMenu {
  display: none; 
  position: fixed; 
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 5px; 
  z-index: 1001; /* Убедитесь, что меню выше других элементов */
  transform: scale(0.6); /* Уменьшить масштаб до 30% */
}
}
    </style>
</head>
<body>
    <div id="talentsMenu">
        <h2>Древние Знания</h2>
        <button class="close-btn" onclick="closeTalentsMenu()">
            <img src="close_button_image.png" alt="Закрыть">
          </button>
        <div id="talentsContainer"></div> 
        <p>Эссенция Хаоса: <span id="talentsChaosEssence"></span></p> 
        
    </div>

    <div id="skillBook"> 
        <h3>Книга  скиллов</h3> 
        <div id="skillButtonsContainer"></div> 
    </div>

    <div id="rareMonsterTimer"></div>

    <div id="dailyQuestsMenu" style="display: none;">
        <h2>Ежедневные задания</h2>
        <button class="close-btn" onclick="closeDailyQuestsMenu()">
            <img src="close_button_image.png" alt="Закрыть">
          </button>
    
        <!--  Кнопки  для  переключения  категорий -->
        <div  id="dailyQuestCategories">
            <!--  Кнопки будут  динамически  добавлены сюда  --> 
        </div>
    
        <ul  id="dailyQuestsList"></ul> 
       
    </div>

<!-- Кнопка  для ежедневных  заданий --> 
<div id="dailyQuestsButton" onclick="openDailyQuestsMenu()"> 
    <span class="daily-quests-text">Ежедневные задания</span>
</div>
<div id="talentsButton" onclick="openTalentsMenu()"> 
    <span class="daily-quests-text">Древние Знания</span> 
</div>

    <div  id="gameMessage"  style="display:  none;">
        <p  id="gameMessageText"></p>
    </div>
    <div id="arenaScreen" style="display:none;">
        <h3>Последние PvP-битвы</h3> 
    </div>
    
    <ul  id="pvpLastBattles"></ul>  <!--  Перемещаем  список  сюда -->
    <div id="clanDonateMenu" style="display: none;"> 
        <h3>Пожертвование в клан</h3>
        <p>Требуется: <span id="clanUpgradeCost"></span> золота</p> 
        <p>Собрано: <span id="clanCurrentDonations"></span> золота</p> 
        <input type="number" id="clanDonateAmount" placeholder="Введите сумму" min="1">
        <button onclick="donateToClan()">Пожертвовать</button> 
        <button class="close-btn" onclick="closeClanDonateMenu()">
            <img src="close_button_image.png" alt="Закрыть">
          </button>
        <!-- <button onclick="closeClanDonateMenu()">Закрыть</button>  -->
    </div>

    <div id="clanMenu">
        <h2><span id="clanName"></span> (<span id="clanLevel"></span> уровень)</h2>
        <p>Лидер: <span id="clanLeader"></span></p>
        <ul id="clanMembers"></ul>
        <button onclick="leaveClan()">Покинуть клан</button>
        <button onclick="upgradeClan()">Улучшить клан</button>
        <button class="close-btn" onclick="closeClanMenu()">
            <img src="close_button_image.png" alt="Закрыть">
          </button>
        <button onclick="openClanDonateMenu()">Пожертвовать</button> 
        <!-- <button onclick="closeClanMenu()">Закрыть</button> -->
    </div>

    <div id="rebornMenu" style="display:  none;">
        <h2>Перерождение</h2> 
        <p id="rebornMessage"></p>
        <button onclick="confirmReborn()">Переродиться</button>
        <button onclick="closeRebornMenu()">Отмена</button>
    </div>

    <button id="fullscreenButton" onclick="toggleFullscreen()">Полноэкранный режим</button>
    <button id="toggleAutoboyButton" onclick="toggleAutoboy()">Отключить автобой</button>
    <div id="pvpButton" onclick="openPvpRegistration()"></div>
    <div id="nicknameMenu">
        <h2>Введите свой никнейм</h2>
        <input type="text" id="nicknameInput" placeholder="Ваш никнейм">
        <button id="startGameButton" onclick="startGame()">Начать игру</button> 
        <div id="gameVersion">Версия игры: 1.15</div>
    </div>
    <canvas id="gameCanvas" style="display:none;"></canvas>
    <div id="bottomMenu" style="display:none;">
        <div onclick="changeScreen('arena')">Арена</div>
        <div onclick="changeScreen('dungeon')">Подземелье</div>
        <div onclick="changeScreen('raid')">Рейд</div>
        <div onclick="changeScreen('castle')">Замок</div>
        <div onclick="openClanListMenu()">Кланы</div>
        <div onclick="changeScreen('worldBoss')">Мировой Босс</div>
        <!-- <div onclick="toggleShop()">Магазин</div> -->
        <!-- <div onclick="toggleTopPlayers()">Топ игроки</div> -->
       
    </div>

    <div id="chatContainer"> 
        <button onclick="switchChat('global')">Глобальный чат</button>
        <button onclick="switchChat('clan')">Клановый чат</button> 
        <div id="chatMessages"></div> 
        <div id="chatInput">
            <input type="text" id="chatMessageInput" placeholder="Введите сообщение...">
            <button onclick="sendMessage()">Отправить</button>
        </div>
    </div>

    <div id="pvpRegistration">
        <h2>Хотите зарегистрироваться на бой PvP?</h2>
        <button>Да</button> <button onclick="closePvpRegistration()">Нет</button> 
      </div>
    <div id="pvpBattle" style="display:none;">
        <h2>Бой PvP</h2>
        <div id="pvpOpponentInfo"></div>
        <div id="pvpFightLog"></div>
        <button onclick="endPvpBattle()">Завершить бой</button>
    </div>

    <div id="monsterHealthContainer">
        <div id="monsterHealthBar"></div>
        <div id="monsterHealthValue"></div>
    </div>
    <div id="monsterHealthDisplay">
        <span style="font-size: 30px; margin-right: 10px;">❤️</span>
        Здоровье монстра <span id="monsterHealthValue"></span>
    </div>
    

    <button class="skill-button" disabled>Skill</button>


    <!-- Добавляем кнопку с изображением письма -->
    <div id="mailButton" onclick="toggleMailWindow()"></div>

    <!-- Окно почты -->
    <div id="mailWindow">
        <h2>Ваша почта</h2>
        <p>Здесь будут отображаться ваши награды.</p>
        <button onclick="toggleMailWindow()">Закрыть</button>
    </div>

    <div id="rebornButton" onclick="showRebornPrompt()"></div>
    <div id="rebornPrompt">
        <h2>Вы хотите переродиться?</h2>
        <p>Прогресс уровней, нанятые герои и накопленное золото будут сброшены. Но вы будете получать награды за убийство монстров в два раза выше.</p>
        <button onclick="confirmReborn()">Да</button>
        <button onclick="hideRebornPrompt()">Нет</button>
    </div>

    <!-- Меню для отображения списка кланов -->
<div id="clanListMenu">
    <h2>Список кланов</h2>
    <ul id="clanList"></ul>
    <input type="text" id="clanNameInput" placeholder="Название клана">
    <button onclick="createClan(document.getElementById('clanNameInput').value)">Создать клан</button>
    <button onclick="closeClanListMenu()">Закрыть</button>
</div>


<div id="worldBossScreen" style="display:none;">
    <h2>Мировой Босс</h2>
    <img id="worldBossImage" src="world_boss.png" alt="Мировой Босс">
    <div id="worldBossHealth">Здоровье Босса: <span id="worldBossHealthValue">1000000</span></div>
    <div id="playersDamageList">
        <h3>Список игроков</h3>
        <ul id="damageList"></ul>
    </div>
    <div id="worldBossTimer"></div> 
</div>
   
    <div id="leftCharacterMenu">
        <!-- Контент меню для найма героев слева будет динамически добавлен через JavaScript -->
    </div>
    
    </div>
    <div id="characterMenu">
        <img id="characterImage" src="peasant.png" alt="Character">
        <p style="display:none;">Оружие: <span id="weapon"></span></p> <!-- Скрытый элемент для отображения оружия -->
        <p style="display:none;">Здоровье: <span id="health"></span></p> <!-- Скрытый элемент для отображения здоровья -->
        <p style="display:none;">Уровень: <span id="level"></span></p>
        <p style="display:none;">Золото: <span id="gold"></span></p>
        <p style="display:none;"><span id="totalDamage">Суммарный урон: 0</p>

        <p style="display:none;">Урон: <span id="damage"></span></p>
        
        
        
    </div>
    <!-- <div id="shopMenu">
        <button class="close-btn" onclick="toggleShop()">X</button>
        <h2>Магазин</h2>
        <p>Золото: <span id="shopGold"></span></p>
        <div id="shopItems">
            <div class="shop-item" onclick="showItemDetail('sword.png', 'Меч (+10 сила)', 50, 'sword', 10)">
                <img src="sword_thumb.png" alt="Меч">
                <p>Меч</p>
                <p>50 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('bow.png', 'Лук (+8 сила)', 40, 'bow', 8)">
                <img src="bow_thumb.png" alt="Лук">
                <p>Лук</p>
                <p>40 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('crossbow.png', 'Арбалет (+12 сила)', 60, 'crossbow', 12)">
                <img src="crossbow_thumb.png" alt="Арбалет">
                <p>Арбалет</p>
                <p>60 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('armor.png', 'Доспехи (+15 защита)', 70, 'armor', 15)">
                <img src="armor_thumb.png" alt="Доспехи">
                <p>Доспехи</p>
                <p>70 золота</p>
            </div>
            <div class="shop-item" onclick="showItemDetail('helmet.png', 'Шлем (+5 защита)', 30, 'helmet', 5)">
                <img src="helmet_thumb.png" alt="Шлем">
                <p>Шлем</p>
                <p>30 золота</p>
            </div>
            
        </div>
    </div> -->
    <!-- <div id="topPlayersMenu">
        <button onclick="toggleTopPlayers()">Закрыть</button>
    </div> -->

    <div class="status-bar" id="statusBar" style="display:none;">
        <div class="health-bar">
            <div class="health-bar-inner" id="playerHealthBar"></div>
        </div>
        <p>Уровень: <span id="statusLevel"></span></p>
        <p> <img src="gold_icon.png" alt="Gold Icon" style="width: 30px; height: 30px; vertical-align: middle;"> <span id="statusGold"></span></p>
        <p> <img src="damage_icon.png" alt="Gold Icon" style="width: 30px; height: 30px; vertical-align: middle;"> <span id="statusDamage"></span></p>
        <p><img src="health_icon.png" alt="Health Icon" style="width:  30px;  height:  30px; vertical-align:  middle;"> <span id="statusHealth">100</span></p>  <!--  Добавлен  элемент  для  здоровья  -->
        <p>Эссенция Хаоса: <span id="chaosEssence">0</span></p>
        <p>Множитель награды: <span id="statusRewardMultiplier"></span></p> <!-- Новый элемент для отображения множителя награды -->
    </div>
    
    <div id="errorMessage" style="display: none;">
        <p id="errorMessageText"></p>
        <button onclick="closeErrorMessage()">Закрыть</button> 
    </div>


    
    <div class="victory-message" id="victoryMessage">
        <p>Shap в печали, что вы его бьете :(</p>
    </div>
    
    <div id="rebornSuccessMessage" style="display:  none;">
        <p id="rebornSuccessMessageText"></p>
        <button onclick="closeRebornSuccessMessage()">Закрыть</button>
    </div>
    
    
    <div class="crosshair" id="crosshair"></div>
    <!-- <div id="itemDetail">
        <img id="itemDetailImage" src="" alt="Item Detail">
        <p id="itemDetailName"></p>
        <button onclick="buyItem()">Купить</button>
        <button onclick="closeItemDetail()">Закрыть</button>
    </div> -->
    <div id="continuePrompt">
        <img id="victoryImage" src="win2.png" alt="Вы победили" style="display: none; width: 10px; height: 10px; position: relative; z-index: 3000;">
        <p>Shap в печали, что вы его бьете :(</p>
        <p>Вы хотите продолжить унижать Shap и убить следующего монстра?</p>
        <div id="goldEarned" style="display: none; font-size: 24px; color: gold; font-family: 'Comic Sans MS', cursive, sans-serif;">Золото: <span id="goldAmount"></span></div>
        
    </div>
    
    
    
    <div class="monster-message" id="monsterMessage"></div>
    <script type="module">
        let globalChatListener; 
        let clanChatListener;
        let chaosEssence = 0;
let worldBossTimerInterval;
let timeUntilWorldBoss = 2400; //  Время в секундах (40 минут)

let isRareMonsterEncountered = false; // Флаг, указывающий на встречу с редким монстром
let rareMonsterTimerInterval; // Интервал для таймера редкого монстра
let rareMonsterTimer = 30; // Время на убийство редкого монстра

let rewardMultiplier = 1; // Начальное значение множителя награды
let currentClan = null;  // Текущий клан игрока
let currentChat = 'global'; // Текущий чат (глобальный по умолчанию)

let worldBossMaxHealth  =  1000000; // Максимальное  здоровье  босса
let worldBossHealth  =  worldBossMaxHealth; 
let  worldBossWasKilled = false;  // Флаг,  указывающий, был ли босс убит в текущем  цикле

let talents = {
  fury: { // Ярость 
    name: 'Ярость Стихий', 
    description: 'Увеличивает урон от всех атак.',
    level: 0,
    baseBonus: 100, //  можно менять в будущем 
    cost: 100
  },
  resilience: { // Стойкость
    name: 'Древняя Стойкость',
    description: 'Укрепляет жизненную силу, увеличивая максимальное здоровье.',
    level: 0,
    baseBonus: 1500,  //  можно менять в будущем 
    cost: 100 
  }
};
    // Данные о героях
    let allHeroes = [
    { name: 'Эльф', level: 1, baseDamage: 5, baseCost: 50, damage: 5, cost: 50, img: 'hero1.png', hired: false, 
      skill: {
        name: 'Быстрый выстрел',
        hitsPerSecond: 5,
        duration: 5,
        cooldown: 60, 
        onCooldown: false
      } 
    },
    { name: 'Гном', level: 1, baseDamage: 10, baseCost: 100, damage: 10, cost: 100, img: 'hero2.png', hired: false,
      skill: {
        name: 'Молот гнева',
        hitsPerSecond: 6,
        duration: 5,
        cooldown: 60,
        onCooldown: false 
      } 
    },
    { name: 'хоббит', level: 1, baseDamage: 20, baseCost: 250, damage: 20, cost: 250, img: 'hero3.png', hired: false, 
      skill: {
        name: 'Град стрел',
        hitsPerSecond: 7,
        duration: 5, 
        cooldown: 60, 
        onCooldown: false 
      }
    },
    { name: 'Тор', level: 1, baseDamage: 30, baseCost: 500, damage: 30, cost: 500, img: 'hero4.png', hired: false,
      skill: { 
        name: 'Удар грома', 
        hitsPerSecond: 8, 
        duration: 5, 
        cooldown: 60,
        onCooldown: false
      }
    }, 
    { name: 'Кузнечик', level: 1, baseDamage: 40, baseCost: 1000, damage: 40, cost: 1000, img: 'hero5.png', hired: false,
      skill: {
        name: 'Ярость кузнечика',
        hitsPerSecond: 9, 
        duration: 5, 
        cooldown: 60,
        onCooldown: false
      }
    },
    { name: 'Лесной зверек', level: 1, baseDamage: 60, baseCost: 2000, damage: 60, cost: 2000, img: 'hero6.png', hired: false,
      skill: {
        name: 'Звериная атака',
        hitsPerSecond: 10,
        duration: 5, 
        cooldown: 60,
        onCooldown: false
      }
    },
    { name: 'Дюймовочка', level: 1, baseDamage: 80, baseCost: 4000, damage: 80, cost: 4000, img: 'hero7.png', hired: false,
      skill: {
        name: 'Мини-вихрь',
        hitsPerSecond: 11,
        duration: 5,
        cooldown: 60, 
        onCooldown: false
      }
    },
    { name: 'Зевс', level: 1, baseDamage: 100, baseCost: 8000, damage: 100, cost: 8000, img: 'hero8.png', hired: false,
      skill: {
        name: 'Гнев богов',
        hitsPerSecond: 12, 
        duration: 5,
        cooldown: 60,
        onCooldown: false
      }
    },
    { name: 'Аполлон', level: 1, baseDamage: 120, baseCost: 16000, damage: 120, cost: 16000, img: 'hero9.png', hired: false,
      skill: {
        name: 'Солнечный удар',
        hitsPerSecond: 13,
        duration: 5,
        cooldown: 60, 
        onCooldown: false
      }
    },
    { name: 'Олимп', level: 1, baseDamage: 200, baseCost: 100000, damage: 200, cost: 100000, img: 'hero10.png', hired: false,
      skill: {
        name: 'Мощь Олимпа', 
        hitsPerSecond: 14, 
        duration: 5,
        cooldown: 60, 
        onCooldown: false
      }
    }
];
let initialHeroes = allHeroes.slice(0, 5); // Начальные герои
let heroes = [...initialHeroes];
// Функция для миграции данных героев
let  currentQuestCategory  =  'Убийство монстров'; //  Текущая категория  

let questCategories = {
    'Убийство монстров': [
        { description: 'Убить 10 монстров', goal: 10, progress: 0, reward: 500, completed: false, claimed: false },
        { description: 'Убить 30 монстров', goal: 30, progress: 0, reward: 1000, completed: false, claimed: false },
        { description: 'Убить 60 монстров', goal: 60, progress: 0, reward: 2500, completed: false, claimed: false },
        { description: 'Убить 100 монстров', goal: 100, progress: 0, reward: 5000, completed: false, claimed: false },
        { description: 'Убить 150 монстров', goal: 150, progress: 0, reward: 8000, completed: false, claimed: false },
        { description: 'Убить 210 монстров', goal: 210, progress: 0, reward: 12000, completed: false, claimed: false },
        { description: 'Убить 280 монстров', goal: 280, progress: 0, reward: 17000, completed: false, claimed: false },
        { description: 'Убить 360 монстров', goal: 360, progress: 0, reward: 23000, completed: false, claimed: false },
        { description: 'Убить 450 монстров', goal: 450, progress: 0, reward: 30000, completed: false, claimed: false },
        { description: 'Убить 550 монстров', goal: 550, progress: 0, reward: 40000, completed: false, claimed: false }
    ],
    'Убийство редких монстров': [ // *** Новая категория ***
        { description: 'Победить 1 Эпического монстра', goal: 1, progress: 0, reward: 1000, completed: false, claimed: false },
        { description: 'Победить 2 Эпических монстров', goal: 2, progress: 0, reward: 5000, completed: false, claimed: false },
        { description: 'Победить 3 Эпических монстров', goal: 3, progress: 0, reward: 10000, completed: false, claimed: false },
        { description: 'Победить 4 Эпических монстров', goal: 4, progress: 0, reward: 20000, completed: false, claimed: false },
        { description: 'Победить 5 Эпических монстров', goal: 5, progress: 0, reward: 50000, completed: false, claimed: false }
    ],
    'Перерождения': [ // *** Новая категория  *** 
        { description:  'Переродиться  1  раз', goal:  1, progress: 0,  reward:  2000, completed:  false, claimed:  false },
        { description: 'Переродиться  3  раза',  goal: 3,  progress:  0,  reward: 20000,  completed:  false,  claimed: false }, 
        { description:  'Переродиться 5  раз',  goal:  5,  progress:  0,  reward: 100000, completed:  false,  claimed: false }
    ],
    'Трата золота': [
        { description: 'Потратить 1000 золота', goal: 1000, progress: 0, reward: 200, completed: false, claimed: false },
        { description: 'Потратить 3000 золота', goal: 3000, progress: 0, reward: 500, completed: false, claimed: false },
        { description: 'Потратить 6000 золота', goal: 6000, progress: 0, reward: 1200, completed: false, claimed: false },
        { description: 'Потратить 10000 золота', goal: 10000, progress: 0, reward: 2500, completed: false, claimed: false },
        { description: 'Потратить 15000 золота', goal: 15000, progress: 0, reward: 4000, completed: false, claimed: false },
        { description: 'Потратить 21000 золота', goal: 21000, progress: 0, reward: 6000, completed: false, claimed: false },
        { description: 'Потратить 28000 золота', goal: 28000, progress: 0, reward: 8500, completed: false, claimed: false },
        { description: 'Потратить 36000 золота', goal: 36000, progress: 0, reward: 11500, completed: false, claimed: false },
        { description: 'Потратить 45000 золота', goal: 45000, progress: 0, reward: 15000, completed: false, claimed: false },
        { description: 'Потратить 55000 золота', goal: 55000, progress: 0, reward: 20000, completed: false, claimed: false }
    ]
};

const rareMonsterImages = [
    'rare_monster1.png',
    'rare_monster2.png',
    'rare_monster3.png',
    
];

// Функция для открытия меню талантов
function openTalentsMenu() {
  document.getElementById('talentsMenu').style.display = 'block'; 
  updateTalentsMenu();
}
window.openTalentsMenu = openTalentsMenu;

// Функция для закрытия меню талантов
function closeTalentsMenu() {
  document.getElementById('talentsMenu').style.display = 'none';
}
window.closeTalentsMenu = closeTalentsMenu;

// Функция для обновления меню талантов
function updateTalentsMenu() {
  const talentsContainer = document.getElementById('talentsContainer'); 
  talentsContainer.innerHTML = ''; 
  document.getElementById('talentsChaosEssence').textContent = chaosEssence; 

  for (const talentId in talents) {
    const talent = talents[talentId];
    const talentDiv = document.createElement('div');
    talentDiv.classList.add('talent');
    talentDiv.innerHTML = `
      <h3>${talent.name}</h3> 
      <p>${talent.description}</p>
      <p>Уровень: ${talent.level}</p>
      <p>Бонус: +${calculateTalentBonus(talentId, talent.level + 1)}</p> 
      <p>Стоимость: ${calculateTalentCost(talentId, talent.level + 1)} Эссенции Хаоса</p>
      <button onclick="upgradeTalent('${talentId}')">Улучшить</button>
    `;
    talentsContainer.appendChild(talentDiv);
  }
}

// Функция для расчета бонуса таланта
function  calculateTalentBonus(talentId,  level)  { 
  const talent  =  talents[talentId]; 
  return level  *  talent.baseBonus;  //  Используем baseBonus 
}

// Функция для расчета стоимости улучшения таланта
function calculateTalentCost(talentId, level) {
  return Math.pow(3, level - 1) * talents[talentId].cost; 
}

// Функция для улучшения таланта
function upgradeTalent(talentId) {
  const talent = talents[talentId];
  const cost = calculateTalentCost(talentId, talent.level + 1); 

  if (chaosEssence >= cost) {
    chaosEssence -= cost;
    talent.level++;
    updateTalentsMenu(); 
    updateStatusBar();  //  Добавляем  вызов  здесь 

    // Обновляем  здоровье  или  урон  в  зависимости  от  улучшенного  таланта
    if (talentId === 'fury') { 
      updateTotalDamage(); 
      updateStatusBar(); 
    } else if (talentId === 'resilience') {
      playerHealth = calculateTotalHealth(); 
      updateStatusBar(); 
    } 

    saveProgress();
  } else {
    showGameMessage('Недостаточно Эссенции Хаоса!');
  }
}
window.upgradeTalent = upgradeTalent;

//  Функция для  переключения  категории  заданий  
function  switchQuestCategory(category)  { 
    console.log(`Переключение категории  на  ${category}`); // *** ДОБАВЬТЕ ЛОГИРОВАНИЕ *** 
    currentQuestCategory  = category; 
    updateDailyQuestsUI();
}
window.switchQuestCategory  =  switchQuestCategory;

function showRebornPrompt() {
    const playerLevel = currentLevel;
    let rebornPossible = false;
    let nextRebornLevel = 0;

    const nextRebornCount = rebornCount; //  Без увеличения

    if (nextRebornCount === 0 && playerLevel >= 10) {
        rebornPossible = true;
        nextRebornLevel = 20;
    } else if (nextRebornCount === 1 && playerLevel >= 20) {
        rebornPossible = true;
        nextRebornLevel = 30;
    } else if (nextRebornCount === 2 && playerLevel >= 30) {
        rebornPossible = true;
        nextRebornLevel = 40;
    } else if (nextRebornCount >= 3 && playerLevel >= 50) {
        rebornPossible = true;
        nextRebornLevel = 50;
    } else { //  ***  ИСПРАВЛЕНИЕ В БЛОКЕ ELSE ***
        rebornPossible = false;

        //  Используем ту  же  логику  расчета, что и  в  начале
        if (nextRebornCount === 0) { 
            nextRebornLevel = 10;
        } else if (nextRebornCount === 1) {
            nextRebornLevel = 20;
        } else if (nextRebornCount === 2) {
            nextRebornLevel = 30;
        } else {
            nextRebornLevel = 50;
        }
    }

  if (rebornPossible) {
    document.getElementById('rebornMenu').style.display =  'block'; 
    document.getElementById('rebornMessage').textContent = `Прогресс уровней, нанятые  герои  и  накопленное золото будут  сброшены. Но вы будете получать награды  за  убийство  монстров в ${1 + rebornCount * 0.1}  раза  выше. Также  будут доступны новые  герои  для найма. Следующее перерождение доступно с уровня ${nextRebornLevel}.`;
  } else {
    document.getElementById('errorMessage').style.display =  'block';
    document.getElementById('errorMessageText').textContent = `Ваш  уровень слишком  низок  для перерождения!  Требуется уровень:  ${nextRebornLevel}.`;
  }
}
window.showRebornPrompt = showRebornPrompt;


// Функция  для  закрытия  окна  сообщения  об  ошибке 
function closeErrorMessage() {
    document.getElementById('errorMessage').style.display = 'none';
}
window.closeErrorMessage = closeErrorMessage;

//  Функция  для  закрытия  окна  перерождения  
function closeRebornMenu()  {
    document.getElementById('rebornMenu').style.display =  'none'; 
}
window.closeRebornMenu = closeRebornMenu;

// Функция для перерождения
function confirmReborn() {
  hideRebornPrompt();
  levels = new Array(10000).fill().map((_, i) => ({ number: i + 1, stars: 0, completed: false }));
  heroes.forEach(hero => {
    const baseDamage = hero.baseDamage || 0;
    const baseCost = hero.baseCost || 0;

    hero.level = 0;
    hero.hired = false;
    hero.damage = calculateHeroStats(1, baseDamage, baseCost).newDamage;
    hero.cost = baseCost;
  });
  currentLevel = 1;
  rebornCount++;
  rewardMultiplier = Math.min(1 + rebornCount * 0.1, 9999);

  // Обновить список героев для включения новых героев после перерождения
  heroes = allHeroes;

  updateGold(100).then(() => {
    updateCharacterMenu();
    addHeroesToMenu();
    startLevel(currentLevel);
    closeRebornMenu();
    document.getElementById('rebornSuccessMessage').style.display = 'block';
    document.getElementById('rebornSuccessMessageText').textContent = `Вы переродились!
                                                                          Теперь вы будете получать награды за убийство монстров в ${rewardMultiplier.toFixed(1)} раза выше.`;

    // ***  ОБНОВЛЯЕМ ПРОГРЕСС ЗАДАНИЙ НА ПЕРЕРОЖДЕНИЕ ***
    questCategories['Перерождения'].forEach(quest => {
      if (!quest.completed) {
        quest.progress++;
        if (quest.progress >= quest.goal) {
          quest.completed = true;
          showGameMessage(`Задание "${quest.description}" выполнено!`);
        }
      }
    });

    saveProgress().then(() => {
      console.log('Progress saved after reborn');
      updateStatusBar();
    }).catch(error => {
      console.error('Error saving progress after reborn:', error);
    });
  }).catch(error => {
    console.error('Error updating gold:', error);
  });
}
window.confirmReborn = confirmReborn;

//  Функция  для закрытия окна сообщения о перерождении  
function closeRebornSuccessMessage() {
    document.getElementById('rebornSuccessMessage').style.display = 'none';
}
window.closeRebornSuccessMessage = closeRebornSuccessMessage;


// Функция для проверки встречи с редким монстром
function checkForRareMonster() {
  return Math.random() <= 0.1; // 10% шанс
}

// Функция для начала боя с редким монстром
function startRareMonsterBattle() {
  isRareMonsterEncountered = true;
  monsterHealth = baseMonsterHealth * Math.pow(1.1, currentLevel - 1) * 2; // Удваиваем здоровье
  rareMonsterTimer = 30; // Сбрасываем таймер
  updateMonsterImage(currentLevel); // Используем то же изображение, но можно добавить другое
  document.getElementById('rareMonsterTimer').style.display = 'block';
  updateMonsterHealthDisplay(); // Обновляем полоску здоровья

  // Запускаем таймер
  rareMonsterTimerInterval = setInterval(updateRareMonsterTimer, 1000);
}

// Функция для обновления таймера редкого монстра
function updateRareMonsterTimer() {
  rareMonsterTimer--; 
  document.getElementById('rareMonsterTimer').textContent = rareMonsterTimer + " секунд"; // Добавляем "секунд"

  if (rareMonsterTimer <= 0) {
    clearInterval(rareMonsterTimerInterval);
    document.getElementById('rareMonsterTimer').style.display = 'none';
    isRareMonsterEncountered = false;
    showGameMessage("Время вышло! Редкий монстр скрылся...");
    showContinuePrompt(); 
  }
}

//  На  сервере
function  handleWorldBossDeath()  {
  const  worldBossRef  =  ref(database,  'worldBoss');
  const  rebornTime  =  Date.now()  +  (timeUntilWorldBoss  *  1000); 

  set(worldBossRef,  {
    health:  0,
    rebornTime:  rebornTime, 
    isAlive:  false
  });

  setTimeout(()  =>  {
    resetWorldBossHealth(); 
    set(worldBossRef,  {
      health:  worldBossMaxHealth, 
      rebornTime:  null, //  Устанавливаем rebornTime в null
      isAlive:  true    //  Устанавливаем isAlive в true 
    });
  },  timeUntilWorldBoss  *  1000);
}

function duplicateSkillButtons() {
  const skillButtonsContainer = document.getElementById('skillButtonsContainer');
  skillButtonsContainer.innerHTML = ''; // Очищаем контейнер перед добавлением кнопок

  heroes.forEach(hero => {
    if (hero.hired) {
      // Создаем новую кнопку скилла
      const skillButton = document.createElement('img');
      skillButton.src = hero.img; // Используем изображение героя в качестве иконки
      skillButton.alt = hero.skill.name;
      skillButton.classList.add('skill-button');
      skillButton.title = hero.skill.name; // Добавляем подсказку с названием скилла
      skillButton.disabled = hero.skill.onCooldown; 

      // Добавляем обработчик события click 
      skillButton.addEventListener('click', () => {
        activateSkill(hero);
        // Отключаем все кнопки этого скилла (в книге и у героя)
        disableSkillButtons(hero); 
      });

      // Добавляем класс 'onCooldown' если скилл на перезарядке
      if (hero.skill.onCooldown) {
        skillButton.classList.add('onCooldown');
      }

      // Добавляем кнопку в контейнер
      skillButtonsContainer.appendChild(skillButton); 
    }
  });
}


//  Функция для отключения  всех  кнопок  скилла  героя
function disableSkillButtons(hero) {
  // Отключаем кнопку в меню героя и добавляем класс .onCooldown 
  const heroDiv = document.querySelector(`.hero[alt="${hero.name}"]`);

  // Объявляем bookButton здесь 
  const bookButton = document.querySelector(`#skillButtonsContainer img[alt="${hero.skill.name}"]`);

   //  Отключаем  кнопку в  меню героя  и  добавляем  класс  .onCooldown  
   if (heroDiv) { 
      const skillButton = heroDiv.querySelector('.skill-button'); 
      if (skillButton) {
          // --- LOGGING START ---
          console.log(`Disabling hero skill button for ${hero.name}, adding .onCooldown`);
          // Логируем прозрачность родителя
          console.log(`Hero div opacity: ${heroDiv.style.opacity}`);
          // --- LOGGING END ---

          skillButton.classList.add('onCooldown'); 

          // Добавляем задержку перед отключением
          setTimeout(() => {
            skillButton.disabled = true;
          }, 100); 
        } 
  }

   // Отключаем  кнопку в книге  скиллов  и добавляем  класс .onCooldown
  if  (bookButton) {
    // --- LOGGING START ---
    console.log(`Disabling skill book button for ${hero.name}, adding .onCooldown`);
    // --- LOGGING END ---
      
    //  Сначала  добавляем класс .onCooldown: 
    bookButton.classList.add('onCooldown');

    //  Потом  отключаем кнопку
    setTimeout(() => {
        bookButton.disabled = true;
    },  10);  // Можно  увеличить задержку, если  необходимо
  } 
}


function  updateWorldBossTimer()  {
    const  worldBossRef =  ref(database, 'worldBoss');
    onValue(worldBossRef, (snapshot)  =>  { 
      const  data =  snapshot.val();

      if (data.rebornTime)  { 
        //  Вычисляем  оставшееся время  в секундах  
        const timeUntilWorldBoss  =  Math.max(0, Math.floor((data.rebornTime - Date.now())  /  1000)); 

        const minutes = Math.floor(timeUntilWorldBoss  / 60);
        const  seconds = timeUntilWorldBoss  %  60; 

        const  worldBossTimerElement =  document.getElementById('worldBossTimer'); 
        worldBossTimerElement.textContent  =  `Осталось  ${minutes}m  ${seconds}s  до появления  мирового  босса`; 

        //  Логируем координаты  и размеры
        const  rect  =  worldBossTimerElement.getBoundingClientRect(); 
        console.log(`worldBossTimer coordinates:  x=${rect.left},  y=${rect.top}`);
        console.log(`worldBossTimer size: width=${rect.width},  height=${rect.height}`);  
      } else {
        //  Босс жив, таймер не  отображается  
        document.getElementById('worldBossTimer').style.display  =  'none'; 
      }
    }); 
}

function activateSkill(hero) {
if (hero.hired && !hero.skill.onCooldown) {
    console.log(`Активация скилла "${hero.skill.name}"`);
    hero.skill.onCooldown = true;
    // Обновляем  книгу  скиллов  
    duplicateSkillButtons(); //  **ДОБАВЛЕНО** 
    hero.skill.activationTime = Date.now();

    // --- LOGGING START ---
    let skillStartTime = Date.now();
    console.log(`Skill "${hero.skill.name}" activated at ${skillStartTime}`);
    // --- LOGGING END ---

    let skillHits = 0;
    const skillInterval = setInterval(() => {
      if (currentScreen === 'battle' && skillHits < hero.skill.hitsPerSecond * hero.skill.duration) {
        hitMonster({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
        skillHits++;
      } else {
        clearInterval(skillInterval);
      }
    }, 1000 / hero.skill.hitsPerSecond);

    const cooldownTime = hero.skill.cooldown * 1000;

    setTimeout(() => {
      hero.skill.onCooldown = false;
      delete hero.skill.activationTime;

      // 1. Обновляем кнопку в меню героя
      const heroDiv = document.querySelector(`.hero[alt="${hero.name}"]`);
      if (heroDiv) {
        const skillButton = heroDiv.querySelector('.skill-button');
        if (skillButton) {
          skillButton.disabled = false;
          skillButton.classList.remove('onCooldown');

          // --- LOGGING START ---
          let skillEndTime = Date.now();
          console.log(`Skill "${hero.skill.name}" cooldown finished at ${skillEndTime}, duration: ${skillEndTime - skillStartTime}ms`);
          console.log(`Skill button styles:`, skillButton.style);
          // --- LOGGING END ---
        }
      }

      // 2. Обновляем книгу скиллов
      duplicateSkillButtons();

      // Сохраняем прогресс
      saveProgress()
        .then(() => console.log("Прогресс сохранен после окончания cooldown."))
        .catch((error) => console.error("Ошибка при сохранении прогресса после окончания cooldown:", error));
    }, cooldownTime);
  } else if (hero.skill.onCooldown) {
    const remainingCooldown = Math.ceil((hero.skill.activationTime + hero.skill.cooldown * 1000 - Date.now()) / 1000);
    showGameMessage(`Скилл "${hero.skill.name}" на перезарядке! Осталось ${remainingCooldown} секунд.`);
  }
}

function updateCooldown(hero, startTime) {
    const cooldownTime = hero.skill.cooldown * 1000; // Время отката в миллисекундах
    const elapsedTime = Date.now() - startTime; // Прошедшее время с момента активации
    const remainingTime = Math.max(0, cooldownTime - elapsedTime); // Оставшееся время отката

    const cooldownPercentage = (remainingTime / cooldownTime) * 100; // Процент отката

    // Поиск кнопки скилла для героя
    const heroDiv = document.querySelector(`.hero[alt="${hero.name}"]`);
    
    // Проверяем, найден ли heroDiv
    if (heroDiv) {
        const skillButton = heroDiv.querySelector('.skill-button');
        
        // Проверяем, найдена ли skillButton
        if (skillButton) {
            skillButton.disabled = true; // Кнопка остается отключенной во время отката

            skillButton.querySelector('::before').style.transform = `scaleX(${1 - cooldownPercentage / 100})`;



            if (remainingTime > 0) {
                // Продолжаем обновлять индикатор отката
                requestAnimationFrame(() => updateCooldown(hero, startTime));
            } else {
                // Откат завершен
                hero.skill.onCooldown = false;
                skillButton.disabled = false; // Разблокируем кнопку
                
            }
        } else {
            console.error("skillButton не найден для героя:", hero.name);
        }
    } else {
        console.error("heroDiv не найден для героя:", hero.name);
    }
}


//  Функция для открытия меню ежедневных заданий  
function  openDailyQuestsMenu()  { 
    document.getElementById('dailyQuestsMenu').style.display = 'block';
    updateDailyQuestsUI(); 
}
window.openDailyQuestsMenu  = openDailyQuestsMenu;

// Функция для закрытия меню  ежедневных заданий  
function  closeDailyQuestsMenu()  { 
    document.getElementById('dailyQuestsMenu').style.display =  'none'; 
} 
window.closeDailyQuestsMenu  = closeDailyQuestsMenu;

// Функция  для обновления UI  ежедневных заданий 
function updateDailyQuestsUI() {
    const dailyQuestsList = document.getElementById('dailyQuestsList');
    dailyQuestsList.innerHTML = ''; // Очищаем список 

    // ПРОВЕРКА НА UNDEFINED
    const currentQuests = questCategories[currentQuestCategory];
    if (!currentQuests) { 
      console.error(`Категория ${currentQuestCategory} не найдена в questCategories!`); 
      return; // Прекращаем выполнение функции, если категория не найдена
    }

    currentQuests.forEach((quest, index) => { 
        // Отображаем задание, только если оно НЕ выполнено ИЛИ выполнено, но награда не получена
        if (!quest.completed || (quest.completed && !quest.claimed)) { 
            const questItem = document.createElement('li');
            questItem.textContent = `${quest.description} (${quest.progress}/${quest.goal}) - Награда: ${quest.reward} золота`; 

            // Добавляем кнопку "Получить награду", если задание выполнено И награда еще не забрана
            if (quest.completed && !quest.claimed) { 
                const claimRewardButton = document.createElement('button');
                claimRewardButton.textContent = 'Получить награду'; 
                claimRewardButton.onclick =  () => {  
                    claimDailyQuestReward(index); 
                };
                questItem.appendChild(claimRewardButton); 
            }

            dailyQuestsList.appendChild(questItem); 
        }
    });

    // Добавляем информацию о сбросе заданий 
    const resetTimeElement = document.createElement('p'); 
    resetTimeElement.id = 'dailyQuestResetTime';
    resetTimeElement.textContent = `Сброс через: ${getTimeUntilDailyQuestReset()}`;
    dailyQuestsList.appendChild(resetTimeElement);
}

//  Функция для  динамического  создания кнопок  категорий 
function createCategoryButtons() {
  const categoriesContainer = document.getElementById('dailyQuestCategories');
  categoriesContainer.innerHTML = '';

  for (const category in questCategories) {
    const button = document.createElement('button');
    button.textContent = category;
    button.onclick = () => switchQuestCategory(category);
    categoriesContainer.appendChild(button);
  }
}



//  Функция для  получения награды за  задание
function claimDailyQuestReward(questIndex) {
    const quest = questCategories[currentQuestCategory][questIndex];

    if (quest.completed && !quest.claimed) { // Проверяем, забрана ли  уже награда
        console.log("Получение награды  за задание:", quest.description);
        console.log("Награда:", quest.reward); 

        updateGold(gold + quest.reward)
            .then(() => {
                console.log("Золото обновлено.  Текущее золото:", gold); 

                // Помечаем, что награда  забрана 
                quest.claimed = true;  
                
                updateDailyQuestsUI();
                saveProgress();
                console.log('Задание  обновлено  и прогресс  сохранен.');
            }) 
            .catch((error) => {
                console.error("Ошибка  при  обновлении  золота:",  error); 
            });
            quest.claimed =  true; 
            updateDailyQuestsUI(); 
    }
}
window.claimDailyQuestReward = claimDailyQuestReward;



// Функция для сброса ежедневных заданий 
async function resetDailyQuests() {
  console.log("Проверка необходимости сброса ежедневных заданий...");

  const now = new Date();
  const resetHourUTC = 0; //  Час сброса  в UTC

  // Проверяем, нужно ли сбрасывать задания
  const lastResetRef = ref(database, `players/${nickname}/lastDailyQuestReset`);
  const lastResetSnapshot = await get(lastResetRef);

  let lastReset = lastResetSnapshot.exists() ? new Date(lastResetSnapshot.val()) : null;

  //  Если lastReset равен null или  если  текущий  день  больше, чем  день  последнего сброса,  сбрасываем задания  
  if (!lastReset || now.getUTCDate() > lastReset.getUTCDate() || (now.getUTCDate() === lastReset.getUTCDate() && now.getUTCHours() >= resetHourUTC && lastReset.getUTCHours() < resetHourUTC)) { 
    console.log("Сброс ежедневных заданий...");

    for (const category in questCategories) {
      questCategories[category].forEach(quest => {
        quest.progress = 0;
        quest.completed = false;
        quest.claimed = false;
      });
    }

    await saveProgress(); // Сохранение прогресса заданий
    await set(lastResetRef, now.toISOString()); //  Обновляем  время  последнего сброса  

    updateDailyQuestsUI();  // Обновляем UI после сброса

    console.log("Ежедневные задания сброшены!");
  } else {
    console.log("Сброс ежедневных заданий не требуется.");
  }
}
window.resetDailyQuests = resetDailyQuests;
//  Запускаем  таймер  для  ежедневного сброса заданий  



//  Функция для расчета времени  до  сброса  ежедневных заданий
function  getTimeUntilDailyQuestReset()  {
    const now  =  new  Date(); 
    const  resetHour  =  0;  //  Час  сброса  (00:00  UTC)  
    const resetTime = new Date(now);
    resetTime.setUTCHours(resetHour, 0,  0,  0); 

    // Если время  сброса уже  прошло сегодня,  устанавливаем  его  на  завтра
    if  (now  >=  resetTime)  { 
        resetTime.setUTCDate(resetTime.getUTCDate()  +  1);
    }

    const  timeDifference  = resetTime.getTime()  - now.getTime();
    const  hours =  Math.floor(timeDifference  / (1000  *  60  *  60)); 
    const minutes  = Math.floor((timeDifference  %  (1000  *  60  *  60)) /  (1000  *  60));

    return `${hours} ч ${minutes}  мин`; 
}








function showGameMessage(message) {
  const gameMessage = document.getElementById('gameMessage');
  const gameMessageText = document.getElementById('gameMessageText');
  gameMessageText.textContent = message;
  gameMessage.style.display = 'block';

  // Скрываем сообщение  через  3  секунды
  setTimeout(()  =>  {
    gameMessage.style.display = 'none'; 
  },  3000);
}
window.showGameMessage = showGameMessage; 


// Функция для миграции данных героев
function migrateHeroData(oldHeroes) {
  return oldHeroes.map(oldHero => {
    const newHero = allHeroes.find(hero => hero.name === oldHero.name); 
    if (newHero) {
      //  Копируем  данные  и добавляем  skill,  если  его нет  у  старого героя
      return {
        ...newHero, 
        level: oldHero.level ||  1, 
        damage: calculateHeroStats(oldHero.level  ||  1,  newHero.baseDamage, newHero.baseCost).newDamage, 
        cost: calculateHeroStats(oldHero.level  ||  1,  newHero.baseDamage, newHero.baseCost).newCost, 
        hired: oldHero.hired  || false, 
        skill: {
          ...newHero.skill, // Используем новые значения по умолчанию
          // ...(oldHero.skill || {}), // Копируем старые значения, если они есть
          remainingCooldown: oldHero.skill?.remainingCooldown || 0 //  Проверка  существования remainingCooldown 
        }
      };
    }
    return oldHero; 
  });
}
window.migrateHeroData = migrateHeroData;








function createHeroElement(hero) {
    const heroDiv = document.createElement('div');
    heroDiv.className = `hero ${hero.hired ? 'hired' : 'not-hired'}`;
    heroDiv.setAttribute('alt', hero.name);

    const heroImg = document.createElement('img');
    heroImg.src = hero.img;
    heroImg.alt = hero.name; 
    heroDiv.appendChild(heroImg);

    const heroName = document.createElement('p');
    heroName.textContent = hero.name;
    heroDiv.appendChild(heroName);

    const heroLevel = document.createElement('p');
    heroLevel.textContent = `Ур.: ${hero.level}`;
    heroDiv.appendChild(heroLevel);

    const heroDamage = document.createElement('p');
    heroDamage.textContent = `Урон: ${hero.damage}`;
    heroDiv.appendChild(heroDamage);

    const heroCost = document.createElement('p');
    const upgradeCost = hero.hired ? calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost).newCost : hero.cost;
    heroCost.textContent = `Стоимость: ${upgradeCost}`;
    heroDiv.appendChild(heroCost);

    // Кнопка для скилла
    const skillButton = document.createElement('button');
    skillButton.classList.add('skill-button'); 
    skillButton.textContent = hero.skill ? hero.skill.name : 'Скилл недоступен';
        //  Лог  состояния  onCooldown  при  создании кнопки  
        console.log(`${hero.name} skill button created, onCooldown:  ${hero.skill.onCooldown}`);
    skillButton.disabled = !hero.hired || hero.skill.onCooldown; // Отключена, если герой не нанят
    skillButton.onclick = () => {
    activateSkill(hero);
    // Сначала добавляем класс onCooldown
    skillButton.classList.add('onCooldown'); 
    // Затем отключаем кнопку с задержкой
    setTimeout(() => {
        skillButton.disabled = true;
    }, 300); // 300 мс - примерное время анимации opacity
};
    heroDiv.appendChild(skillButton);

    // Кнопка "Нанять/Улучшить"
    const hireButton = document.createElement('button');
    hireButton.className = hero.hired ? 'upgrade-button' : 'hire-button'; // Присваиваем класс кнопке
    hireButton.textContent = hero.hired ? 'Улучшить' : 'Нанять';
    hireButton.onclick = () => {
        hireOrUpgradeHero(hero, heroDiv, hireButton);
    };
    heroDiv.appendChild(hireButton);

    return heroDiv;
}

window.createHeroElement = createHeroElement;


    // Функция для добавления героев в меню
    function addHeroesToMenu() {
    const leftCharacterMenu = document.getElementById('leftCharacterMenu');
    leftCharacterMenu.innerHTML = ''; // Очистка меню перед добавлением героев
    heroes.forEach(hero => {
        const heroElement = createHeroElement(hero);
        leftCharacterMenu.appendChild(heroElement);
    });
}
window.addHeroesToMenu = addHeroesToMenu;

async  function displayLastPvpBattles() {
  const battlesRef = ref(database, 'pvpBattles');
  const battlesSnapshot = await get(battlesRef);

  if (battlesSnapshot.exists()) {
    const battlesData = battlesSnapshot.val();
    const battlesArray = Object.values(battlesData);

    //  Сортируем битвы по  времени  (последние сверху)  
    battlesArray.sort((a, b) =>  b.timestamp  - a.timestamp);  

    const last5Battles =  battlesArray.slice(0,  5); // Берем  последние  5  битв
    const battleList =  document.getElementById('pvpLastBattles');

    // Очищаем предыдущий список  битв
    battleList.innerHTML = '';

    //  Список  для  отслеживания уже  отображенных  пар игроков  
    const  displayedBattles = new  Set();  

    last5Battles.forEach((battle,  index)  => {  //  Передаем  index  в forEach
        //  Создаем  уникальный  ключ  для  пары игроков
        //  Сортируем  никнеймы, чтобы  ключ  был  одинаковым  независимо от  порядка  игроков 
        const battleKey = [battle.player1,  battle.player2].sort().join('-');  

        // Проверяем,  была  ли эта  пара  игроков  уже отображена
        if (displayedBattles.has(battleKey))  {
            return; //  Пропускаем  битву 
        } 

        // Добавляем  пару  игроков  в список  отображенных 
        displayedBattles.add(battleKey);  

        const battleItem =  document.createElement('li'); 
        const winner = battle.winner ===  'player' ? battle.player1 : battle.player2;  
        battleItem.textContent = `${battle.player1}  vs  ${battle.player2}  - Победил:  ${winner}`; 
        battleList.appendChild(battleItem);

        //  Логируем координаты и  текст  каждой битвы
        console.log(`Битва  ${index  + 1}:`,  {
            text: battleItem.textContent, 
            x: battleItem.getBoundingClientRect().x, 
            y:  battleItem.getBoundingClientRect().y, 
        });
    }); 

    // Логируем координаты и размеры  контейнера  списка битв 
    const battleListRect  = battleList.getBoundingClientRect(); 
    console.log('Контейнер  списка  битв:',  { 
        x: battleListRect.x,
        y:  battleListRect.y, 
        width: battleListRect.width, 
        height: battleListRect.height
    });

  } else  {
    console.log("Нет данных  о PvP-битвах");
  }
}

function hireOrUpgradeHero(hero, heroDiv, hireButton) {
    console.log(`Начало функции hireOrUpgradeHero для ${hero.name}, уровень: ${hero.level}, золото: ${gold}`);

    if (!hero.hired && gold >= hero.cost) {
        // Найм героя
        console.log(`Найм героя ${hero.name} за ${hero.cost} золота`);
        spendGold(hero.cost);
        hero.hired = true;
        hero.level = 1; 
        const stats = calculateHeroStats(hero.level, hero.baseDamage, hero.baseCost);
        hero.damage = stats.newDamage;
        hero.cost = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost).newCost; 
        console.log(`Герой ${hero.name} нанят: уровень ${hero.level}, урон ${hero.damage}, следующая стоимость улучшения ${hero.cost}`);
        heroDiv.classList.remove('not-hired');
        heroDiv.classList.add('hired');
        hireButton.textContent = 'Улучшить';
        updateHeroElement(hero, heroDiv);

        // Обновление состояния кнопки скилла 
        const skillButton = heroDiv.querySelector('.skill-button');
        if (skillButton) {
            skillButton.disabled = !hero.hired || hero.skill.onCooldown;
        }

        // Обновление информации в клане
        updateClanMemberData(nickname, {
            level: currentLevel,
            damage: calculateTotalDamage()
        });
                // Дублируем  кнопки  скиллов  в  книге  
                duplicateSkillButtons();
    } else if (hero.hired) {
        // Улучшение героя
        console.log(`Улучшение героя ${hero.name}`);
        const stats = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost);
        const upgradeCost = stats.newCost;
        console.log(`Текущая стоимость улучшения: ${hero.cost}, Новая стоимость улучшения: ${upgradeCost}`);
        if (gold >= upgradeCost) {
            console.log(`Герой ${hero.name} улучшается за ${upgradeCost} золота`);
            spendGold(upgradeCost);
            hero.level++;
            hero.damage = stats.newDamage;
            hero.cost = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost).newCost;
            console.log(`Герой ${hero.name} улучшен: уровень ${hero.level}, урон ${hero.damage}, следующая стоимость улучшения ${hero.cost}`);
            updateHeroElement(hero, heroDiv);

            // Обновление состояния кнопки скилла
            const skillButton = heroDiv.querySelector('.skill-button');
            if (skillButton) {
                skillButton.disabled = !hero.hired || hero.skill.onCooldown;
            }

            // Обновление информации в клане
            updateClanMemberData(nickname, {
                level: currentLevel,
                damage: calculateTotalDamage()
            });

            //  Изменить текст кнопки на  "Улучшено!" 
 hireButton.textContent  = 'Улучшено!';

//  Изменить  цвет  кнопки
hireButton.style.background = 'linear-gradient(to  right,  #23c85f,  #212a78)'; //  Зелёный градиент

            //  Вернуть исходный  цвет  и  текст  через  2  секунды
            setTimeout(() =>  {
                hireButton.textContent =  'Улучшить';
                hireButton.style.background = 'linear-gradient(to  right,  #ff416c,  #ff4b2b)'; //  Исходный градиент
            }, 2000); //  2 секунды  
                    // Дублируем  кнопки  скиллов  в  книге  
        duplicateSkillButtons();
        } else {
            console.log('Недостаточно золота для улучшения!');
            showGameMessage("Недостаточно золота!");
        }
    } else {
        console.log('Недостаточно золота для найма!');
        showGameMessage("Недостаточно золота для найма!");
    }

    updateTotalDamage(); // Добавьте эту строку, если вы хотите обновлять totalDamage в реальном времени 
    localGoldUpdated = true;
    updateStatusBar();
    savePlayerData();
    console.log(`Конец функции hireOrUpgradeHero для ${hero.name}, уровень: ${hero.level}, золото: ${gold}`);
}
window.hireOrUpgradeHero = hireOrUpgradeHero;















function saveGoldToDatabase() {
    const playerGoldRef = ref(database, `players/${nickname}/gold`);
    return set(playerGoldRef, gold).then(() => {
        console.log(`Gold saved to database: ${gold}`);
    }).catch((error) => {
        console.error('Error saving gold to database:', error);
        throw error;
    });
}

function updateHeroElement(hero, heroDiv) {
    console.log(`Обновление элемента героя ${hero.name}: уровень ${hero.level}, урон ${hero.damage}, стоимость ${hero.cost}`);
    heroDiv.querySelector('p:nth-child(3)').textContent = `Ур.: ${hero.level}`;
    heroDiv.querySelector('p:nth-child(4)').textContent = `Урон: ${hero.damage}`;
    heroDiv.querySelector('p:nth-child(5)').textContent = `Стоимость: ${hero.cost}`;
    console.log(`Элемент героя ${hero.name} обновлен в интерфейсе: уровень ${heroDiv.querySelector('p:nth-child(3)').textContent}, урон ${heroDiv.querySelector('p:nth-child(4)').textContent}, стоимость ${heroDiv.querySelector('p:nth-child(5)').textContent}`);
}
window.updateHeroElement = updateHeroElement;





// Функция для обновления суммарного урона
function updateTotalDamage() {
    totalDamage = calculateTotalDamage();
    const totalDamageElement = document.getElementById('totalDamage');
    if (totalDamageElement) {
        totalDamageElement.textContent = `Суммарный урон: ${totalDamage}`;
    }


}
window.updateTotalDamage = updateTotalDamage;


function calculateHeroStats(level, baseDamage, baseCost) {
    const damageMultiplier = 2; // Множитель для урона
    const costMultiplier = 2.4; // Множитель для стоимости
    const newDamage = Math.floor(baseDamage * Math.pow(damageMultiplier, level - 1));
    const newCost = Math.floor(baseCost * Math.pow(costMultiplier, level - 1));
    console.log(`Расчет новых значений для уровня ${level}: урон ${newDamage}, стоимость ${newCost}`);
    return { newDamage, newCost };
}
window.calculateHeroStats = calculateHeroStats;





import { initializeApp } from "https://www.gstatic.com/firebasejs/9.8.4/firebase-app.js";
import { getDatabase, ref, set, get, child, runTransaction, onValue, push, off, remove } from "https://www.gstatic.com/firebasejs/9.8.4/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCPQFqbWCL3XaM-sLYDWgWMdslhS7O7WC8",
            authDomain: "game-7bdb0.firebaseapp.com",
            databaseURL: "https://game-7bdb0-default-rtdb.firebaseio.com",
            projectId: "game-7bdb0",
            storageBucket: "game-7bdb0.appspot.com",
            messagingSenderId: "327382187542",
            appId: "1:327382187542:web:cc82e8673791983404bf37",
            measurementId: "G-8JBZ9PEV84"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        window.currentSessionId = null;

function startSession(nickname) {
    const sessionId = generateSessionId();
    set(ref(database, 'players/' + nickname + '/session'), sessionId);
    return sessionId;
}










async function saveProgress() {
    if (!nickname || !currentSessionId) {
        console.error('Cannot save progress: no nickname or session ID');
        return;
    }

    //  Подготовка данных  для сохранения
    const progressData = {
        currentLevel: currentLevel,
        gold: gold,
        playerHealth: playerHealth,
        weaponPower: weaponPower,
        weaponName: weaponName,
        weaponLevel: weaponLevel || 0,
        heroes: heroes.map(hero => ({
            name: hero.name, 
            level: hero.level,
            hired: hero.hired, 
            skill: {
                ...hero.skill,
                //  Сохраняем оставшееся  время  cooldown  
                remainingCooldown: hero.skill.onCooldown ? Math.max(0, hero.skill.activationTime + hero.skill.cooldown * 1000 - Date.now()) : 0  
            }
        })), 
        levels: levels,
        session: currentSessionId,
        monsterHealth: monsterHealth,
        rewardMultiplier: rewardMultiplier,
        rebornCount: rebornCount,
        currentClan: currentClan, 
        chaosEssence: chaosEssence,
        talents: talents,
        dailyQuests: questCategories 
    };
    console.log('Saving progress:', progressData);
    try {
        const dbRef = ref(database, `players/${nickname}/progress`);
        const sessionRef = ref(database, `players/${nickname}/session`);
        const sessionSnapshot = await get(sessionRef);
        if (sessionSnapshot.val() !== currentSessionId) {
            console.log(`Session mismatch, progress not saved. Current session: ${currentSessionId}, Server session: ${sessionSnapshot.val()}`);
            alert('Сессия изменилась. Прогресс не сохранен.');
            return;
        }
        await set(dbRef, progressData);
        console.log('Data saved successfully:', progressData);
    } catch (error) {
        console.error('Error saving progress:', error);
    }
}

window.saveProgress = saveProgress;








function savePlayerData() {
    if (nickname && currentSessionId) {
        saveProgress(nickname, currentSessionId, {
            currentLevel,
            gold,
            playerHealth,
            weaponPower,
            weaponName,
            weaponLevel,
            levels,
            heroes // Сохранение данных о героях
        });
    }
}



function validateData(data) {
    if (!data || typeof data !== 'object') return false;
    if (!Array.isArray(data.heroes)) return false;
    return true;
}


// Загрузка прогресса игрока
async  function loadProgress(nickname)  {
    if  (!nickname) {
        console.error('Cannot  load progress: no  nickname'); 
        return;
    }

    try  { 
        const dbRef  =  ref(database,  `players/${nickname}/progress`); 
        const  snapshot  = await get(dbRef);
        if (snapshot.exists())  {
            const data  = snapshot.val(); 
            console.log('Loaded  progress:', data);

            //  Миграция  данных героев
            data.heroes =  migrateHeroData(data.heroes); 

            //  Загружаем  данные  ежедневных заданий
            if (data.dailyQuests)  {
                questCategories =  data.dailyQuests;
            }

            //  Применяем загруженные  данные  
            applyProgress(data); 

            //  Сохраняем прогресс 
            saveProgress();

    // Загружаем данные  о кланах  после загрузки  прогресса  игрока
    const  clansSnapshot =  await get(ref(database, 'clans')); 
    if (clansSnapshot.exists()) {
        clans =  clansSnapshot.val();
    } else {
        clans = {};
    }

    //  Вызываем  resetClanIfInvalid  после  загрузки  clans
    await resetClanIfInvalid(nickname,  data); // Передаем  data
            

            
            // Проверяем  нахождение  игрока  в  клане
            await isPlayerInClan(nickname); //  Устанавливаем  currentClan
            
            return data;
        } else {
            console.log('No progress found for', nickname);
            return null;
        }
    } catch (error) {
        console.error('Error loading progress:', error);
        return null;
    }
}


window.loadProgress = loadProgress;




// Функция для применения загруженного прогресса
function applyProgress(data) {
    if (data && validateData(data)) {
        console.log('Applying progress:', data);
        console.log(`Gold before applying progress: ${gold}`);
        
        currentLevel = data.currentLevel;
        gold = data.gold;
        playerHealth = data.playerHealth;
        weaponPower = data.weaponPower;
        weaponName = data.weaponName;
        weaponLevel = data.weaponLevel || 0;
        rebornCount = data.rebornCount || 0; 
        rewardMultiplier = data.rewardMultiplier || 1;
        chaosEssence = data.chaosEssence || 0;
        talents = data.talents ||  talents;
        //  Проверяем  наличие baseBonus  
        talents.resilience.baseBonus =  1500;  //  Или  любое  другое  значение,  которое  вы  хотите  установить
    playerHealth = calculateTotalHealth();  // Пересчитываем здоровье
        //  Миграция  данных  героев  
        heroes = migrateHeroData(data.heroes);  
        
        heroes = data.heroes.map(hero => {
            const baseDamage = hero.baseDamage !== undefined ? hero.baseDamage : 0;
            const baseCost = hero.baseCost !== undefined ? hero.baseCost : 0; 
            const level = hero.level || 1; 
            // Обновляем название  скилла,  если  необходимо 
            if (hero.skill) {
                const newSkillName = allHeroes.find(h => h.name === hero.name)?.skill.name;
                if (newSkillName) {
                    hero.skill.name = newSkillName; 
                }
            }
            //  Проверка  наличия  activationTime  и  расчет  onCooldown
            if (hero.skill && hero.skill.remainingCooldown > 0) { 
                hero.skill.onCooldown = true;
                hero.skill.activationTime = Date.now() - (hero.skill.cooldown * 1000 - hero.skill.remainingCooldown);  
                setTimeout(() => { 
                    hero.skill.onCooldown = false;
                    delete hero.skill.activationTime;

                    const heroDiv = document.querySelector(`.hero[alt="${hero.name}"]`);
                    if (heroDiv) {
                        const skillButton = heroDiv.querySelector('.skill-button'); 
                        if (skillButton) {
                            skillButton.disabled = false; 
                        }
                    }
                    //  3.  Обновляем  кнопку  в книге  скиллов  
                    const bookButton = document.querySelector(`#skillButtonsContainer img[alt="${hero.skill.name}"]`);
                    if (bookButton) { 
                        bookButton.disabled = true;  
                        bookButton.classList.add('onCooldown');  
                    } 
                }, hero.skill.remainingCooldown); 
            } else {
                hero.skill.onCooldown = false; 
            } 

            return { 
                ...hero,
                baseDamage: baseDamage,
                baseCost: baseCost,
                cost: isNaN(hero.cost) || hero.cost === undefined ? baseCost : hero.cost,
                damage: isNaN(hero.damage) || hero.damage === undefined ? calculateHeroStats(level, baseDamage, baseCost).newDamage : hero.damage, 
                level: level
            }; 
        });

        levels = data.levels || levels; // Исправлено:  используем let
        monsterHealth = data.monsterHealth || baseMonsterHealth; 

        // Проверка на наличие данных о клане
        if (data.currentClan) { 
            currentClan  =  data.currentClan;
        }

        //  Обновляем  ссылки на  объекты quest в questCategories
        if (data.dailyQuests)  { 
            for (const  category  in data.dailyQuests)  {
                questCategories[category]  =  data.dailyQuests[category].map((loadedQuest, index) => { 
                    // Если  квест  уже существует,  обновляем его данные
                    if  (questCategories[category][index])  {
                        return { ...questCategories[category][index],  ...loadedQuest }; 
                    }  else  { 
                        // Если квеста нет, добавляем его 
                        return loadedQuest; 
                    } 
                });
            } 
        } 

        // Проверяем  наличие  новой  категории  у старых  игроков 
        if (!data.dailyQuests  || !data.dailyQuests['Перерождения'])  {
            // Если категория  отсутствует,  добавляем ее
            questCategories['Перерождения']  = [
                { description:  'Переродиться  1  раз', goal: 1,  progress: 0,  reward:  2000,  completed:  false,  claimed: false },
                { description:  'Переродиться  3 раза', goal:  3,  progress: 0,  reward: 20000,  completed: false,  claimed: false  },
                { description:  'Переродиться  5 раз', goal:  5, progress: 0,  reward: 100000, completed: false,  claimed: false  } 
            ]; 
            console.log('Добавлена  новая категория  "Перерождения" для старого  игрока');
        }

        // Добавляем новую категорию заданий, если ее нет  у старых  игроков 
        if (!data.dailyQuests  ||  !data.dailyQuests['Убийство редких монстров'])  {
            questCategories['Убийство редких монстров'] =  [
                { description: 'Победить 1 Эпического монстра',  goal: 1,  progress: 0, reward: 1000,  completed: false, claimed:  false },
                { description: 'Победить 2  Эпических монстров',  goal:  2,  progress:  0, reward:  5000,  completed:  false, claimed:  false  },
                { description: 'Победить 3  Эпических монстров',  goal:  3,  progress: 0, reward: 10000, completed: false,  claimed: false  }, 
                { description: 'Победить  4 Эпических  монстров',  goal:  4,  progress: 0, reward: 20000,  completed:  false, claimed:  false }, 
                { description: 'Победить  5  Эпических  монстров',  goal: 5, progress: 0, reward:  50000, completed:  false,  claimed:  false  }
            ]; 
            console.log("Добавлена  новая категория  заданий для старого  игрока.");
        }

        console.log(`Gold after applying  progress:  ${gold}`);
        console.log(`currentClan  after applying progress:  ${currentClan}`);

        updateCharacterMenu();  
        addHeroesToMenu();
        updateTotalDamage(); 
        updateStatusBar();
    } 
}


window.applyProgress = applyProgress;





async function startGame() {
    const input = document.getElementById('nicknameInput').value;
    console.log(`Nickname entered: ${input}`);
    if (input) {
        nickname = input;
        const dbRef = ref(database, `players/${nickname}/session`);
    // Показать индикатор загрузки (например,  spinner или  текст)
    document.getElementById('nicknameInput').disabled =  true; //  Отключить  ввод  
    document.getElementById('startGameButton').disabled = true; //  Отключить кнопку
    document.body.style.cursor  =  'wait'; 
    displayLoadingIndicator(); 
        try {
            const sessionSnapshot = await get(dbRef);
            if (sessionSnapshot.exists()) {
                const existingSessionId = sessionSnapshot.val();
                console.log(`Existing session found for ${nickname}: ${existingSessionId}`);
                await endSession(nickname, existingSessionId);
            } else {
                console.log(`No existing session found for ${nickname}`);
            }

            const newSessionId = generateSessionId();
            await set(dbRef, newSessionId);
            currentSessionId = newSessionId;
            console.log(`New session started for ${nickname}: ${newSessionId}`);
            watchSessionChanges();
            listenForOpponent();

            // Загружаем прогресс игрока и применяем миграцию данных 
            let progressData = await loadProgress(nickname);

            // Если прогресс не найден, создаем новую запись для игрока
            if (!progressData) {
                // Устанавливаем начальное количество золота для нового игрока
                const playerGoldRef = ref(database, `players/${nickname}/gold`);
                await set(playerGoldRef, 100); 
                console.log('Initial gold set to 100 for new player');

                //  Создаем  пустую  запись прогресса  
                progressData = { currentClan: null };  
                applyProgress(progressData);
                await saveProgress();
            }

            continueGameSetup();
            //await updateClanList(); 
        } catch (error) {
            console.error('Error starting new session:', error);
        }finally {
        // Скрыть индикатор  загрузки  независимо от  результата 
        hideLoadingIndicator();
        document.getElementById('nicknameInput').disabled  =  false; 
        document.getElementById('startGameButton').disabled  =  false;  
        document.body.style.cursor = 'default'; 
    }
    } else {
        alert('Пожалуйста, введите никнейм.');
    }
}
window.startGame = startGame; 


// Функции для отображения/скрытия  индикатора  загрузки 
function displayLoadingIndicator() {
    // Создать  элемент  индикатора  и добавить его  в  DOM 
    const loadingIndicator = document.createElement('div');
    loadingIndicator.id = 'loadingIndicator'; 
    loadingIndicator.textContent = 'Загрузка...'; 
    document.body.appendChild(loadingIndicator); 
}

function hideLoadingIndicator() {
    //  Удалить  индикатор  из DOM 
    const loadingIndicator  = document.getElementById('loadingIndicator'); 
    if (loadingIndicator) { 
        document.body.removeChild(loadingIndicator); 
    } 
}

async function continueGameSetup() {
    const data = await loadProgress(nickname);
    console.log(`Data loaded: ${JSON.stringify(data)}`);
    applyProgress(data);

    document.getElementById('nicknameMenu').style.display = 'none';
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('bottomMenu').style.display = 'flex';
    document.getElementById('leftCharacterMenu').style.display = 'block'; 
    document.getElementById('chatContainer').style.display = 'flex';

    currentScreen = 'dungeon';
    console.log(`Screen set to: ${currentScreen}`);

    if (data && data.levels) {
        levels = data.levels;
    }
    await resetDailyQuests(); //  Проверяем  и  сбрасываем  задания,  если  необходимо
    initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
    drawMenu();
    changeScreen('dungeon');
    updateStatusBar();
    duplicateSkillButtons();

    // Проверяем нахождение игрока в клане ПОСЛЕ загрузки прогресса
    if (await isPlayerInClan(nickname)) {
        console.log('Игрок в клане:', currentClan);
        listenForClanMessages(currentClan);
        switchChat('clan'); //  Переключаем  на клановый чат
    } else {
        console.log('Игрок не в клане.');
        listenForGlobalMessages();
        switchChat('global'); // Переключаем на глобальный  чат
    }
} 
window.continueGameSetup = continueGameSetup;









function updateHeroCost(hero, heroDiv) {
    const stats = calculateHeroStats(hero.level + 1, hero.baseDamage, hero.baseCost);
    const upgradeCost = stats.newCost;
    heroDiv.querySelector('p:nth-child(5)').textContent = `Стоимость: ${upgradeCost}`;
    hero.cost = upgradeCost; // Обновляем стоимость героя
}
window.updateHeroCost = updateHeroCost;



// Установка начального состояния автобоя
let isAutoHitting = true; // Автобой включен по умолчанию
let autoHitInterval;

function startAutoHit() {
    if (isAutoHitting) {
        autoHitInterval = setInterval(() => {
            if (currentScreen === 'battle') {
                hitMonster({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
            }
        }, 300);
    }
}
window.startAutoHit = startAutoHit;
function stopAutoHit() {
    clearInterval(autoHitInterval);
}
window.stopAutoHit = stopAutoHit;
function toggleAutoboy() {
    if (isAutoHitting) {
        stopAutoHit();
        isAutoHitting = false;
        document.getElementById('toggleAutoboyButton').textContent = 'Включить автобой';
    } else {
        isAutoHitting = true;
        startAutoHit();
        document.getElementById('toggleAutoboyButton').textContent = 'Отключить автобой';
    }
}
window.toggleAutoboy = toggleAutoboy;
// Запуск автобоя при загрузке страницы
window.addEventListener('load', startAutoHit);


function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        window.toggleFullscreen = toggleFullscreen;

        function toggleMailWindow() {
    const mailWindow = document.getElementById('mailWindow');
    if (mailWindow.style.display === 'block') {
        mailWindow.style.display = 'none';
    } else {
        mailWindow.innerHTML = ''; // Очищаем содержимое перед загрузкой новой почты
        loadMail();
        mailWindow.style.display = 'block';
    }
}
window.toggleMailWindow = toggleMailWindow;


const characterImages = [
    'peasant.png',     // 0-9 уровень
    'warrior.png',     // 10-19 уровень
    'knight.png',      // 20-29 уровень
    'mage.png',        // 30-39 уровень
    'archer.png',      // 40-49 уровень
    'paladin.png',     // 50-59 уровень
    'barbarian.png',   // 60-69 уровень
    'assassin.png',    // 70-79 уровень
    'samurai.png',     // 80-89 уровень
    'dragon_knight.png' // 90-99 уровень
];

function updateCharacterImage() {
    const index = Math.floor(currentLevel / 10);
    const imageIndex = index < characterImages.length ? index : characterImages.length - 1;
    document.getElementById('characterImage').src = characterImages[imageIndex];
}
window.updateCharacterImage = updateCharacterImage;



function getMonsterImage(level) {
    if (level >= 90) {
        return monsterImages[monsterImages.length - 1];
    }
    const index = Math.floor(level / 10);
    return monsterImages[index % monsterImages.length];
}

window.getMonsterImage = getMonsterImage;

function updateMonsterImage(level) {
  let imageSrc;
  if (isRareMonsterEncountered) { 
    const randomIndex = Math.floor(Math.random() * rareMonsterImages.length); 
    imageSrc = rareMonsterImages[randomIndex];
  } else {
    imageSrc = getMonsterImage(level);
  }
  monsterImage.src = imageSrc;
  console.log(`Updated monster image to: ${imageSrc} for level ${level}`);
}
window.updateMonsterImage = updateMonsterImage;


        function updateTopPlayers(nickname, playerData) {
            set(ref(database, 'topPlayers/' + nickname), playerData);
        }

        function displayTopPlayers() {
    const dbRef = ref(database);
    return get(child(dbRef, 'topPlayers')).then((snapshot) => {
        if (snapshot.exists()) {
            const topPlayers = snapshot.val();
            // Преобразование объекта в массив и сортировка по уровню
            const sortedPlayers = Object.values(topPlayers).sort((a, b) => b.level - a.level);
            
            let topListHTML = '<h2>Топ игроки</h2>';
            sortedPlayers.forEach(player => {
                topListHTML += `<p>${player.nickname} - Уровень ${player.level}</p>`;
            });
            document.getElementById('topPlayersMenu').innerHTML = topListHTML;
            return topPlayers;
        } else {
            console.log("No data available");
            return {};
        }
    }).catch((error) => {
        console.error(error);
    });
}

let rebornCount = 0; // Переменная для отслеживания количества перерождений
        let nickname = '';
        let currentSessionId = null;
        
        let currentLevel = 1;
        let gold = 100;
        
        let weaponPower = 10;
        let weaponName = 'Кулаки';
        let weaponLevel = 0;
        const monsterMessages = ["Не бейте меня", "За что мне это все ?? ", "как честный человек, ты должен на мне жениться ", "я не буду больше читерить", "простите я просто сплю с админами :( )"];

        const monsterImages = [
            'monster1.png',
            'monster2.png',
            'monster3.png',
            'monster4.png',
            'monster5.png',
            'monster6.png',
            'monster7.png',
            'monster8.png',
            'monster9.png',
            'monster10.png'
        ];


let playersDamage = {};
let isUpdating = false;



        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let currentScreen = 'menu';
            let hits = 0;
            let baseMonsterHealth = 100; // Установите это значение на начальное здоровье монстра
            let monsterHealth = baseMonsterHealth;
            let levels = new Array(10000).fill().map((_, i) => ({ number: i + 1, stars: 0, completed: false }));


        const backgroundImage = new Image();
        backgroundImage.src = 'background.png';
        const castle = new Image();
        castle.src = 'castle.png';
        const arena2 = new Image();
        arena2.src = 'arena.png';
        const dungeonGateImage = new Image();
        dungeonGateImage.src = 'dung.png';
        const monsterImage = new Image();
        //monsterImage.src = 'mob.png';
        const mapImage = new Image();
        mapImage.src = 'map.png';
        const starImage = new Image();
        starImage.src = 'star.png';
        const peasantWithSwordImage = 'peasant_with_sword.png';
        const battleBackgroundImage = new Image();
        battleBackgroundImage.src = 'fon2.png';






        starImage.onload = function() {
            drawLevelMap();
        };
        
        // Crosshair logic
        const crosshair = document.getElementById('crosshair');
        document.addEventListener('mousemove', (event) => {
    if (currentScreen === 'battle') {
        crosshair.style.left = `${event.clientX}px`;
        crosshair.style.top = `${event.clientY}px`;
    } else {
        crosshair.style.display = 'none'; // Скрываем прицел, если не в режиме "battle"
    }
});









        window.showHitAnimation = showHitAnimation;

        function showMonsterMessage() {
            const message = monsterMessages[Math.floor(Math.random() * monsterMessages.length)];
            const monsterMessage = document.getElementById('monsterMessage');
            monsterMessage.textContent = message;
            monsterMessage.style.display = 'block';
            setTimeout(() => {
                monsterMessage.style.display = 'none';
            }, 500);
        }
        window.showMonsterMessage = showMonsterMessage;
      
        function drawStars(x, y, count) {
    //console.log(`Drawing ${count} stars at (${x}, ${y})`);
    for (let i = 0; i < count; i++) {
        ctx.drawImage(starImage, x + i * 30, y, 20, 20);
    }
}
        window.drawStars = drawStars;

        // function toggleShop() {
        //     const shopMenu = document.getElementById('shopMenu');
        //     shopMenu.style.display = shopMenu.style.display === 'block' ? 'none' : 'block';
        //     updateShop();
        // }
        // window.toggleShop = toggleShop; // Добавляем в глобальную область видимости

        function drawShop() {
            document.getElementById('shopGold').textContent = gold;
        }
        window.drawShop = drawShop;



        function updateGold(amount) {
    return new Promise((resolve, reject) => {
        console.log(`Updating gold: current gold = ${gold}, new gold = ${amount}`);
        gold = amount;
        document.getElementById('statusGold').textContent = gold;
        const playerGoldRef = ref(database, `players/${nickname}/gold`);
        set(playerGoldRef, gold).then(() => {
            console.log(`Gold updated in database: ${gold}`);
            resolve();
        }).catch((error) => {
            console.error('Error updating gold:', error);
            reject(error);
        });
    });
}


window.updateGold = updateGold;



async function endSession(nickname, sessionId) {
    const dbRef = ref(database, `players/${nickname}/session`);
    console.log(`В endSession, nickname: ${nickname}, sessionid: ${sessionId}`);
    try {
        const result = await runTransaction(dbRef, (currentSession) => {
            if (currentSession === null) {
                console.log(`No session to end for ${nickname}.`);
                return null; // Ignore if there's no session
            }
            if (currentSession === sessionId) {
                console.log(`Ending session ${sessionId} for ${nickname}`);
                return null;
            } else {
                console.error(`Session mismatch during transaction: currentSession=${currentSession}, sessionId=${sessionId}`);
                throw new Error("Session mismatch");
            }
        });
        if (result.committed) {
            console.log(`Session ${sessionId} for ${nickname} ended successfully`);
            currentSessionId = null;
        } else {
            console.log(`Session ${sessionId} for ${nickname} was not ended`);
        }
    } catch (error) {
        console.error('Error ending session:', error);
    }
}
window.endSession = endSession;

function watchSessionChanges() {
    const dbRef = ref(database, `players/${nickname}/session`);
    onValue(dbRef, (snapshot) => {
        const sessionId = snapshot.val();
        if (sessionId !== currentSessionId && sessionId !== null) {
            console.log(`Session changed from ${currentSessionId} to ${sessionId}`);
            alert('Вы были выброшены из игры, так как сессия была начата с другого устройства или вкладки.');
            endCurrentSession();
            location.reload();  // Перезагрузка страницы для выхода из игры
        }
        
    });
}
window.watchSessionChanges = watchSessionChanges;

function generateSessionId() {
    return Math.random().toString(36).substr(2, 9);
}

function endCurrentSession() {
    if (nickname && currentSessionId) {
        endSession(nickname, currentSessionId);
    }
}
window.endCurrentSession = endCurrentSession;




function hideRebornPrompt() {
    document.getElementById('rebornPrompt').style.display = 'none';
}






window.showRebornPrompt = showRebornPrompt;
window.hideRebornPrompt = hideRebornPrompt;



function sendRewards() {
    const sortedPlayers = Object.entries(playersDamage).sort(([, damageA], [, damageB]) => damageB - damageA);
    const rewards = {
        top3: 10000,
        top10: 1000
    };

    sortedPlayers.forEach(([player, damage], index) => {
        let reward = 0;
        if (index < 3) {
            reward = rewards.top3;
        } else if (index < 10) {
            reward = rewards.top10;
        }
        if (reward > 0) {
            sendMail(player, reward, index + 1, damage);
            console.log(`Reward sent to player ${player}: ${reward} gold for rank ${index + 1} with damage ${damage}`);
        }
    });

    // Обнуление рейтинга
    playersDamage = {};
    syncPlayersDamage();
}
window.sendRewards = sendRewards;


function sendMail(player, reward, rank, damage) {
    const mailMessage = `Поздравляем! Вы заняли ${rank}-е место в рейтинге с уроном ${damage}. Ваша награда: ${reward} золота.`;
    const playerMailRef = ref(database, `players/${player}/mail`);
    console.log(`Preparing to send mail to ${player}: ${mailMessage}`);
    get(playerMailRef).then((snapshot) => {
        let playerMail = snapshot.val() || {};
        // Проверка на существование аналогичного письма
        const existingMail = Object.values(playerMail).find(mail => mail.message === mailMessage);
        if (existingMail) {
            console.log(`Mail already exists for player ${player}: ${mailMessage}`);
            return;
        }
        const mailId = `mail_${Date.now()}`;
        playerMail[mailId] = {
            reward: reward,
            message: mailMessage,
            timestamp: Date.now()
        };
        set(playerMailRef, playerMail).then(() => {
            console.log(`Mail sent to player ${player}: ${mailMessage}`);
        }).catch((error) => {
            console.error('Error setting mail data:', error);
        });
    }).catch((error) => {
        console.error('Error getting mail data:', error);
    });
}
window.sendMail = sendMail;





function loadMail() {
    const mailWindow = document.getElementById('mailWindow');
    mailWindow.innerHTML = '<h2>Ваша почта</h2><div id="mailContent"></div><button onclick="toggleMailWindow()">Закрыть</button>';
    const mailContent = document.getElementById('mailContent');
    const playerMailRef = ref(database, `players/${nickname}/mail`);
    console.log(`Loading mail for player ${nickname}`);
    get(playerMailRef).then((snapshot) => {
        const mailsObject = snapshot.val() || {};
        console.log('Mails Object:', mailsObject);
        const mails = Object.entries(mailsObject); // Преобразуем объект в массив [ключ, значение]
        mails.forEach(([mailId, mail]) => {
            const mailItem = document.createElement('div');
            console.log('Mail Item:', mail);
            mailItem.innerHTML = `
                <p>${mail.message}</p>
                <p>Награда: ${mail.reward} золота</p>
                <button onclick="claimReward('${mailId}', ${mail.reward})">Получить награду</button>
            `;
            mailContent.appendChild(mailItem);
        });
    }).catch((error) => {
        console.error('Error loading mail:', error);
    });
}
window.loadMail = loadMail;

function claimReward(mailId, reward) {
    const playerMailRef = ref(database, `players/${nickname}/mail/${mailId}`);
    const playerGoldRef = ref(database, `players/${nickname}/gold`);

    // Получаем текущее количество золота
    get(playerGoldRef).then((snapshot) => {
        let currentGold = snapshot.val() || 0;
        let newGold = currentGold + reward;
        updateGold(newGold);  // Используем updateGold

        // Удаляем письмо
        set(playerMailRef, null).then(() => {
            console.log(`Mail ${mailId} deleted`);

            // Перезагружаем почту
            loadMail();
            saveProgress(); // Сохраняем прогресс
            updateStatusBar(); // Обновляем статус бар
        }).catch((error) => {
            console.error('Error deleting mail:', error);
        });
    }).catch((error) => {
        console.error('Error getting current gold:', error);
    });
}

window.claimReward = claimReward;



function spendGold(amount) {
    const playerGoldRef = ref(database, `players/${nickname}/gold`);
    console.log("questCategories:", questCategories);

    get(playerGoldRef).then((snapshot) => {
        let currentGold = snapshot.val() || 0;
        if (currentGold >= amount) {
            updateGold(currentGold - amount);

            set(playerGoldRef, currentGold - amount).then(() => {
                console.log(`Gold spent: ${amount}, remaining gold: ${currentGold - amount}`);

                // Обновление прогресса ежедневных заданий на трату золота
                questCategories['Трата золота'].forEach(quest => {
                    if (!quest.completed && !quest.claimed) {
                        quest.progress += amount;
                        if (quest.progress >= quest.goal) {
                            quest.completed = true;
                            showGameMessage(`Задание "${quest.description}" выполнено!`);
                        }
                    }
                });

                // Обновляем глобальную переменную золота
                gold = currentGold - amount;

                document.getElementById('statusGold').textContent = gold;
                saveProgress();
                updateStatusBar();
            }).catch((error) => {
                console.error('Error updating gold:', error);
            });
        } else {
            console.log('Not enough gold to spend.');
            showGameMessage('Недостаточно золота!');
        }
    })
    .catch((error) => {
        console.error('Error getting current gold:', error);
    });
}
window.spendGold = spendGold;





function startWorldBossTimer() {
    worldBossTimerInterval =  setInterval(updateWorldBossTimer, 1000);
}





function resetWorldBossHealth() {
  //  Если босс уже был убит хотя бы раз, увеличиваем его здоровье
  if (worldBossWasKilled) {
    worldBossMaxHealth *= 1.2; // Увеличиваем максимальное здоровье на 20% 
    showGameMessage("Мировой босс стал сильнее! Его здоровье увеличено на 20%.");
  }

  worldBossHealth = worldBossMaxHealth; // Устанавливаем текущее здоровье равным максимальному
  worldBossWasKilled = false; // Сбрасываем флаг 

  // Скрываем таймер и показываем полоску здоровья
  document.getElementById('worldBossTimer').style.display = 'none'; 
  document.getElementById('monsterHealthContainer').style.display = 'block';

  // Устанавливаем isAlive в true в базе данных
  const worldBossRef = ref(database, 'worldBoss');
  set(worldBossRef, {
    health: worldBossHealth, 
    rebornTime: null,
    isAlive: true
  });

  syncWorldBossHealth();
  console.log("World Boss Health has been reset to", worldBossHealth);
  updateWorldBossHealthDisplay();
  drawWorldBossBattle(); 
}


function getTimeUntilNextHour() {
    const now = new Date();
    const nextHour = new Date(now.getTime() + (60 - now.getMinutes()) * 60 * 1000);
    nextHour.setMinutes(0, 0, 0);
    return nextHour - now;
}
function startHourlyReset() {
    const timeUntilNextHour = getTimeUntilNextHour();
    
    // Запускаем таймер, который сбросит здоровье в начале следующего часа
    setTimeout(() => {
        resetWorldBossHealth();
        
        // После сброса здоровья запускаем интервал на каждый час
        setInterval(resetWorldBossHealth, 3600000);
    }, timeUntilNextHour);
}




 

        function buyWeapon(type, power, cost) {
            if (gold >= cost) {
                weaponPower = power;
                updateGold(gold - cost);  // Используем updateGold
                weaponLevel = 1;
                if (type === 'sword') {
                    weaponName = 'Меч';
                    document.getElementById('characterImage').src = peasantWithSwordImage;
                }
                updateCharacterMenu();
                updateShop();
                saveProgress(nickname, {
                    currentLevel,
                    gold,
                    playerHealth,
                    weaponPower,
                    weaponName,
                    weaponLevel
                });
            }
        }

        window.buyWeapon = buyWeapon;

        function upgradeWeapon(type, costPerLevel) {
            if (gold >= costPerLevel && weaponName === 'Меч') {
                weaponPower += 15;
                updateGold(gold - costPerLevel);  // Используем updateGold
                weaponLevel++;
                updateCharacterMenu();
                updateShop();
                saveProgress(nickname, {
                    currentLevel,
                    gold,
                    playerHealth,
                    weaponPower,
                    weaponName,
                    weaponLevel
                });
            }
        }

        window.upgradeWeapon = upgradeWeapon;

        function continueGame() {
    // document.getElementById('shopMenu').style.display = 'none';
    if (currentLevel < 10000) {
        currentLevel++;
        initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
        startLevel(currentLevel);
    } else {
        currentScreen = 'victory';
        drawVictoryScreen();
    }
    updateTopPlayers(nickname, { nickname, level: currentLevel });
    drawLevelMap();
}


        window.continueGame = continueGame;

        function getHealthColor(percentage) {
    let color;
    if (percentage > 50) {
        color = 'green';
    } else if (percentage > 20) {
        color = 'yellow';
    } else {
        color = 'red';
    }
   // console.log(`Health percentage: ${percentage}, Color: ${color}`);
    return color;
}

function updateMonsterHealthDisplay() {
    const healthBar = document.getElementById('monsterHealthBar');
    const healthValue = document.getElementById('monsterHealthValue');

    if (healthBar) {
        let currentHealth, maxHealth;
        
        if (currentScreen === 'worldBoss') {
            currentHealth = worldBossHealth;
            maxHealth = 1000000;  // Максимальное здоровье мирового босса
        } else if (isRareMonsterEncountered) {  // *** Проверка на редкого монстра ***
            currentHealth = monsterHealth;
            maxHealth = baseMonsterHealth * Math.pow(1.1, currentLevel - 1) * 2; // Максимальное здоровье редкого монстра
        } else {
            currentHealth = monsterHealth;
            maxHealth = baseMonsterHealth * Math.pow(1.1, currentLevel - 1);
        }

        const healthPercentage = (currentHealth / maxHealth) * 100; 
        const color = getHealthColor(healthPercentage);
        healthBar.style.width = `${Math.min(healthPercentage, 100)}%`;
        healthBar.style.backgroundColor = color; 
    }

    if (healthValue) {
        if (currentScreen === 'worldBoss')  {
            healthValue.textContent = worldBossHealth.toFixed(0);
        }  else {
            healthValue.textContent = monsterHealth.toFixed(0);
        }
    }
}
window.updateMonsterHealthDisplay =  updateMonsterHealthDisplay;

window.getHealthColor = getHealthColor;


function drawArena() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); //  Очищаем  холст
    ctx.drawImage(arena2, 0, 0, canvas.width, canvas.height);  //  Рисуем  арену 
    
}
window.drawArena  =  drawArena;


function switchChat(chat) {
    //  Если  игрок не  в  клане,  принудительно переключаемся  на  глобальный  чат 
    if (!currentClan)  { 
        chat = 'global';
    }

    currentChat = chat;
    const chatMessages = document.getElementById('chatMessages');
    chatMessages.innerHTML = ''; // Очищаем сообщения 

    // Отписываемся от предыдущего  слушателя 
    if (globalChatListener) {
        off(ref(database, 'chat/messages'), globalChatListener);
        globalChatListener = null;  // Сбрасываем ссылку 
        console.log('Отключен  слушатель глобального  чата.'); 
    }
    if (clanChatListener)  {
        off(ref(database, `clans/${currentClan}/chat`),  clanChatListener);
        clanChatListener  =  null; //  Сбрасываем  ссылку 
        console.log('Отключен слушатель  кланового  чата.'); 
    }

    // Подписываемся  на соответствующий чат  в Firebase
    if (chat  === 'global')  { 
        console.log("Переключение  на  глобальный чат"); 
        globalChatListener  =  onValue(ref(database, 'chat/messages'), function(snapshot) {
            displayMessages(snapshot); 
        });
    }  else if  (chat  ===  'clan'  && currentClan)  { 
        console.log("Переключение  на клановый  чат:", currentClan);
        clanChatListener  = onValue(ref(database, `clans/${currentClan}/chat`), function(snapshot) {
            displayMessages(snapshot);
        });
    }  else  if (chat  ===  'clan' && !currentClan)  { 
        console.log("Попытка  переключения  на клановый  чат,  но игрок  не  в  клане.");
        displayChatMessage({ 
            nickname: 'System', 
            text:  'Вы не  состоите  в клане!' 
        }); 
    } 
}
window.switchChat = switchChat;

// Функция для прослушивания сообщений глобального чата
function listenForGlobalMessages() {
    off(ref(database,  'chat/messages')); //  Отключаем предыдущие  слушатели 
    onValue(ref(database, 'chat/messages'), function(snapshot) {
        displayMessages(snapshot);
    }); 
}


//  Функция для прослушивания  сообщений кланового  чата
function listenForClanMessages(clanName) {
    off(ref(database,  'chat/messages')); //  Отключаем предыдущие  слушатели
    const clanChatRef = ref(database,  `clans/${clanName}/chat`); 
    onValue(clanChatRef, function(snapshot) {
        displayMessages(snapshot);
    }); 
}

//  Функция для  отображения  сообщений
function displayMessages(snapshot) {
    const chatMessages = document.getElementById('chatMessages'); 
    chatMessages.innerHTML = ''; 
    snapshot.forEach(function(childSnapshot) {
        const message = childSnapshot.val();
        const messageElement = document.createElement('div'); 
        messageElement.innerHTML = `<strong>${message.nickname}:</strong> ${message.text}`;
        chatMessages.appendChild(messageElement); 
    }); 
    chatMessages.scrollTop = chatMessages.scrollHeight; //  Прокрутка вниз  
}



async function updateClanMemberData(memberNickname, data) {
    if (currentClan && memberNickname in clans[currentClan].members) {
        // Обновляем данные участника клана
        Object.assign(clans[currentClan].members[memberNickname], data);

        // Сохраняем обновленные данные клана в базу данных
        await set(ref(database, 'clans/' + currentClan), clans[currentClan]);
        console.log(`Данные участника ${memberNickname} в клане ${currentClan} обновлены.`);
    }
}
window.updateClanMemberData = updateClanMemberData;


function calculateClanDamageBonus(clanLevel)  {
  return 10 * Math.pow(2,  clanLevel - 1); // 10  урона  на 1  уровне,  х5  на  каждом  следующем
}
window.calculateClanDamageBonus = calculateClanDamageBonus;

async  function  resetClanIfInvalid(nickname,  data) { //  Добавляем  data  в  аргументы
    console.log("Проверка валидности клана  для  игрока", nickname);

    //  Проверка, был ли установлен currentClan  вообще  
    if (data.currentClan) { 
        const clansSnapshot = await  get(ref(database, 'clans')); 
        if (clansSnapshot.exists()) {
            const clansData = clansSnapshot.val(); 
            let clanFound = false; 

            for (const  clanName in  clansData)  { 
                if (nickname  in clansData[clanName].members) {
                    console.log("Клан найден, currentClan:",  currentClan);
                    clanFound = true;
                    break;
                } 
            } 

            //  Если клан не  найден,  сбрасываем  currentClan  
            if (!clanFound)  {
                console.log("Клан не найден,  сбрасываем  currentClan");
                currentClan =  null;

                //  Обновляем  данные игрока  в  базе  данных,  чтобы  убрать несуществующий currentClan
                const playerProgressRef = ref(database,  `players/${nickname}/progress`); 
                await  set(playerProgressRef, {  ...(await get(playerProgressRef)).val(), currentClan: null }); 

                showGameMessage('Вы были  удалены из клана, поскольку  он  больше  не  существует.'); 
            } 
        }
    }
}
window.resetClanIfInvalid = resetClanIfInvalid;

// Структура данных для клана
function Clan(name, leader) {
    this.name = name;
    this.leader = leader;
    this.members = {}; // Словарь для хранения членов клана {nickname: {rank, level, damage}}
    this.level = 1;
    this.upgradeCost = 10000; // Стоимость первого улучшения
    this.members[leader] = { rank: 'leader', level: currentLevel, damage: calculateTotalDamage() }; // Добавляем лидера в клан
    this.damageBonus = 10; 
}

// Возможные ранги в клане
const clanRanks = {
    leader: 'Лидер',
    deputy: 'Заместитель',
    member: 'Воин'
};

// Словарь для хранения кланов
let clans = {};

async function createClan(clanName) {
    console.log('Попытка создать клан:', clanName);

    // Проверка на достаточное количество золота
    if (gold < 1000) {
        showGameMessage('Недостаточно  золота для создания клана!');
        return;
    }

    // Проверка на существование клана с таким именем
    if (clanName in clans) {
        showGameMessage('Клан  с  таким именем  уже существует!');
        return;
    }

    // Проверка, состоит ли игрок уже в клане
    if (await isPlayerInClan(nickname)) {
        showGameMessage('Вы  уже  состоите  в  клане!');
        return;
    }

    console.log('Создаем клан:', clanName, 'для лидера:', nickname);
    spendGold(1000);
    clans[clanName] = new Clan(clanName, nickname);

    // Сохраняем клан в базу данных и ждем завершения
    await set(ref(database, 'clans/' + clanName), clans[clanName]); 

    // Обновляем список кланов 
    await updateClanList(); 

    // Устанавливаем currentClan  явно
    currentClan = clanName; 

    // Обновляем интерфейс клана
    updateClanInterface(); 
    await isPlayerInClan(nickname); 

    console.log('Клан', clanName, 'успешно создан!');
}
window.createClan = createClan;



async function openClanListMenu() {
    if (await isPlayerInClan(nickname)) {
        // Игрок уже в клане, открываем меню клана
        openClanMenu(); 
    } else {
        // Игрок не в клане, открываем меню списка кланов
        document.getElementById('clanListMenu').style.display = 'block';
        updateClanList();
    }
}
window.openClanListMenu = openClanListMenu;

function closeClanListMenu() {
    document.getElementById('clanListMenu').style.display = 'none';
}
window.closeClanListMenu = closeClanListMenu;

function openClanMenu() {
    document.getElementById('clanMenu').style.display = 'block';
    updateClanInterface();
}
window.openClanMenu = openClanMenu;

function closeClanMenu() {
    document.getElementById('clanMenu').style.display = 'none'; 
}
window.closeClanMenu = closeClanMenu; 

// Обновление списка кланов
async function updateClanList() {
    const clanList = document.getElementById('clanList');
    clanList.innerHTML =  '';

    //  Сортируем  кланы по уровню  (в порядке  убывания)
    const sortedClans = Object.entries(clans).sort(([, a], [, b]) =>  b.level - a.level); 

    for (const [clanName, clan] of sortedClans) {
        const clanItem =  document.createElement('li');
        
        //  Вычисляем вместимость клана  
        const  clanCapacity  =  clan.level  +  9;  
        
        clanItem.textContent = `${clan.name} (Уровень:  ${clan.level}, Игроков:  ${Object.keys(clan.members).length}/${clanCapacity}, Лидер: ${clan.leader})`; // Добавляем вместимость 
        clanItem.onclick = () =>  { joinClan(clanName);  };
        clanList.appendChild(clanItem);
    }
}


// Обновление информации о клане в интерфейсе
function updateClanInterface() {
    // Проверка на существование клана и нахождение игрока в нем
    if (currentClan && nickname in clans[currentClan].members) {
        const clanNameElement = document.getElementById('clanName');
        const clanLevelElement = document.getElementById('clanLevel');
        const clanLeaderElement = document.getElementById('clanLeader');
        const clanMembersElement = document.getElementById('clanMembers');

        // Заполняем элементы информацией о клане
        clanNameElement.textContent = currentClan;
        clanLevelElement.textContent = clans[currentClan].level;
        clanLeaderElement.textContent = clans[currentClan].leader;

        // Очищаем список членов клана
        clanMembersElement.innerHTML = '';

        // Отображаем  бонус  к  урону
        const  damageBonusElement =  document.createElement('p');
        damageBonusElement.textContent =  `Бонус  к урону: ${calculateClanDamageBonus(clans[currentClan].level)}`;
        clanMembersElement.appendChild(damageBonusElement);

        //  Добавляем каждого члена  клана  в список
        for (const memberNickname in clans[currentClan].members) {
            const member = clans[currentClan].members[memberNickname];

            // Пропускаем  лидера  в  цикле, если это  текущий  игрок
            if (memberNickname ===  nickname  && member.rank  ===  'leader')  { 
                continue;
            }

            const memberItem = document.createElement('li');
            memberItem.textContent = `${memberNickname} (${clanRanks[member.rank]}, Уровень: ${member.level}, Урон: ${member.damage})`;

            //  Проверка,  является  ли текущий игрок  лидером  клана  
            if  (clans[currentClan].leader ===  nickname)  { 
                //  Добавляем  кнопки  управления  
                const appointDeputyButton = document.createElement('button'); 
                appointDeputyButton.textContent = 'Назначить  заместителем'; 
                appointDeputyButton.onclick =  ()  =>  {
                    const selectedMember =  prompt('Введите никнейм участника для  назначения заместителем:');
                    if  (selectedMember)  { 
                        appointDeputy(selectedMember); 
                    }
                }; 
                memberItem.appendChild(appointDeputyButton); 

                const  kickMemberButton =  document.createElement('button'); 
                kickMemberButton.textContent = 'Исключить'; 
                kickMemberButton.onclick =  () =>  {
                    const  selectedMember = prompt('Введите никнейм  участника для исключения:'); 
                    if  (selectedMember)  {
                        kickMember(selectedMember);
                    }
                };
                memberItem.appendChild(kickMemberButton); 
            }
            //  Добавление  кнопки  исключения, если  игрок  -  заместитель
            else  if (member.rank  === 'deputy'  &&  memberNickname  ===  nickname)  {
                const  kickMemberButton =  document.createElement('button'); 
                kickMemberButton.textContent =  'Исключить';
                kickMemberButton.onclick =  ()  => {
                    const selectedMember = prompt('Введите  никнейм  участника  для исключения:'); 
                    if (selectedMember)  { 
                        kickMember(selectedMember);
                    } 
                };
                memberItem.appendChild(kickMemberButton);
            }
            clanMembersElement.appendChild(memberItem);
        }
    } else {
        console.error('Игрок не состоит в клане или клан не определен');
    }
}


// Проверка, находится ли игрок в клане
async function isPlayerInClan(playerNickname)  { 
    console.log("Проверка  нахождения  игрока",  playerNickname,  "в  клане.  Текущий  клан:", currentClan); 
    const  clansSnapshot  = await  get(ref(database,  'clans'));  //  ***  ДОБАВЛЕН  AWAIT  ***
    if (clansSnapshot.exists())  {
        const  clansData  =  clansSnapshot.val();
        for  (const  clanName in  clansData) { 
            console.log('clansData[clanName]:',  clansData[clanName]);
            if (playerNickname in  clansData[clanName].members)  { 
                //  Игрок найден в  клане
                currentClan =  clanName;
                console.log("Игрок найден  в клане", currentClan); 
                return  currentClan; 
            }
        }
    } 
    console.log("Игрок  не найден  ни в  одном  клане"); 
    return currentClan;  // Возвращаем  currentClan (null,  если  не найден)
}




async function joinClan(clanName) {
  //  Проверяем,  не  превышает  ли  число участников  лимит 
  if (Object.keys(clans[clanName].members).length >= clans[clanName].level + 9)  { 
      showGameMessage('Клан  уже  полон!');
      return;
  }

  //  Проверяем,  не  состоит  ли  игрок  уже  в  клане  
  if (await  isPlayerInClan(nickname))  { 
      showGameMessage('Вы уже  состоите  в клане!'); 
      return;
  }

  //  Добавляем  игрока  в  клан  
  clans[clanName].members[nickname]  = {
      rank: 'member',
      level:  currentLevel,
      damage:  calculateTotalDamage()  
  }; 

  //  Обновляем currentClan  ДО сохранения  в  Firebase
  currentClan  =  clanName;  

  try {
      //  Сохраняем  данные  клана  в  Firebase
      await set(ref(database,  'clans/'  +  clanName), clans[clanName]);

      //  Обновляем  информацию  о  клане  в  интерфейсе 
      updateClanInterface();

      //  Закрываем  меню  списка  кланов 
      closeClanListMenu();

      //  Открываем  меню  клана
      openClanMenu(); 

      //  Подключаемся к  чату  клана
      switchChat('clan');  
      console.log('Игрок  успешно  вступил в  клан',  clanName);
  } catch  (error)  {
      // Обработка  ошибки
      console.error('Ошибка  при  вступлении  в клан:',  error); 
      showGameMessage('Произошла  ошибка  при вступлении  в  клан.');  
  }
}
window.joinClan = joinClan;


async function leaveClan() {
    if (currentClan && nickname in clans[currentClan].members) {
        if (clans[currentClan].members[nickname].rank === 'leader') {
            // Лидер покидает клан

            // 1. Назначение нового лидера
            let newLeader = null;
            if (Object.keys(clans[currentClan].members).length > 1) {
                // Есть другие участники
                // Выбираем нового лидера, например, по уровню:
                newLeader = Object.entries(clans[currentClan].members)
                    .filter(([memberNickname, memberData]) => memberNickname !== nickname) // Исключаем текущего лидера
                    .reduce((max, [memberNickname, memberData]) => 
                        memberData.level > max[1].level ? [memberNickname, memberData] : max, ['', { level: 0 }])[0];

                // Обновляем ранг нового лидера
                clans[currentClan].members[newLeader].rank = 'leader';
                clans[currentClan].leader = newLeader;

                //  Сохраняем  обновленные  данные клана  
                await  set(ref(database, 'clans/' + currentClan), clans[currentClan]);
            }

            // 2. Уведомляем участников
            if (newLeader) {
                showGameMessage(`Лидер клана ${currentClan} покинул клан. Новым лидером назначен ${newLeader}.`);
            } else {
                // Нет других участников, удаляем клан
                delete clans[currentClan];
                await remove(ref(database, 'clans/' + currentClan));
                showGameMessage(`Клан ${currentClan} расформирован.`);
            }

            // Удаляем текущего лидера из клана
            delete clans[currentClan].members[nickname];
            currentClan = null; 

        } else {
            // Обычный участник покидает клан
            delete clans[currentClan].members[nickname];
            await set(ref(database, 'clans/' + currentClan), clans[currentClan]); 
            currentClan = null;
            showGameMessage(`Вы покинули клан ${currentClan}.`); 
        }

        //  Отписываемся  от  чата  клана
        off(ref(database,  `clans/${currentClan}/chat`)); 

        //  Переключаемся на  глобальный чат
        switchChat('global'); 

        updateClanList(); // Обновляем список кланов
        closeClanMenu();
    }
}
window.leaveClan = leaveClan; 

// Функция для открытия меню пожертвований
function openClanDonateMenu() {
    const cost = clans[currentClan].upgradeCost;
    const donationsRef = ref(database, `clans/${currentClan}/donations`);
    get(donationsRef).then((snapshot) => {
        const currentDonations = snapshot.exists() ? snapshot.val() : 0; 
        document.getElementById('clanUpgradeCost').textContent = cost; 
        document.getElementById('clanCurrentDonations').textContent = currentDonations;
        document.getElementById('clanDonateMenu').style.display = 'block';
    }); 
}
window.openClanDonateMenu = openClanDonateMenu;

//  Функция для закрытия меню пожертвований 
function closeClanDonateMenu() {
    document.getElementById('clanDonateMenu').style.display = 'none'; 
}
window.closeClanDonateMenu = closeClanDonateMenu;

//  Функция для пожертвования в клан
async function donateToClan() {
    const donateAmount = Number(document.getElementById('clanDonateAmount').value);
    if (donateAmount > 0 && gold >= donateAmount) {
        spendGold(donateAmount);

        const clanDonationsRef = ref(database, `clans/${currentClan}/donations`);

        //  Получаем текущее  значение  из  базы 
        let currentDonations =  await  get(clanDonationsRef).then(snapshot => snapshot.val() || 0);
        
        //  Обновляем  clans  и  Firebase 
        clans[currentClan].donations =  currentDonations + donateAmount; 
        await set(clanDonationsRef, clans[currentClan].donations); 

        //  Обновляем  UI 
        document.getElementById('clanCurrentDonations').textContent = clans[currentClan].donations; 

        document.getElementById('clanDonateAmount').value = '';  
        showGameMessage('Спасибо за ваше пожертвование!');  
    } else  {
        showGameMessage('Некорректная  сумма  или  недостаточно  золота!');
    } 
}
window.donateToClan = donateToClan;

//  Обновленная функция upgradeClan
//  Обновленная функция upgradeClan
async function upgradeClan() {
    if (currentClan && nickname in clans[currentClan].members) {
        const currentLevel = clans[currentClan].level;
        const maxLevel = 10; 
        const cost = clans[currentClan].upgradeCost;
        const nextCapacity = currentLevel + 10; 

        if (currentLevel >= maxLevel) {
            showGameMessage(`Ваш клан уже достиг максимального уровня (${maxLevel}).`); 
            return;
        }

        // Получаем текущую сумму пожертвований 
        const clanDonationsRef = ref(database, `clans/${currentClan}/donations`);
        const donationsSnapshot = await get(clanDonationsRef); 
        let currentDonations = donationsSnapshot.exists() ? donationsSnapshot.val() : 0;

        // Проверка, может ли лидер улучшить клан
        if (clans[currentClan].members[nickname].rank === 'leader'  &&  currentDonations >= cost) { 
            if (confirm(`Улучшить клан до уровня ${currentLevel  +  1}?  \n` +
                        `Текущая вместимость: ${currentLevel  +  9} участников\n` +
                        `Вместимость после улучшения:  ${nextCapacity} участников`)) {
                // Вычитаем стоимость улучшения из пожертвований
                currentDonations -= cost;

                // Обновляем clans[currentClan].donations
                clans[currentClan].donations = currentDonations; 

                // Сохраняем обновленную сумму пожертвований
                await set(clanDonationsRef, currentDonations);

                clans[currentClan].level++;
                clans[currentClan].upgradeCost *= 2; 
                
                // Обновляем бонус к урону 
                clans[currentClan].damageBonus = calculateClanDamageBonus(clans[currentClan].level);

                await set(ref(database, 'clans/' + currentClan), clans[currentClan]); 
                updateClanInterface(); 
            }
        } else  if (clans[currentClan].members[nickname].rank !== 'leader') {
            showGameMessage(`Только лидер клана может улучшить клан!`)
        } else {
            // Отображаем информацию о пожертвованиях в интерфейсе 
            openClanDonateMenu();
        }
    }
}
window.upgradeClan = upgradeClan; 


async function appointDeputy(memberNickname) {
    if (currentClan && clans[currentClan].members[nickname].rank === 'leader') {
        if (memberNickname in clans[currentClan].members && memberNickname !== nickname) {
            clans[currentClan].members[memberNickname].rank = 'deputy';
            await set(ref(database, 'clans/' + currentClan), clans[currentClan]); // Сохраняем данные клана
            updateClanInterface();
        } else {
            showGameMessage('Выбран неверный участник клана!');
        }
    }
}
window.appointDeputy = appointDeputy;

async function kickMember(memberNickname) {
    if (currentClan && 
       (clans[currentClan].members[nickname].rank === 'leader' || 
        clans[currentClan].members[nickname].rank === 'deputy')) {
        if (memberNickname in clans[currentClan].members && memberNickname !== nickname) {
            if (clans[currentClan].members[memberNickname].rank !== 'leader') {
                delete clans[currentClan].members[memberNickname];
                await set(ref(database, 'clans/' + currentClan), clans[currentClan]); // Сохраняем данные клана
                updateClanInterface();
            } else {
                showGameMessage('Вы не можете исключить лидера клана!');
            }
        } else {
            showGameMessage('Выбран неверный участник клана!');
        }
    }
}
window.kickMember = kickMember;










































let turnTimeout; // Тайм-аут для управления ходами
let opponent; // Объявление глобальной переменной для хранения данных о противнике
let totalDamage = 100; // Урон игрока
let opponentDamage = 50; // Урон противника
let opponentHealth = 800; // Здоровье противника
let playerHealth = 800;
let currentPlayer = null;
let battleInProgress = false; // Отслеживает состояние боя
let playerRef;
let opponentRef;
let onValueListener; // Глобальная переменная для хранения ссылки на обработчик
let turnDuration = 3000; // Продолжительность хода в миллисекундах
let opponentListenerRef;
let isFinalizingBattle = false; // Флаг для предотвращения повторных вызовов 
let isListeningForOpponent = false; 
let battlePromise = null; // Промис для блокировки listenForOpponent
let registrationPromise = null; // Промис для блокировки регистрации

// Открытие окна регистрации на PvP
function openPvpRegistration() {
    document.getElementById('pvpRegistration').style.display = 'block';
}

// Закрытие окна регистрации на PvP
function closePvpRegistration() {
    document.getElementById('pvpRegistration').style.display = 'none';
}

// Регистрация на PvP
async function registerForPvp() {
  console.log("Попытка регистрации на PvP. Текущее здоровье: ", playerHealth);

  if (battleInProgress) {
    console.log("Вы уже участвуете в бою!");
    return;
  }

  nickname = document.getElementById('nicknameInput').value;

  const inBattle = await isPlayerInBattle(nickname);
  if (inBattle) {
    console.log("Вы уже участвуете в бою!");
    showGameMessage("Вы уже участвуете в бою!");
    return;
  }

  // Ждем завершения регистрации, если она заблокирована
  console.log("Ожидание завершения регистрации...");
  await Promise.resolve(registrationPromise);
  console.log("Регистрация разблокирована.");
  updateTotalDamage(); // Обновляем totalDamage перед  регистрацией
  playerHealth = calculateTotalHealth(); // Вычисляем  здоровье,  учитывая таланты 
  playerRef = ref(database, 'pvpQueue/' + nickname);
  console.log(`Регистрация игрока ${nickname} с данными: здоровье ${playerHealth}, урон ${totalDamage}`);

  await set(playerRef, {
    nickname: nickname,
    health:  playerHealth,  // Отправляем  playerHealth 
    damage: totalDamage,
    inBattle: false,
    timestamp: Date.now()
  });

  console.log(`${nickname} зарегистрирован на PvP с данными:`, {
    nickname: nickname,
    health: playerHealth,
    damage: totalDamage,
    timestamp: Date.now()
  });

  closePvpRegistration();
  showWaitingForOpponent();
}

// Синхронизация очереди PvP
function listenForOpponent() {
  console.log("Ожидание завершения предыдущего боя...");

  Promise.resolve(battlePromise)
    .then(() => {
      console.log("Предыдущий бой завершен. Запуск прослушивания очереди.");

      const opponentRef = ref(database, 'pvpQueue');
      opponentListenerRef = onValue(opponentRef, async (snapshot) => {
        if (snapshot.exists() && !battleInProgress && !isFinalizingBattle) {
          const queue = snapshot.val();
          const players = Object.entries(queue)
            .filter(([key, value]) => key && value && !value.inBattle && key !== nickname);
          console.log("Изменения в очереди PvP:", queue, "Найденные игроки:", players);

          if (players.length >= 1) {
            players.sort((a, b) => a[1].timestamp - b[1].timestamp);

            const player1 = [nickname, queue[nickname]];
            const player2 = players[0];

            if (player1[1] && player2[1]) {
              console.log("Попытка начать PvP бой между игроками:", player1, player2);

              // Прослушиваем событие сдачи оппонента
              const opponentSurrenderRef = ref(database, `pvpQueue/${player2[1].nickname}/surrender`);
              onValue(opponentSurrenderRef, (snapshot) => {
                if (snapshot.exists() && snapshot.val() === true) {
                  console.log("Оппонент сдался!");
                  finalizePvpBattle('player', 'opponent_surrender');
                }
              });

              try {
                const startBattleSuccess = await startPvpBattle(player2[1]);
                if (startBattleSuccess) {
                  console.log("PvP бой успешно начат.");
                } else {
                  console.warn("Не удалось начать PvP бой. Возможно, другой игрок уже начал бой.");
                }
              } catch (error) {
                console.error("Ошибка при попытке начать PvP бой:", error);
              }
            } else {
              console.log("Не найден подходящий оппонент для боя.");
            }
          }
        } else {
          console.log("Идет или завершается бой, новые бои не запускаются.");
        }
      });
    });
}

// Остановка прослушивания очереди после завершения боя
async function finalizePvpBattle(winner, reason = null) {
  if (isFinalizingBattle) {
    console.log("Битва уже завершается.");
    return;
  }

  isFinalizingBattle = true;

  if (!battleInProgress) {
    console.log("Битва уже завершена.");
    isFinalizingBattle = false;
    return;
  }

  console.log(`Завершение битвы. Победитель: ${winner}, Причина: ${reason}`);
  battleInProgress = false;

  const opponentNickname = opponent ? opponent.nickname : null;

  try {
    // Блокируем listenForOpponent до завершения транзакции
    battlePromise = new Promise(resolve => {
      runTransaction(ref(database, 'pvpQueue'), (queue) => {
        if (!queue) {
          console.warn("Очередь PvP пуста.");
          return undefined;
        }

        if (!queue[nickname] || (opponentNickname && !queue[opponentNickname])) {
          console.warn("Один из игроков уже отсутствует в очереди.");
          return undefined;
        }

        // Сбрасываем флаги inBattle и обновляем здоровье
        queue[nickname].inBattle = false;
        queue[nickname].health = 800;
        if (opponentNickname) {
          queue[opponentNickname].inBattle = false;
          queue[opponentNickname].health = 800;
        }

        // Удаляем игроков из очереди
        delete queue[nickname];
        if (opponentNickname) {
          delete queue[opponentNickname];
        }

        return queue;
      })
      .then(() => {
        console.log(`Игроки ${nickname} и ${opponentNickname} удалены из очереди.`);
        resetBattleState();
        resolve(); // Разрешаем промис после успешного завершения
      })
      .catch(error => {
        console.error('Ошибка при выполнении транзакции:', error);
        resolve(); // Разрешаем промис, даже если произошла ошибка
      });
    });

    // Дожидаемся завершения транзакции
    await battlePromise;
    //  Запись  результата  битвы  в  базу данных  
    const  battlesRef =  ref(database,  'pvpBattles'); 
    const  newBattleRef  =  push(battlesRef);
     // Сортируем никнеймы  игроков  в  алфавитном  порядке
     const  players  =  [nickname,  opponentNickname].sort(); 
     await set(newBattleRef, {
            player1: players[0], //  Никнейм  первого  игрока  (в  алфавитном  порядке) 
            player2: players[1],  // Никнейм  второго  игрока  (в  алфавитном  порядке) 
            winner: winner, 
            reason: reason,
            timestamp: Date.now() 
        });
    // Обновляем UI (теперь всегда выполнится)
    if (winner === 'player') {
      if (reason === 'opponent_surrender') {
        document.getElementById('pvpFightLog').innerHTML += '<span style="color: green;">Противник сдался! Вы победили!</span><br>';
      } else {
        document.getElementById('pvpFightLog').innerHTML += '<span style="color: green;">Вы победили!</span><br>';
      }
    } else if (winner === 'opponent') {
      if (reason === 'player_surrender') {
        document.getElementById('pvpFightLog').innerHTML += '<span style="color: red;">Вы сдались! Вы проиграли!</span><br>';
      } else {
        document.getElementById('pvpFightLog').innerHTML += '<span style="color: red;">Вы проиграли!</span><br>';
      }
    }
// Добавляем задержку перед скрытием pvpBattle
setTimeout(() => {
      document.getElementById('pvpBattle').style.display = 'none';
      const waitingMessage = document.getElementById('waitingMessage');
      if (waitingMessage) {
        document.body.removeChild(waitingMessage);
      }
    }, 3000); // 3 секунды задержки

    console.log("Данные о завершении боя успешно обновлены.");
  

  } catch (error) {
    console.error('Ошибка при завершении боя:', error);
  } finally {
    isFinalizingBattle = false;
    battlePromise = null; // Разблокируем listenForOpponent
  }
}

// Завершение PvP боя
async function startPvpBattle(opponentData) {
  if (isFinalizingBattle) {
    console.log("Предыдущий бой еще завершается. Прерывание запуска нового боя.");
    return false;
  }

  console.log("Начало битвы. Данные оппонента:", opponentData);

  if (battleInProgress) {
    console.log("Битва уже идет. Прерывание вызова startPvpBattle.");
    return false;
  }

  if (!opponentData || !opponentData.nickname || opponentData.health === undefined || opponentData.damage === undefined) {
    console.error("Некорректные данные оппонента:", opponentData);
    return false;
  }

  try {
    await runTransaction(ref(database, 'pvpQueue'), (queue) => {
      if (queue && 
          queue[nickname] && !queue[nickname].inBattle && 
          queue[opponentData.nickname] && !queue[opponentData.nickname].inBattle) {
        queue[nickname].inBattle = true;
        queue[opponentData.nickname].inBattle = true;
        return queue;
      } else {
        console.warn("Один из игроков уже участвует в бою или данные устарели.", queue);
        return undefined;
      }
    });

    battlePromise = new Promise(resolve => {
      stopListeningForOpponent();

      opponent = opponentData;
      opponentRef = ref(database, 'pvpQueue/' + opponent.nickname);
      opponentHealth = opponent.health;
      opponentDamage = opponent.damage;

      currentPlayer = (Math.random() > 0.5) ? 'player' : 'opponent';
      console.log("Начало битвы. Текущий игрок:", currentPlayer);

      document.getElementById('pvpOpponentInfo').innerText = `Противник: ${opponent.nickname}\nЗдоровье: ${opponent.health}\nУрон: ${opponent.damage}`;
      document.getElementById('pvpFightLog').innerHTML = '';
      document.getElementById('pvpBattle').style.display = 'block';

      // Устанавливаем battleInProgress = true ПОСЛЕ создания данных
      battleInProgress = true;

      // Запускаем первый ход 
      if (currentPlayer === 'player') {
        playerTurn();
      } else {
        opponentTurn();
      }

      // Блокируем регистрацию во время боя
      registrationPromise = battlePromise; 

      resolve();
    });

    return true;
  } catch (error) {
    console.error("Ошибка при обновлении флагов inBattle:", error);
    return false;
  }
}

function stopListeningForOpponent() {
  if (opponentListenerRef) { // Проверяем,  что слушатель еще не отключен
    off(ref(database, 'pvpQueue'), opponentListenerRef);
    opponentListenerRef = null;
    console.log("Прослушивание очереди PvP остановлено.");
  }
}


// Показ надписи "идет поиск соперника"
function showWaitingForOpponent() {
    const waitingMessage = document.createElement('div');
    waitingMessage.id = 'waitingMessage';
    waitingMessage.style.position = 'fixed';
    waitingMessage.style.top = '50%';
    waitingMessage.style.left = '50%';
    waitingMessage.style.transform = 'translate(-50%, -50%)';
    waitingMessage.style.background = 'rgba(0, 0, 0, 0.8)';
    waitingMessage.style.color = 'white';
    waitingMessage.style.padding = '20px';
    waitingMessage.style.borderRadius = '10px';
    waitingMessage.style.textAlign = 'center';
    waitingMessage.innerText = 'Идет поиск соперника...';
    document.body.appendChild(waitingMessage);
}









// Завершение PvP боя в ручную по нажатию кнопки завершить бой
function endPvpBattle() {
  if (!battleInProgress) {
    console.log("Битва уже завершена.");
    return;
  }

  console.log("Завершение битвы вручную.");

  // Отправляем сообщение о сдаче в базу данных
  set(ref(database, `pvpQueue/${nickname}/surrender`), true);

  // Завершаем бой на стороне игрока
  finalizePvpBattle('opponent', 'player_surrender'); 
}

function resetBattleState() {
    currentPlayer = null;
    playerRef = null;
    opponentRef = null;
    opponent = null;
    playerHealth = calculateTotalHealth(); //  Инициализируем  playerHealth
    opponentHealth = null; //  Сбрасываем opponentHealth перед  началом  новой битвы 
    battleInProgress = false;

    console.log("Состояние после сброса. Игрок здоровье: ", playerHealth, " Оппонент здоровье: ", opponentHealth);
}

function playerTurn() {
    if (!battleInProgress) {
        console.log("Битва не идет. Прерывание хода игрока.");
        return;
    }
    console.log("Ход игрока. Урон:", totalDamage);
    opponentHealth -= totalDamage;
    if (opponentHealth < 0) opponentHealth = 0;
    console.log(`Урон по оппоненту: ${totalDamage}. Здоровье оппонента: ${opponentHealth}`);
    updateHealthBars(); // Обновить health bar прежде, чем проверять окончание битвы
    if (opponentHealth <= 0) {
        console.log("Оппонент побежден игроком.");
        finalizePvpBattle('player');
        return;
    }

    document.getElementById('pvpFightLog').innerHTML += `<span style="color: green;">Вы нанесли ${totalDamage} урона противнику!</span><br>`;
    updateOpponentHealth();
    currentPlayer = 'opponent';
    console.log("Передача хода оппоненту.");
    scheduleNextTurn();
}

function opponentTurn() {
    if (!battleInProgress) {
        console.log("Битва не идет. Прерывание хода оппонента.");
        return;
    }
    console.log("Ход оппонента. Урон:", opponentDamage);
    playerHealth -= opponentDamage;
    if (playerHealth < 0) playerHealth = 0;
    console.log(`Урон по игроку: ${opponentDamage}. Здоровье игрока: ${playerHealth}`);

    if (playerHealth <= 0) {
        console.log("Игрок побежден оппонентом.");
        finalizePvpBattle('opponent');
        return;
    }

    document.getElementById('pvpFightLog').innerHTML += `<span style="color: red;">Противник нанес вам ${opponentDamage} урона!</span><br>`;
    updatePlayerHealth();
    currentPlayer = 'player';
    scheduleNextTurn();
}

async function updateOpponentHealth() {
    if (opponent && opponent.nickname) {
        const opponentHealthRef = ref(database, 'pvpQueue/' + opponent.nickname + '/health');
        await set(opponentHealthRef, opponentHealth)
            .then(() => {
                console.log(`Здоровье противника обновлено: ${opponentHealth}`);
            })
            .catch((error) => {
                console.error(`Ошибка при обновлении здоровья противника:`, error);
            });
    } else {
        console.error("Не удалось обновить здоровье противника: некорректные данные оппонента.");
    }
}

async function updatePlayerHealth() {
    const playerHealthRef = ref(database, 'pvpQueue/' + nickname + '/health');
    await set(playerHealthRef, playerHealth)
        .then(() => {
            console.log(`Здоровье игрока обновлено: ${playerHealth}`);
            
    updateHealthBars();

        })
        .catch((error) => {
            console.error(`Ошибка при обновлении здоровья игрока:`, error);
        });
}


function updateHealthBars() {
    const playerHealthPercentage = (playerHealth / 800) * 100; // 800 - максимальное здоровье
    document.getElementById('playerHealthBar').style.width = playerHealthPercentage + '%';

    // const opponentHealthPercentage = (opponentHealth / 800) * 100; // 800 - максимальное здоровье
    // document.getElementById('opponentHealthBar').style.width = opponentHealthPercentage + '%';
}




function scheduleNextTurn() {
    if (!battleInProgress) {
        console.log("Битва не идет. Прерывание scheduleNextTurn.");
        return;
    }

    if (currentPlayer === 'player') {
        setTimeout(playerTurn, turnDuration);
    } else {
        setTimeout(opponentTurn, turnDuration);
    }
}

// Обновление лога боя с цветовым выделением
function updateFightLog(message, color) {
    const logElement = document.getElementById('pvpFightLog');
    const newMessage = document.createElement('span');
    newMessage.style.color = color;
    newMessage.innerHTML = message + '<br>';
    logElement.appendChild(newMessage);
}







// Дополнительная функция для проверки, находится ли игрок в бою
async function isPlayerInBattle(playerNickname) {
    const battleRef = ref(database, 'pvpQueue/' + playerNickname);
    try {
        const snapshot = await get(battleRef);
        if (snapshot.exists()) {
            const playerData = snapshot.val();
                     //  ОБНОВЛЕНИЕ:  Если  игрок  в  бою,  обновляем  его  здоровье  
         if  (playerData.inBattle)  {
             playerHealth =  playerData.health; //  Берем  здоровье  из  очереди  
             updateStatusBar(); //  Обновляем  отображение  здоровья 
         } 

            const inBattle = playerData.inBattle;
            console.log(`Проверка статуса боя игрока ${playerNickname}: ${inBattle}`);
            return inBattle;
        }
        console.log(`Игрок ${playerNickname} не найден в очереди PvP.`);
        return false;
    } catch (error) {
        console.error(`Ошибка при проверке статуса боя игрока ${playerNickname}:`, error);
        return false;
    }
}


        window.openPvpRegistration = openPvpRegistration;
        window.closePvpRegistration = closePvpRegistration;
        window.endPvpBattle = endPvpBattle;
        window.stopListeningForOpponent = stopListeningForOpponent;


        window.updateHealthBars = updateHealthBars;

        // window.registerForPvp = registerForPvp;
        // window.showWaitingForOpponent = showWaitingForOpponent;
        // window.startPvpBattle = startPvpBattle;
        // window.scheduleNextTurn = scheduleNextTurn;
        // window.opponentTurn = opponentTurn;
        // window.playerTurn = playerTurn;
        // window.updateOpponentHealth = updateOpponentHealth;
        // window.updatePlayerHealth = updatePlayerHealth;
        // window.finalizePvpBattle = finalizePvpBattle;
        
        // window.isPlayerInBattle = isPlayerInBattle;
            // window.listenForOpponent = listenForOpponent;
//         function clearQueue() {
//     const queueRef = ref(database, 'pvpQueue');
//     set(queueRef, null)
//     .then(() => {
//         console.log('Очередь очищена.');
//     })
//     .catch((error) => {
//         console.error('Ошибка при очистке очереди:', error);
//     });
// }
// window.clearQueue = clearQueue;






function hitMonster(event) {
  if (currentScreen !== 'battle') return;
  if (monsterHealth <= 0) return;

  const rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;
  const monsterX = canvas.width / 2 - monsterImage.width / 2;
  const monsterY = canvas.height / 2 - monsterImage.height / 2;

  if (mouseX >= monsterX && 
      mouseX <= monsterX + monsterImage.width && 
      mouseY >= monsterY && 
      mouseY <= monsterY + monsterImage.height) {

        showHitAnimation(monsterImage); // Pass the monsterImage to the animation function
    const totalDamage = calculateTotalDamage();
    monsterHealth -= totalDamage; 

    if (monsterHealth < 0) { 
      monsterHealth = 0;
    }

    hits += 1; 
    updateMonsterHealthDisplay();

    // Проверка на редкого монстра
    if (monsterHealth <= 0 && isRareMonsterEncountered) {
      clearInterval(rareMonsterTimerInterval);
      document.getElementById('rareMonsterTimer').style.display = 'none';
      isRareMonsterEncountered = false;

 // Награда за редкого монстра
 let goldReward = Math.round(100 * currentLevel * rewardMultiplier); 
    let chaosReward = currentLevel; //  Количество  Эссенции Хаоса  равно  уровню
    showGameMessage(`Вы победили редкого монстра! Получено: ${goldReward} золота и ${chaosReward} Эссенции Хаоса`);
    updateGold(gold + goldReward); 
    updateChaosEssence(chaosEssence + chaosReward); // Обновляем Эссенцию Хаоса
    updateStatusBar();  //  Добавляем  вызов  здесь 
    saveProgress(); 

      // Обновляем прогресс заданий на убийство редких монстров
      questCategories['Убийство редких монстров'].forEach(quest => {
        if (!quest.completed) {
          quest.progress++; 
          if (quest.progress >= quest.goal) {
            quest.completed = true;
            showGameMessage(`Задание "${quest.description}" выполнено!`);
          }
        }
      });

      // Продолжаем игру с обычными монстрами
      showContinuePrompt();
    } else if (monsterHealth <= 0) { // Логика для обычного монстра
      let goldReward = Math.round(10 * currentLevel * rewardMultiplier);
      console.log(`Monster defeated. Awarding gold: ${goldReward}`);
      updateGold(gold + goldReward)
        .then(() => {
          console.log(`Gold after defeating monster: ${gold}`);
          document.getElementById('goldAmount').textContent = goldReward;
          return saveProgress();
        })
        .then(() => {
          showVictoryMessage();
        })
        .catch(error => {
          console.error('Error updating gold and saving progress:', error);
        });

      // Обновление прогресса заданий на убийство обычных монстров
      questCategories['Убийство монстров'].forEach(quest => {
        if (quest.description.includes('Убить') && !quest.completed) {
          quest.progress++;
          if (quest.progress >= quest.goal) {
            quest.completed = true;
            showGameMessage(`Задание "${quest.description}" выполнено!`);
          } 
        }
      });
    }
    
    updateCharacterImage();
  }
}
window.hitMonster = hitMonster; 

function updateChaosEssence(amount) {
  chaosEssence = amount;
  // Обновим отображение Эссенции Хаоса в интерфейсе, 
  // например, добавив новый элемент <span id="chaosEssence"></span> в #statusBar
  document.getElementById('chaosEssence').textContent = chaosEssence; 
}
// Начальное создание монстра с базовым здоровьем
function initializeMonster(initialHealth) {
    monsterHealth = initialHealth;
    console.log('Initializing monster with health:', initialHealth);
    updateMonsterImage(currentLevel);
    updateMonsterHealthDisplay();
}

window.initializeMonster = initializeMonster;

const level = 5;
const baseHealth = 100; // Предположим, базовое здоровье
const calculatedHealth = baseHealth * Math.pow(1.1, level - 1);
console.log(`Calculated health for level ${level}: ${calculatedHealth}`);




// Функция для продолжения игры после победы над монстром
function showContinuePrompt() {
  currentLevel++; // Переход к следующему уровню
  console.log(`Proceeding to level ${currentLevel}`);

  // ПРОВЕРЯЕМ НА РЕДКОГО МОНСТРА
  if (checkForRareMonster()) {
      startRareMonsterBattle();
  } else {
      // Используем фиксированное baseMonsterHealth для расчета нового здоровья монстра
      const newMonsterHealth = baseMonsterHealth * Math.pow(1.1, currentLevel - 1);
      console.log(`New monster health for level ${currentLevel}: ${newMonsterHealth}`);
      console.log(`Base monster health: ${baseMonsterHealth}`); // Логирование начального значения здоровья
      monsterHealth = newMonsterHealth;

      // Логирование прогресса перед сохранением на новом уровне
      console.log('Saving progress after proceeding to next level:', {
          currentLevel,
          gold,
          playerHealth,
          weaponPower,
          weaponName,
          weaponLevel,
          heroes,
          levels,
          monsterHealth // Добавляем здоровье монстра для сохранения
      });

      // Сохранение прогресса на новом уровне
      saveProgress();

      initializeMonster(newMonsterHealth);
      drawMenu();
      // Обновляем информацию в клане
      updateClanMemberData(nickname, {
          level: currentLevel, //  Обновленный  уровень 
          damage: calculateTotalDamage()
      });
  }
} 




window.showContinuePrompt = showContinuePrompt;

function resetMonsterState() {
    initializeMonster(baseMonsterHealth * Math.pow(1.1, currentLevel - 1));
    console.log(`Monster health reset to: ${monsterHealth}`);
}





function hideContinuePrompt() {
    document.getElementById('continuePrompt').style.display = 'none';
    document.getElementById('victoryImage').style.display = 'none';
    document.getElementById('goldEarned').style.display = 'none'; // Скрыть текст с количеством золота
}



function continueToNextLevel() {
  hideContinuePrompt();
  if (currentLevel < 10000) {
    currentLevel++;
    // Проверка на редкого монстра 
    if (checkForRareMonster()) {
      startRareMonsterBattle(); //  Запускаем бой с редким монстром 
    } else {
      startLevel(currentLevel);  //  Запускаем обычный  уровень 
    }

    updateCharacterImage(); //  вызов  функции  для смены изображения 
  } else {
    currentScreen = 'victory';
    drawVictoryScreen();
  }
  updateTopPlayers(nickname, { nickname, level: currentLevel });
  drawLevelMap();
  
  //  Обновляем информацию в клане 
  updateClanMemberData(nickname, {
      level: currentLevel, 
      damage: calculateTotalDamage() 
  });
}



window.continueToNextLevel = continueToNextLevel;




        function drawMenu() {
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        }
        function drawCastle() {
            ctx.drawImage(castle, 0, 0, canvas.width, canvas.height);
            document.getElementById('mailButton').style.display = 'block'; // Отображаем кнопку почты

            // Логирование координат и размеров кнопки почты
            const mailButton = document.getElementById('mailButton');
            const rect = mailButton.getBoundingClientRect();
            console.log(`Mail button coordinates: (${rect.left}, ${rect.top})`);
            console.log(`Mail button size: ${rect.width}x${rect.height}`);
        }
        window.drawCastle = drawCastle;
        function arena() {
            ctx.drawImage(arena2, 0, 0, canvas.width, canvas.height);
        }

        function drawDungeonEntrance() {
            ctx.drawImage(dungeonGateImage, 0, 0);
        }

        function drawVictoryScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Вы победили!', canvas.width / 2, canvas.height / 2);
        }
        
        function showVictoryMessage() {
    console.log("Victory message displayed");

    // Создаем контейнер для сообщения о победе
    const victoryMessage = document.createElement('div');
    victoryMessage.id = 'victoryMessage';
    victoryMessage.style.position = 'absolute';
    victoryMessage.style.top = '50%';
    victoryMessage.style.left = '50%';
    victoryMessage.style.transform = 'translate(-50%, -50%)';
    victoryMessage.style.padding = '20px';
    victoryMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    victoryMessage.style.color = 'white';
    victoryMessage.style.fontSize = '24px';
    victoryMessage.style.textAlign = 'center';
    document.body.appendChild(victoryMessage);

    // Добавляем картинку победы
    const victoryImage = document.createElement('img');
    victoryImage.id = 'victoryImage';
    victoryImage.src = 'win2.png';
    victoryImage.alt = 'Вы победили';
    victoryImage.style.width = '400px';
    victoryImage.style.height = 'auto';
    victoryImage.onclick = () => {
        document.body.removeChild(victoryMessage);
        showContinuePrompt();
    };
    victoryMessage.appendChild(victoryImage);

    // Добавляем отображение заработанного золота
    const goldEarnedDiv = document.createElement('div');
    goldEarnedDiv.id = 'goldEarned';
    goldEarnedDiv.style.fontSize = '24px';
    goldEarnedDiv.style.color = 'gold';
    goldEarnedDiv.style.fontFamily = "'Comic Sans MS', cursive, sans-serif";
    goldEarnedDiv.textContent = `Золото: ${document.getElementById('goldAmount').textContent}`;
    victoryMessage.appendChild(goldEarnedDiv);

    // Добавляем текст сообщения о победе
    const victoryText = document.createElement('p');
    victoryText.textContent = 'Победа! Вы хотите продолжить унижать Shap и убить следующего монстра?';
    victoryMessage.appendChild(victoryText);

    // Убираем сообщение через 3 секунды
    setTimeout(() => {
        if (document.body.contains(victoryMessage)) {
            document.body.removeChild(victoryMessage);
            showContinuePrompt();
        }
    }, 3000); // Время отображения сообщения о победе
}

window.showVictoryMessage = showVictoryMessage;


function calculateStars() {
    // Логика расчета количества звезд, например, на основе оставшегося здоровья игрока или времени
    if (playerHealth > 80) {
        return 3;
    } else if (playerHealth > 50) {
        return 2;
    } else {
        return 1;
    }
}

function startLevel(levelNumber) {
    currentLevel = levelNumber;
    monsterHealth = 100 * Math.pow(1.1, levelNumber - 1); // Устанавливаем здоровье монстра на основе уровня
    console.log(`Starting level ${levelNumber}`);
    console.log(`Monster health set to: ${monsterHealth}`);
    document.getElementById('monsterHealthContainer').style.display = 'block'; // Отображение контейнера здоровья монстра
    document.getElementById('monsterHealthBar').style.width = '100%'; // Полная ширина при начале уровня
    updateMonsterImage(levelNumber); // Устанавливаем изображение монстра
    
    currentScreen = 'battle';
    drawBattle();
    updateMonsterHealthDisplay(); // Обновление отображения здоровья при начале уровня
    updateCharacterImage(); // вызов функции для смены изображения
    //showHealthBar();  //  Показываем полоску  здоровья 
}

window.startLevel = startLevel;

function showHealthBar() {
    const healthContainer = document.getElementById('monsterHealthContainer');
    healthContainer.style.display = 'block';
}

window.showHealthBar = showHealthBar;





function completeLevel(levelNumber, stars) {
    if (levels[levelNumber - 1]) {
        levels[levelNumber - 1].completed = true;
        levels[levelNumber - 1].stars = stars;
        saveProgress(nickname, {
            currentLevel,
            gold,
            playerHealth,
            weaponPower,
            weaponName,
            weaponLevel,
            levels
        });
        drawLevelMap();
    }
    updateCharacterImage(); // вызов функции для смены изображения
}
window.completeLevel = completeLevel;


// function drawLevelsScreen() {
//     ctx.clearRect(0, 0, canvas.width, canvas.height);
//     ctx.fillStyle = 'black';
//     ctx.fillRect(0, 0, canvas.width, canvas.height);

//     ctx.fillStyle = 'white';
//     ctx.font = '30px Arial';
//     ctx.textAlign = 'center';
//     ctx.fillText('Уровни и Звезды', canvas.width / 2, 50);

//     levels.forEach((level, index) => {
//         const { x, y } = getLevelPosition(index);

//         ctx.fillStyle = level.completed ? 'gold' : 'silver';
//         ctx.beginPath();
//         ctx.arc(x, y, 25, 0, Math.PI * 2);
//         ctx.fill();

//         ctx.fillStyle = 'white';
//         ctx.font = '20px Arial';
//         ctx.fillText(level.number, x, y + 8);

//         drawStars(x - 30, y + 35, level.stars);
//     });
// }





        function drawLevelMap() {
            //console.log(levels);  // Вывод данных уровней в консоль
           // console.log('Drawing level map');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);

            levels.forEach((level, index) => {
                const { x, y } = getLevelPosition(index);

                ctx.fillStyle = level.completed ? 'gold' : 'silver';
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(level.number, x, y + 8);

                drawStars(x - 30, y + 35, level.stars);
            });
        }

        function getLevelPosition(index) {
            const perRow = 5;
            const spacing = 80;
            const offsetX = (canvas.width - perRow * spacing) / 2;
            const offsetY = 100;

            const x = offsetX + (index % perRow) * spacing;
            const y = offsetY + Math.floor(index / perRow) * spacing;
            return { x, y };
        }
        




        const updateInterval = 1000; // Интервал обновления в миллисекундах (1 секунда)

// Функция для регулярного обновления данных
function startUpdating() {
    if (!isUpdating) {
        isUpdating = true;
        setInterval(() => {
            // Получаем последние данные с сервера
            updateWorldBossData();
        }, updateInterval);
    }
}


// Функция для обновления данных босса и игроков
function updateWorldBossData() {
    const dbRef = ref(database);
    get(child(dbRef, 'worldBoss')).then((snapshot) => {
        if (snapshot.exists()) {
            const data = snapshot.val();
            worldBossHealth = data.health;
            playersDamage = data.playersDamage || {};
            if (currentScreen === 'worldBoss') {
                drawWorldBossBattle();
            }
        } else {
            console.log("No data available for world boss");
        }
    }).catch((error) => {
        console.error(error);
    });
}













        
        function drawWorldBossBattle() {
    //console.log('Drawing World Boss Battle');
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const worldBossImage = document.getElementById('worldBossImage');
    const bossX = canvas.width / 2 - worldBossImage.width / 2;
    const bossY = canvas.height / 2 - worldBossImage.height / 2;

    ctx.drawImage(worldBossImage, bossX, bossY);

    // Устанавливаем координаты текста выше босса и проверяем, что они в пределах экрана
    const healthTextY = bossY - 40 > 0 ? bossY - 40 : 40;


    // Рисуем полоску здоровья
    drawHealthBar(worldBossHealth, canvas.width - 210, 10, 200, 20, 'red');
    

    // Добавляем отображение рейтинга игроков
    const playersListX = canvas.width - 350; // смещение на 200 пикселей от правого края
const playersListStartY = canvas.height - 700; // смещение на 100 пикселей от низа экрана
    //const playersListStartY = canvas.height / 2 - (Object.keys(playersDamage).length * 15); // вертикальная координата для списка игроков, чтобы он был по центру
    let playersListY = playersListStartY - (Object.keys(playersDamage).length * 15); // вертикальная координата для списка игроков, чтобы он был по центру

    const lineHeight = 30; // задаем отступ между строками

    ctx.textAlign = 'right';
    ctx.font = '26px Roboto';
    ctx.strokeStyle = 'black'; // цвет обводки
    ctx.lineWidth = 4; // ширина обводки
    ctx.fillStyle = 'white'; // цвет текста
    // Отрисовка заголовка
    ctx.strokeText('Рейтинг игроков:', playersListX, playersListY);
    ctx.fillText('Рейтинг игроков:', playersListX, playersListY);
    playersListY += lineHeight; // увеличение отступа после заголовка
 

    Object.entries(playersDamage).sort(([, damageA], [, damageB]) => damageB - damageA).forEach(([player, damage], index) => {
        playersListY += lineHeight; // вертикальное смещение для каждой строки
        ctx.strokeText(`${index + 1}. ${player}: ${damage}`, playersListX, playersListY);
        ctx.fillText(`${index + 1}. ${player}: ${damage}`, playersListX, playersListY);
    });

    updateStatusBar();
    updateMonsterHealthDisplay();
}









function showHitAnimation() {
  let shakeCount = 8; 
  let shakeOffset = 10; 
  let currentShake = 0;
  let flashCount = 1; // Number of flashes
  let currentFlash = 0;
  let originalAlpha = 1; // Store the original alpha value

  function shakeAndFlash() {
    if (currentShake < shakeCount) {
      const offsetX = (Math.random() - 0.5) * shakeOffset;
      const offsetY = (Math.random() - 0.5) * shakeOffset;

      drawBattle(offsetX, offsetY); // Apply offset when drawing
      currentShake++;

    } else {
      // Monster is done shaking, now flash
      if (currentFlash < flashCount) {
        ctx.globalAlpha = (currentFlash % 2 === 0) ? originalAlpha : 0.5; // Toggle alpha
        drawBattle(); // Redraw with modified alpha
        currentFlash++;
      } else {
        ctx.globalAlpha = originalAlpha; // Reset alpha to original value
        drawBattle(); // Final redraw with normal alpha
        return; // Animation complete
      }
    }

    requestAnimationFrame(shakeAndFlash); 
  }

  shakeAndFlash(); 
}

function drawBattle(offsetX = 0, offsetY = 0) { 
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
    ctx.drawImage(battleBackgroundImage, 0, 0, canvas.width, canvas.height); // Draw background

    if (currentScreen === 'worldBoss') {
        // ... (existing world boss drawing logic) ...
    } else {
        const mobWidth = 600;
        const mobHeight = 580;
        const x = (canvas.width / 2) - (mobWidth / 2) + offsetX; // Apply offsetX
        const y = (canvas.height / 2) - (mobHeight / 2) + offsetY; // Apply offsetY
        ctx.drawImage(monsterImage, x, y, mobWidth, mobHeight); 

        drawHealthBar(monsterHealth, canvas.width - 210, 10, 200, 20, 'red');
    }

    updateStatusBar();
}




function drawHealthBar(health, x, y, width, height, color) {
    ctx.fillStyle = 'grey';
    ctx.fillRect(x, y, width, height);
    ctx.fillStyle = color;
    ctx.fillRect(x, y, width * (health / 1000000), height);  // Учитывая максимальное здоровье босса 1000000
}


        function updateShop() {
            document.getElementById('shopGold').textContent = gold;
        }



// Вызов функции загрузки данных при старте игры





function updateDamageList() {
    const damageList = document.getElementById('damageList');
    damageList.innerHTML = '';

    const sortedPlayers = Object.entries(playersDamage).sort(([, a], [, b]) => b - a);
    sortedPlayers.forEach(([player, damage]) => {
        const listItem = document.createElement('li');
        listItem.textContent = `${player}: ${damage} урона`;
        damageList.appendChild(listItem);
    });
}

function hitWorldBoss(playerName, damage) {
    if (worldBossHealth <= 0) return; // Проверка, чтобы не засчитывать урон после смерти босса

    if (!playersDamage[playerName]) {
        playersDamage[playerName] = 0;
    }
    playersDamage[playerName] += damage;
    worldBossHealth -= damage;
    if (worldBossHealth < 0) worldBossHealth = 0;
    updateWorldBossHealthDisplay();
    updateDamageList();
    syncWorldBossHealth();
    syncPlayersDamage();
    updateMonsterHealthDisplay(); //  Добавьте  вызов  здесь

    if (worldBossHealth <= 0) {
        worldBossWasKilled = true; // Устанавливаем  флаг, что босс был  убит 
        // Вызов функции отправки наград при смерти босса
        sendRewards();
  
    document.getElementById('monsterHealthContainer').style.display = 'none';
    document.getElementById('worldBossTimer').style.display  =  'block'; //  Показываем  таймер 
    startWorldBossTimer(); //  Запускаем  таймер 
    }
}



function updateWorldBossHealthDisplay() {
    //console.log(`Updating World Boss Health Display: ${worldBossHealth}`);
    document.getElementById('worldBossHealthValue').textContent = worldBossHealth;
}

function startBossBattle() {
    changeScreen('worldBoss');
    startUpdating(); // Убедитесь, что обновление запущено
}

function changeScreen(screen) {
  console.log(`Changing screen to: ${screen}`);
  currentScreen = screen;

  // Скрываем меню магазина
//   document.getElementById('shopMenu').style.display = 'none';

  // Управляем видимостью элементов в зависимости от экрана
  document.getElementById('monsterHealthDisplay').style.display = (screen === 'dungeon') ? 'block' : 'none';
  document.getElementById('crosshair').style.display = 'none';
  document.getElementById('mailButton').style.display = (screen === 'castle') ? 'block' : 'none';
  crosshair.style.display = (screen === 'battle' || screen === 'worldBoss') ? 'block' : 'none';
  document.getElementById('rebornButton').style.display = (screen === 'dungeon') ? 'block' : 'none';
  document.getElementById('pvpButton').style.display = 'none';
  document.getElementById('pvpLastBattles').style.display = 'none';
  document.getElementById('dailyQuestsMenu').style.display = 'none';

  // Скрываем полоску здоровья монстра, если не на экране dungeon или battle
  if (screen !== 'dungeon' && screen !== 'battle') {
    document.getElementById('monsterHealthContainer').style.display = 'none';
    updateStatusBar();
  }

  // Логика для экрана мирового босса
  if (screen === 'worldBoss') {
    document.getElementById('worldBossScreen').style.display = 'block';
    document.getElementById('statusBar').style.display = 'block';
    updateStatusBar();

    // Проверяем состояние босса перед отображением
    const worldBossRef = ref(database, 'worldBoss');

    // Отключаем предыдущий слушатель
    off(worldBossRef); 

    get(worldBossRef).then((snapshot) => {
      const data = snapshot.val();

      if (data.isAlive) {
        // Босс жив, отображаем полоску здоровья
        document.getElementById('monsterHealthContainer').style.display = 'block';
        document.getElementById('worldBossTimer').style.display = 'none';
      } else {
        // Босс мертв, отображаем таймер
        document.getElementById('monsterHealthContainer').style.display = 'none';
        document.getElementById('worldBossTimer').style.display = 'block';
      }

      drawWorldBossBattle();
      updateWorldBossTimer(); // Запускаем обновление таймера
    });
  } else {
    document.getElementById('worldBossScreen').style.display = 'none';
  }

  // Логика для других экранов
  if (screen === 'raid') {
    drawMenu();
  } else if (screen === 'dungeon') {
    showHealthBar();
    drawDungeonEntrance();
    document.getElementById('statusBar').style.display = 'block';
  // Автоматический переход на экран battle через 1 секунды
  setTimeout(() => {
      if (currentScreen === 'dungeon') { // Проверяем, что игрок все еще на dungeon
        const event = { clientX: canvas.width / 2, clientY: canvas.height / 2 }; // Создаем фиктивное событие клика по центру
        canvas.dispatchEvent(new MouseEvent('click', event)); // Вызываем событие клика
      }
    }, 1000);

  } else if (screen === 'arena') {
    drawArena();
    displayLastPvpBattles();
    document.getElementById('pvpLastBattles').style.display = 'block';
    document.getElementById('pvpButton').style.display = 'block';
  } else if (screen === 'castle') {
    drawCastle();
  } else if (screen === 'shop') {
    drawShop();
  } else if (screen === 'battle') {
    loadProgress(nickname).then(data => {
      console.log('Data after loading progress:', data);
      if (data) {
        currentLevel = data.currentLevel;
        gold = data.gold;
        playerHealth = data.playerHealth;
        weaponPower = data.weaponPower;
        weaponName = data.weaponName;
        weaponLevel = data.weaponLevel;
        levels = data.levels || levels;
        updateCharacterMenu();
      }
      document.getElementById('statusBar').style.display = 'block';
      updateStatusBar();
      startLevel(currentLevel);
    });
  }
}

window.changeScreen = changeScreen;

// Пример использования
document.getElementById('bottomMenu').querySelector('div').addEventListener('click', function() {
    changeScreen('arena');
});

function showWorldBossHealthBar() {
    const healthContainer =  document.getElementById('monsterHealthContainer'); 
    if (currentScreen === 'worldBoss') { //  Отображаем  полоску  только  на  экране  босса  
        healthContainer.style.display  =  'block'; 
    } else {
        healthContainer.style.display = 'none'; // Скрываем на  других  экранах 
    }
}
window.showWorldBossHealthBar = showWorldBossHealthBar; 

function syncWorldBossHealth() {
    set(ref(database, 'worldBoss/health'), worldBossHealth);
}

function syncPlayersDamage() {
    set(ref(database, 'worldBoss/playersDamage'), playersDamage);
}

function loadWorldBossData() {
    const dbRef = ref(database);
    return get(child(dbRef, 'worldBoss')).then((snapshot) => {
        if (snapshot.exists()) {
            const data = snapshot.val();
            worldBossHealth = data.health;
            playersDamage = data.playersDamage || {};
            //console.log(`Loaded World Boss Health: ${worldBossHealth}`);
            updateWorldBossHealthDisplay();
            updateDamageList();
        } else {
            console.log("No data available for world boss");
        }
    }).catch((error) => {
        console.error(error);
    });
}
       


function updateCharacterMenu() {
    playerHealth = calculateTotalHealth(); // Обновление текущего здоровья игрока
    document.getElementById('weapon').textContent = weaponName;
    document.getElementById('health').textContent = playerHealth;
    document.getElementById('damage').textContent = calculateTotalDamage();
    document.getElementById('gold').textContent = gold;
    document.getElementById('level').textContent = currentLevel;

    // Смена изображения персонажа при достижении уровня выше 10
    updateCharacterImage(); // Вызов функции для смены изображения

    updateStatusBar(); // Обновление статус бара
}
window.updateCharacterMenu = updateCharacterMenu;


function calculateTotalDamage() {
    let totalDamage = 0;
    heroes.forEach(hero => {
        if (hero.hired) {
            totalDamage += hero.damage;
        }
    });
    totalDamage += calculateTalentBonus('fury', talents.fury.level);
    // Проверяем существование  клана перед  добавлением  бонуса 
    if (currentClan && clans[currentClan]) {
        totalDamage += calculateClanDamageBonus(clans[currentClan].level);
    }
    return totalDamage;
}

window.calculateTotalDamage = calculateTotalDamage;

function calculateTotalHealth() {
    let totalHealth = 100; // базовое  здоровье 

    //  Добавление  бонуса  от  таланта "Древняя  Стойкость"
    totalHealth += calculateTalentBonus('resilience',  talents.resilience.level); 

    return totalHealth;
}
window.calculateTotalHealth = calculateTotalHealth;

let localGoldUpdated = false;

function updateStatusBar() {
    //console.log('updateStatusBar called'); // Логирование вызова функции

    if (!localGoldUpdated) {
        const playerGoldRef = ref(database, `players/${nickname}/gold`);
        get(playerGoldRef).then((snapshot) => {
            const goldAmount = snapshot.val() || 0;
           // console.log(`Gold amount retrieved from database: ${goldAmount}`); // Логирование полученного значения из базы данных

            document.getElementById('statusGold').textContent = goldAmount;
            gold = goldAmount; // Обновляем глобальную переменную золота
          //  console.log(`Global gold variable updated: ${gold}`); // Логирование обновленного значения глобальной переменной

        }).catch((error) => {
            console.error('Error getting gold:', error);
        });
    } else {
        localGoldUpdated = false; // Сбрасываем флаг после использования
    }

    document.getElementById('statusLevel').textContent = currentLevel;
    document.getElementById('playerHealthBar').style.width = playerHealth + '%'; // Обновление ширины полосы здоровья
    document.getElementById('statusDamage').textContent = calculateTotalDamage(); // Обновление значения урона
    document.getElementById('statusHealth').textContent =  playerHealth; //  Обновляем  отображение  здоровья
    document.getElementById('chaosEssence').textContent = chaosEssence; // Обновляем отображение  chaosEssence
    document.getElementById('statusRewardMultiplier').textContent = rewardMultiplier.toFixed(1); // Обновление множителя награды
    

    //console.log('Status bar updated'); // Логирование обновления статус бара
}
window.updateStatusBar = updateStatusBar;


        canvas.addEventListener('click', function(event) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    if (currentScreen === 'menu') {
        currentScreen = 'dungeon';
        drawDungeonEntrance();
    } else if (currentScreen === 'dungeon') {
        const gateCenterX = canvas.width / 2;
        const gateCenterY = canvas.height / 2;
        if (mouseX > gateCenterX - dungeonGateImage.width / 2 &&
            mouseX < gateCenterX + dungeonGateImage.width / 2 &&
            mouseY > gateCenterY - dungeonGateImage.height / 2) {
            currentScreen = 'battle';
            drawBattle();
            crosshair.style.display = 'block';
        } else {
            levels.forEach((level, index) => {
                const { x, y } = getLevelPosition(index);
                const radius = 25;

                if (Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2) < radius) {
                    if (levels[index].completed || index === currentLevel - 1) {
                        startLevel(level.number);
                    }
                }
            });
        }
    } else if (currentScreen === 'battle') {
        hitMonster(event);
    } else if (currentScreen === 'worldBoss') {
        console.log('Click detected on World Boss screen.');
        hitWorldBoss(nickname, calculateTotalDamage());
        syncWorldBossHealth();
        syncPlayersDamage();
    }
});

document.getElementById('nicknameInput').addEventListener('keyup', function(event) {
    if (event.key === 'Enter') {
        startGame(); 
    }
});
       
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            if (currentScreen === 'menu') {
                drawMenu();
            } else if (currentScreen === 'dungeon') {
                drawDungeonEntrance();
            } else if (currentScreen === 'battle') {
                drawBattle();
            } else if (currentScreen === 'levelMap') {
                drawLevelMap();
            } else if (currentScreen === 'victory') {
                drawVictoryScreen();
            } else if (currentScreen === 'shop') {
                drawShop();
            }
        }

        window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Обработка изменения ориентации экрана
        if (window.innerHeight > window.innerWidth) {
            // Вертикальная ориентация
            document.body.classList.add('portrait');
            document.body.classList.remove('landscape');
        } else {
            // Горизонтальная ориентация
            document.body.classList.add('landscape');
            document.body.classList.remove('portrait');
        }

        // Перерисовка экрана в зависимости от текущего состояния
        if (currentScreen === 'battle') {
            drawBattle(); // Перерисовка экрана боя
        } else if (currentScreen === 'arena') {
            drawArena(); // Перерисовка арены
        } else if (currentScreen === 'castle') {
            drawCastle(); // Перерисовка замка
        } else if (currentScreen === 'raid') {
            drawMenu(); // Перерисовка рейда
        } else if (currentScreen === 'menu') {
            drawMenu(); // Перерисовка меню
        } else if (currentScreen === 'dungeon') {
            drawDungeonEntrance(); // Перерисовка подземелья
        } else if (currentScreen === 'worldBoss') {
            drawWorldBossBattle(); // Перерисовка боя с мировым боссом
        }
    });

    // Инициализация классов ориентации при загрузке страницы
    if (window.innerHeight > window.innerWidth) {
        document.body.classList.add('portrait');
        document.body.classList.remove('landscape');
    } else {
        document.body.classList.add('landscape');
        document.body.classList.remove('portrait');
    }



        gameLoop();


        window.onload = async function() {  //  Добавьте  async  
    console.log("Page loaded,  initializing  game."); 
    addHeroesToMenu(); 
    loadWorldBossData(); 
    gameLoop();
    changeScreen('menu'); 
    startUpdating(); 
    startHourlyReset(); 
    updateMonsterHealthDisplay(); 
    // Добавьте await  перед  updateClanList  
    await updateClanList(); 
    
    createCategoryButtons();  //  Создаем кнопки  для  категорий  заданий
    // Запускаем  таймер для  ежедневного  сброса  заданий  
    //setInterval(resetDailyQuests,  1000  *  60  *  60 *  24);  //  Вызываем  каждые  24  часа  
};

// function clearrQueue() {
//     const queueRef = ref(database, 'pvpQueue');
//     set(queueRef, null)
//     .then(() => {
//         console.log('Очередь очищена.');
//     })
//     .catch((error) => {
//         console.error('Ошибка при очистке очереди:', error);
//     });
// }
// window.clearQueue = clearQueue;



// Обновленная функция  sendMessage 
function sendMessage() {
    const chatMessageInput = document.getElementById('chatMessageInput'); 
    const message = chatMessageInput.value.trim();

    if (message  &&  nickname) { 
        const messageData = {
            text: message,
            timestamp: new Date().toISOString(), 
            nickname: nickname 
        };

        // Отправляем  сообщение  в  соответствующий чат
        if (currentChat ===  'global') { 
            const newMessageRef = push(ref(database,  'chat/messages')); 
            set(newMessageRef, messageData); 
        } else if (currentChat  ===  'clan' && currentClan) { 
            const newMessageRef = push(ref(database,  `clans/${currentClan}/chat`)); 
            set(newMessageRef, messageData); 
        } else { 
        displayChatMessage({ 
            nickname:  'System',
            text:  'Вы  не  состоите в  клане!'  
        }); 
        return;
        }

        chatMessageInput.value = ''; 
    } else  if  (!nickname) {
        alert('Пожалуйста,  введите никнейм, прежде чем отправлять сообщение.');
    }
}
window.sendMessage = sendMessage;

// Слушатель для отправки сообщений при нажатии на Enter
document.getElementById('chatMessageInput').addEventListener('keypress',  function(event) {
    // Проверка  фокуса
    if (event.key === 'Enter'  &&  document.activeElement === this) { 
        sendMessage(); 
    } 
});


// Слушатель для новых сообщений
const chatMessages = document.getElementById('chatMessages');
onValue(ref(database, 'chat/messages'), function(snapshot) {
    chatMessages.innerHTML = '';
    snapshot.forEach(function(childSnapshot) {
        const message = childSnapshot.val();
        const messageElement = document.createElement('div');
        messageElement.innerHTML = `<strong>${message.nickname}:</strong> ${message.text}`;
        chatMessages.appendChild(messageElement);
    });
    chatMessages.scrollTop = chatMessages.scrollHeight; // Прокрутка вниз для новых сообщений
});

//  Функция  для добавления  сообщения  в чат  
function displayChatMessage(message) {
    const  chatMessages  = document.getElementById('chatMessages');
    const  messageElement  = document.createElement('div'); 
    messageElement.innerHTML =  `<strong>${message.nickname}:</strong>  ${message.text}`;
    chatMessages.appendChild(messageElement);
    chatMessages.scrollTop = chatMessages.scrollHeight; //  Прокрутка вниз
}


// Находим кнопку PvP
const pvpButton = document.getElementById('pvpButton');
pvpButton.addEventListener('click', openPvpRegistration); 

// Находим кнопку "Да" в окне регистрации
const pvpRegistrationButton = document.querySelector('#pvpRegistration button:first-of-type'); // Выбираем первую кнопку

// Привязываем обработчик события "click"
pvpRegistrationButton.addEventListener('click', registerForPvp); 



    </script>
</body>
</html>